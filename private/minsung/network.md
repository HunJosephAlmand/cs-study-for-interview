[toc]



# OSI 7계층



## 1. 물리 계층


*  bitstream을 두 노드 사이에 연결된 물리적인 데이터 링크를 통해 전송.
* 기기 예시
  * 네트워크 인터페이스 컨트롤러
  * 이더넷(유선 인터넷) 허브
  * 네트워크 스위치
* 디지털 비트를 특정 신호로 인코딩
  * 전자
  * 라디오
  * 광학
* 특정 아날로그 신호로의 인코딩이 어떻게 이루어지는지 결정
  * ex) 1 비트 : 5v -> 0v로 바뀔 때

## 2. 데이터 링크 계층


* 같은 네트워크에 직접적으로 연결된 두 노드의 데이터 전송 프로토콜
* 물리 계층에서 나타날 수 있는 오류들을 감지하고 수정한다.
  * 두 개 이상의 호스트가 같은 회선을 통해 데이터를 동시에 전송할 때

* 물리적으로 연결된 두 기기의 커넥션을 생성하고 제거하는 프로토콜을 결정한다.
* 흐름 제어
  * 수신 노드의 수신 속도가 송신 노드의 송신 속도보다 느릴 때 발생하는 문제 방지.
  * 송신 노드에게 수신 노드가 feedback을 보내는 여부에 따라 분류
* 두 개의 하위 계층으로 나뉜다.
  * Medium Access Control(MAC)
    * 네트워크에 있는 기기들이 어떤 방식으로 전송을 위한 중개 매체에 접근하고, 접근을 허용 받는지를 결정
  * Logical Link Control(LLC) 
    * 네트워크 계층들을 식별하고, 캡슐화한다.
    * 오류 체크
    * 프레임 동기화
  * 이더넷, 와이파이, 지그비

## 3. 네트워크 계층

* **다른 네트워크**에 있는 노드들 간의 연결 기능 및 절차적 수단 제공.
* 네트워크
  * 다수의 노드들이 연결될 수 있는 중간 매체
  * 네트워크 안에서 모든 노드들은 고유의 주소를 갖는다.
  * 기기들은 메시지를 전송할 때 전송 메시지 내용과 목적지 주소만 네트워크에 제시하면 네트워크가 내부적으로 구현된 방법으로 메시지를 전달한다.
  * 보통 routing을 통해 중간 노드들을 거쳐서 목적지 노드까지 전달한다.
* 데이터가 너무 클 경우, 네트워크에서 메시지를 나눠서 전송한다. 
  * 나눠진 메시지는 목적지 노드가 재결합한다.
* 네트워크 계층에서는 신뢰성 있는 메시지 전송을 보장하지 않는다.
* IP 뿐만 아니라 다른 프로토콜들도 존재
  * ARP : 논리 주소 -> 물리 주소(broadcast)
  * RARP : 물리 주소 -> 논리 주소
  * ICMP
    * 연결 상태 제어 및 관리(서버가 닫혀 있는가 등)


## 4. 전송 계층


* 소스 호스트의 애플리케이션과 목적지 호스트의 애플리케이션 사이의 **신뢰성 있는 데이터 전송**을 위한 수단을 제공한다.
* 종류
  * Connection-oriented(연결형)
    * TCP, COTP
    * segment를 추적하고, segment 전송이 실패했을 경우, 다시 전송 요청(hand-shake)
    * 전송한 데이터가 제대로 전송되었는지 acknowlegement, 확인이 되었을 경우 다음 데이터 전송

  * Connectionless(비연결형)
    * UDP, CLTP
    * 신뢰성 보장 X
    * 패킷 손실, 순서, 오류, 중복 허용
      * 사용하는 애플리케이션에서 치명적이지 않음
    * 스트리밍에서 사용
* 거대한 Protocol Data Unit 또는 데이터 스트림을 "segment" 라는 덩어리로 나눈다.=> segmentation

  * 네트워크 계층의 최대 전송 패킷 사이즈(Maximum Transmission Unit) 이내여야 한다.
  * 네트워크 계층과 데이터 계층이 허용할 정도로 segment 단위의 최대 데이터 크기가 결정된다.
    * 이더넷의 MTU - 1500 bytes
* 흐름 제어
* 오류 제어
  * 변조
    * 체크섬으로 확인
    * 송신쪽 헤더에서 보낸 체크섬과 수신 쪽에서 계산한 체크섬을 비교
  * 누락
  * 순서
* 순서 제어

  *  acknowledgement
* cf) TLS는 전송 계층과 세션 계층의 특징을 골고루 갖고있다.(정확하게 OSI 모델과 일치하지 않음)

## 5. 세션 계층

* 두 애플리케이션 사이의 연결(세션) 관리

  * 연결 수립, 종료, 동기화, 유지 관리

* 사용자 로그인, 사용자 로그오프

* 인증 프로토콜
  * FTP NFS 클라이언트

* 통신 방식
  * 동시 송수신 방식(duplex)
  * 반 이중 방식(half-duplex)
  * 전 이중 방식(full duplex)

* 토큰 관리

* 체크포인트를 두어서 연결이 실패했을 경우, 실패한 지점부터 연결을 재개시킬 수 있게 한다.

* 음성이나 비디오 스트림 관련 세션 제어 절차를 성립

* 요청 / 응답 구조

* 자바에서의 예시 : session beans

  * 세션이 수립된 동안에만 저장.
  * 사용자 정보 저장

  

## 6. 표현 계층

* 코드 사이의 번역 담당

* 데이터 포맷
* 데이터 변환
* 애플리케이션에서 전송하는 데이터를 특정 형태로 인코딩/디코딩
* 프로토콜 변환, 데이터 암호화, 데이터 복호화, 데이터 압축, 데이터 압축 해제, OS 간의 데이터 표현 비호환성
* 애플리케이션 계층이 수용할 수 있는 형태로 데이터를 변환
* 예시
  * 객체, 기타 자료 구조의 직렬화(XML, JSON);
  * EBCDIC -> ASCII

## 7. 응용 계층

* 프로토콜 스택을 통해 전달받은 패킷을 다시 파싱해 응용 소프트웨어를 통해 최종적으로 사용자까지 전달

* 사용자와 가장 가까이 있는 계층

* 응용 프로그램들을 매개로 사용자와 직접적인 상호작용.

* 파일 공유, 메시지 처리, 데이터베이스 접근

* HTTP, FTP, SMB/CIFS, TFTP, SMTP, DNS

* 애플리케이션 개체와, 애플리케이션의 구분

  * 예약 웹사이트 애플리케이션의 개체들

    1. HTTP
       * 사용자의 HTTP 프로토콜 요청/응답

    2. RPC
       * 예약 데이터베이스 예약 요청 저장

# TCP/IP 4계층

* 인터넷 혹은 유사 컴퓨너 네트워크에서 사용되는 통신 프로토콜의 집합

## 응용 계층

* OSI 7계층의 응용 계층 + 표현 계층 + 세션 계층
* process to process

## 전송 계층

* host to host

## 인터넷 계층

* 독립적인 네트워크들의 연결 (= 라우팅)

## 링크 계층

* OSI 7 계층의 물리 계층 + 데이터 링크 계층
* 호스트와 직접 연결된 로컬 네트워크 연결 (= link)
  * 라우터를 거치지 않은 직접 연결된 호스트들을 포함한다.

# TCP/UDP

## TCP

가상 회선 구축(vs UDP)

### 연결 성립(3-way handshake)

* 클라이언트가 SYN(n) 패킷 전송
  * 연결 요청 패킷
* 서버는 패킷을 받아서 ACK(n + 1), SYN(m) 패킷 전송
  * ack를 통해 서버가 성공적으로 클라이언트의 요청을 받을 수 있는 상태임 알 수 있음
* 클라이언트는 패킷을 받아서 ACK(m + 1)과 데이터가 담긴 패킷을 전송
  * ack를 통해 클라이언트가 서버의 패킷을 제대로 받았다는 것을 알 수 있음
* 연결 수립

### 연결 종료(4-way handshake)

* 데이터를 모두 받은 클라이언트는 서버에게 FIN 패킷 전송
  * 이 때 연결은 유지한다. 서버가 다 보내지 못한 패킷이 존재할 수 있으므로
*  서버는 FIN 패킷을 성공적으로 받았다고 클라이언트에게 ACK 패킷을 전송
* 서버는 연결을 닫을 준비(CLOSE_WAIT) 상태가 되고, 데이터를 전부 전송한 서버는 클라이언트에게 FIN 패킷을 전송
* 서버로부터 FIN 패킷을 받은 클라이언트는 서버에게 FIN 패킷을 받았다는 ACK 패킷을 보내고, 일정 시간 뒤에 커넥션을 종료(TIME_WAIT)
  * TIME_WAIT이 있는 이유
    * 서버가 커넥션을 성공적으로 종료시키기를 보장
    * 서버가 ACK를 받고 커넥션을 종료하기 까지 시간이 걸림
    * 없을 경우 서버가 커넥션을 종료하기 전에 클라이언트가 새로운 커넥션 형성 요청을 보낼 수 있음
* ACK 패킷을 받은 서버는 커넥션을 종료한다.

### 흐름 제어

* 패킷 전송 호스트와 과 수신 호스트의 처리 속도 조절
  * 수신 호스트의 패킷 처리 속도가 느릴 경우 송신 호스트에서 초당 전송 패킷 수 감소

#### 대표 알고리즘

* stop and wait
  * 전송한 패킷에 대한  ack 응답을 받으면 다음 패킷 전송
  * 매우 느림
* sliding window
  * 수신 호스트는 TCP 헤더에 있는 receive window 필드를 통해 버퍼에 추가 데이터를 얼마나 더 받을 수 있는지 알려준다.
  * ack 확인을 하지 않고 전송한다.
  * 3-way handshake에서 송신, 수신 윈도우가 동기화된다.
  * 수신 호스트는 receive window 필드를 읽고, receive window에 작성된 데이터만큼 데이터를 전송한다.(ack를 확인하지 않고)
  * receive window가 0이 되면

### 혼잡 제어

* 네트워크 성능이 저하되는 혼잡 충돌 상황을 피하기 위해 사용
* 네트워크에 전송되는 패킷의 상-하한선 조정
* slow-start, 
  * MSS(최대 세그먼트 크기)를 낮은 숫자에서 점진적으로 증가시키는 방식
  * 패킷이 성공적으로 도착하면 윈도우 크기를 지수적으로 증가
  * CWND(congestion window size)가 한계점(sshthreshold)에 도달하면 윈도우 크기를 1로 줄인다.
* fast retransmit
  * 타이머를 이용해 보낸 패킷이 손실되었는지 파악한다.(기존)
  * 같은 acknowledgment를 3번 이상 받을 경우, 순서대로 보낸 패킷이 중간에 손실되었다고 간주하고 타이머를 기다리지 않고 해당 패킷부터 다시 재전송한다.
* fast recovery
  * 혼잡 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄인 다음에, 선형적으로 증가시킨다.

### 오류 제어

* checksum 필드를 통해 패킷이 변조되었는지 확인할 수 있다.
* sequence number로 중복된 패킷이나 순서에서 벗어난 패킷을 제거할 수 있다.
* acknowledgement로 전송에 실패한 패킷을 재전송할 수 있다.
* sequence number가 난수
  * 중복 가능성 배제

## IPV4 vs IPV6

* IPV4
  * 32비트
  * 43억
  * 자리수 별 10진수 포맷
  * IP 주소 부족 현상
* IPV6
  * 128 비트
  * 자리수 별 16진수 포맷
  * IP 주소 부족 현상 없음
  * 더 간단한 라우터
  * 모바일 최적화
  * 더 많은 데이터 송신
  * 1%만 사용
  * 통신 방식의 변경
    * unicast
      * ipv4, ipv6
    * multicast
      * 선택해서 뿌린다.
      * 연결 되어 있으면 보낼 수 있음
      * ipv4, iv6
    * broadcast
      * 한 네트워크 안에 있는 모든 기기한테 뿌림
      * ipv4
    * anycast
      * 가장 가까운 노드랑 통신 방식
      * ipv6



# HTTP

## METHOD

#### GET

* 리소스 가져오기 요청

* 멱등성 O

#### POST

* 서버로 데이터 전송 => 서버의 상태 변경
* 멱등성 X

#### PUT

* 요청 페이로드를 통해 새로운 리소스를 생성하거나, 대상 리소스를 나타내는 데이터 변경

* 멱등성 O

* PUT 요청을 통해 리소스가 성공적으로 생성되었을 경우 201 응답을 보내야 한다.

  ```http
  HTTP/1.1 201 Created
  Content-Location: /new.html
  ```

* 이미 저장된 리소스를 성공적으로 수정했을 경우 200(OK) 또는 204 응답을 보내야 한다.

  ```http
  HTTP/1.1 204 No Content
  Content-Location: /existing.html
  ```

#### PATCH

* 리소스의 부분적인 수정
  * PUT은 리소스의 완전한 교체만 허용
* 멱등성 X
  * 하지만 PUT처럼 사용할 경우 멱등성 가지게 할 수 있음

#### DELETE

* 지정한 리소스 삭제
* 멱등성 O

#### HEAD

* 특정 리소스를 GET 메서드로 요청했을 때 돌아올 헤더 요청
* 본문 X
* 멱등성 O
* Content-Length 같은 컨텐츠 설명 헤더

#### OPTIONS

* 목표 리소스와의 통신 옵션을 설명하기 위해 사용
* CORS에서 preflight 요청을 할 때 사용
  * Access-Control-Request-Headers
    * 실제 요청 시 전달될 헤더들을 명시
  * Access-Control-Request-Method
    * 실제 요청 메서드를 명시
  * 서버는 응답으로 Access-Control-Allow-(Methods, Headers, Origin)을 통해 어떤 CORS 요청이 가능한 지 알려준다.

#### TRACE

* loop-back 디버깅 테스트용
* 멱등성 O

#### CONNECT

* 리소스에 대한 양방향 연결을 위한 메서드
* SSL 웹사이트 접속에 사용
  * 원하는 목적지에 대한 TCP 연결을 위해 프록시 서버에 CONNECT 요청
  * 프록시 서버는 클라이언트를 대신하여 연결 수립
* 홉바이홉
* 멱등성 X





## STATUS CODE

#### 1XX Informational

#### 2xx Success

* 200 OK
  * 요청이 성공했음
* 201 Created
  * 자원 요청이 성공적으로 수행되었음을 암시(Post)
  * 요청 메시지의 URL이나 Location 헤더에 생성된 자원 위치 표기

#### 3xx Redirect

* 301 Moved Permanently
  * 원래 이 URL에 존재하는 리소스가 다른 URL로 이동했음
* 304 Not Modified
  * 리소스가 수정되지 않았으므로, 캐시된 자원을 사용하라는 redirect
  * If-Modified-Since, If-None-Match 등의 요청 헤더가 있을 때 응다



#### 4xx Client Error

* 400 Bad Request
  * 클라이어늩의 잘못된 요청 구문, 유효하지 않은 메시지 등을 감지해 요청을 처리하지 않는 다는 것을 의미

* 401 Unauthorized

  * 해당 리소스에 대한 유효한 인증 자격 증명이 없어서 보내는 메시지

  * WWW-Authenticate 를 통해 인증 방법에 대한 정보 응답

  * 인증을 할 수 있다.(인증 양식에 맞춰서 유효할 경우 요청 성공)

  * ```http
    HTTP/1.1 401 Unauthorized
    Date: Wed, 21 Oct 2015 07:28:00 GMT
    WWW-Authenticate: Basic realm="Access to staging site"
    ```

* 403 Forbidden
  * 서버에 요청이 전달되었으나, 권한이 없어서 거절되었음을 전송
  * 재인증을 하더라도 접속 거절
* 404 Not Found
  * 서버가 요청받은 리소스를 찾을 수 없다.
  * broken-link dead link

#### 5xx Server Error

* 500 Internal Server Error
  * 서버의 에러를 총칭하는 응답



## HTTP 1.1 VS HTTP 2.0

* HTTP 2.0은 chunked transfer encoding을 사용하지 않는다.
* HTTP 2.0은 같은 서버에 대한 하나의 커넥션으로 여러 요청을 처리한다. (멀티플렉ㄱ싱)
  * 각 요청 패킷을 쪼개서 stream으로 처리한다. 각 요청마다 고유의 stream id가 부여된다.
* HTTP 2.0은 요청 파이프라인을 사용하지 않는다.
* PUSH를 통해 하나의 요청이후에 필요한 자원들을 예측해서 응답에 미리 담아서 준다.
  * index.html => script.js, main.css 등 파일과 같이 응답
* 대부분의 브라우저에서 HTTPS를 강제한다.
