## Spring  
![](https://i.imgur.com/BSSdBCv.png)
Java 기반의 웹 어플리케이션 개발을 위한 오픈소스 프레임워크 
> 라이브러리 : 개발자가 호출하여 사용할 수 있는 도구의 집합 
> 프레임워크 : 소프트웨어의 특정 문제를 해결하기 위한 상호 협력하는 클래스와 인터페이스의 집합, 주도권이 프레임워크에게 있다.

### 장점 
- POJO를 사용한 객체지향적 구성 
- DI, IoC를 통한 객체 관계 구성으로 결합도를 낮추고 재사용성을 높임 
- AOP 지원 

## Spring MVC 
프론트 컨틀롤러 패턴에 기초한 웹 MVC 프레임워크 
Spring 프레임워크의 하위 모듈이며, Model, View, Controller를 명확하게 분리하여 매우 유연하고 확장성이 좋다는 특징이 있다.
Spring MVC 이전까지는 서블릿이 컨트롤러 역할을 하기 때문에 URL마다 직접 매핑을 해줘야 했고 인스턴스도 생성해야 했었다. 또한, 각 서블릿마다 공통 기능을 하는 코드들이 중복해서 발생하여 유지 보수 하기 어려웠다.
모든 요청을 프론트 컨트롤러(하나의 서블릿)에게 보내고, 프론트 컨트롤러는 각 요청에 맞는 컨트롤러를 찾아서 호출하는 역할을 하는 프론트 컨트롤러 패턴을 통해 공통 기능은 프론트 컨틀롤러에서 처리하고, 서로 다른 코드들만 각 컨트롤러에서 처리할 수 있게 되었다.

### MVC 패턴 
하나의 서블릿이나 JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하게 되면 하나의 영역에서 너무 많은 역할을 부담지게 되고 유지보수가 어려워지는 결과를 낳는다. 
이를 해결해주기 위해  각 영역에서 자신의 역할만 담당하도록 분리한 디자인 패턴이 MVC 패턴이다.
- Model : 표현하고자 하는 데이터
- View : 사용자에게 보여지는 화면 즉, UI 
- Controller : 데이터와 비즈니스 로직 사이의 상호 동작을 관리 즉, 모델과 뷰를 통제 


#### MVC 1 
![](https://i.imgur.com/TsgIp4p.png)
View와 Controller의 책임을 모두 JSP가 담당한다. 
JSP 하나에 많은 책임을 주다보니 재사용성도 떨이지고 유지보수가 어려워진다.

#### MVC 2 
![](https://i.imgur.com/UaMmAji.png)
MVC1과 다르게 Controller와 View의 책임이 나눠지게 되었다.
요청을 서블릿으로 받게 된다. (Controller 역할)
선택된 서블릿은 요청 객체에 대한 서비스 로직을 수행하고, 서비스 계층에서 모델을 가져와 요청에 바인딩한다. 그리고 해당 요청을 자바코드와 분리되어 있는 JSP를 찾아서 바인딩하게 된다. (View 역할)


## Spring Boot 
Spring 설정들을 자동화하는 Spring 기반의 프레임 워크
즉, Spring 애플리케이션을 쉽게 만들 수 있게 해준다.
- 간편한 설정 (자동 설정)
	- AutoConfiguration을 이용
- 편리한 의존성 관리 & 자동 권장 버전 관리 
	- spring boot starter dependency를 통해 다양한 패키지수용
- 내장 서버로 인한 간단한 배포 서버 구축 가능 
- 스프링 프레임워크 요소를 쉽게 사용 가능


## Dispatcher Servlet 
가장 앞단에서 HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러 (Front Controller)
Dispatcher Servlet은 Spring MVC의 핵심 요소로써, 클라이언트로부터 어떤 요청이 들어오면 서블릿 컨테이너가 요청을 받게 된다. 이후 공통 작업을 Dispatcher Servlet에서 처리하고, 이외 작업은 세부 컨트롤러에게 위임하게 된다. 


### 동작 흐름 
![](https://i.imgur.com/2PNQFp4.png)
![](https://i.imgur.com/DYhpWbr.png)
[출처](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1/dashboard)
1. DispatcherServlet으로 클라이언트의 웹 요청이 들어온다. 
2. 웹 요청을 Handler Mapping에 위임하여 해당 요청을 처리할 Handler 즉, Controller를 탐색한다. 
3. 찾은 handler를 실행할 수 있는 HandlerAdapter를 탐색한다. 
4. 찾은 Handler Adapter를 사용하여 실제 Handler의 메소드를 실행한다. 
5. Handler Adapter는 Handler가 반환하는 정보를 Model, View로 변환해 반환한다. 
6. View이름을 ViewResolver에게 전달하고, ViewResolver는 View의 논리 이름을 물리 이름으로 바꾸고 렌더링 역할을 담당하는 View 객체를 반환한다. 
7. 최종적으로 DispatcherServlet은 View결과(HttpServletResponse)를 클라이언트에게 반환한다. 
위 흐름은 스프링MVC 기준 @Controller 기준이며, @RestController의 경우 6,7번 과정이 생략된다. 즉, ViewResolver를 타지 않고 반환 값에 알맞은 MessageConverter를 찾아 응답 본문을 작성한다. 
![](https://i.imgur.com/ZrkkThp.png)


### 정적 자원의 처리 
Dispatcher Servlet이 모든 요청을 처리하다보니 정적 파일에 대한 요청마저 가로채는 문제점이 발생한다. 
이러한 문제를 해결하기 위해 두가지 방법을 고안하게 된다. 
1. 정적 자원에 대한 요청과 어플리케이션에 대한 요청을 분리 
	- /apps의 URL로 접근시 Dispatcher Servlet이 담당 
	- /resources의 URL로 접근시 Dispatcher Servlet이 담당하지 않는다. 
	- 이 방법은 코드가 지저분해지며 URL에 붙여줘야 한다는 한계가 있다.
2. 어플리케이션에 대한 요청을 탐색하고 없으면 정적 자원에 대한 요청으로 처리 
	- Dispatcher Servlet이 요청을 처리할 컨트롤러를 먼저 찾고, 요청에 대한 컨트롤러를 찾을 수 없는 경우 2차적으로 정적 자원 경로를 탐색하여 자원을 탐색한다. 


### Controller 1개는 어떻게 여러 요청을 처리할까? 
톰캣은 기본적으로 200개의 작업 스레드가 존재한다. 톰캣은 하나의 프로세스에서 동작하며, 내부적으로 스레드 풀을 만들어 HTTP 요청이 오면 스레드 풀에서 스레드 하나를 가져오게 된다. 따라서 여러 요청이 올 시 각각 스레드를 생성하여 하나의 컨트롤러에 요청을 한다. 
이때, Controller는 싱글톤 빈으로 등록되기 때문에 여러 스레드에서 접근을 해도 Thread-safe하므로 여러 요청을 처리할 수 있다.

## IoC
Inversion of Control으로써, 제어의 역전이다. 
스프링 어플리케이션에서는 빈의 생성, 관계설정, 사용, 제거 등의 작업을 어플리케이션 코드 대신 스프링 컨테이너가 담당하게 된다. 
이를 스프링 컨테이너가 코드 대신 빈에 대한 제어권을 갖고 있다 해서 IoC라고 부른다. 
스프링 컨테이너를 IoC 컨테이너라고 부르기도 한다. 

### IoC 컨테이너 
스프링에선 IoC를 담당하는 컨테이너를 빈 팩토리, DI 컨테이너, 어플리케이션 컨텍스트라고 부르기도 한다. 
스프링 컨테이너는 DI 작업 외에도 여러 일을 하기 때문에 이를 어플리케이션 컨텍스트라고 부른다. 
즉, 어플리케이션 컨텍스트는 그 자체로 IoC와 DI 그 이상의 기능을 가지고 있다고 보면 된다. 

#### 어플리케이션 컨텍스트 
![](https://i.imgur.com/Gw9SmKV.png)
[출처](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard)
- BeanFactory 
	- 스프링 컨테이너의 최상위 인터페이스 
	- 스프링 빈을 관리하고 조회하는 역할 
- ApplicationContext 
	- BeanFactory를 상속받으며 추가적인 기능을 제공하는 인터페이스이다.
		- 메시지 국제화 기능, 환경변수 등등

## DI - 의존관계 주입 
> 의존성 : 한 객체가 다른 객체를 사용할 때 의존성이 있다고 한다. 
> 파라미터나 리턴 값, 지역변수 등 다른 객체를 참조하는 것

외부에서 두 객체 간의 관계를 결정하는 것으로 의존관계를 외부 즉, 스프링 컨테이너에서 결정하고 주입하는 것이다.
인터페이스를 사이에 둠으로써 클래스 레벨에서는 의존관계가 고정되지 않도록 하고 런타임 시에 관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮출 수 있게 된다.
> 1.  클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스만 의존하고 있어야 한다. 
> 2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다. 
> 3. 의존관계는 사용할 오브젝트에 대한 래퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.
> 토비의 스프링 3.1 

### 왜 필요할까? 
의존관계 주입을 사용하지 않고 직접 생성하여 참조하게 된다면 2가지 문제점이 발생한다. 
1. 두 클래스가 강하게 결합되어 있다. 
	- 강하게 결합되어 있어 변경이 필요한 경우 직접 생성자에 변경이 필요하다. 
2. 객체들 간의 관계가 아닌 클래스 간의 관계가 맺어진다. 

### 장점 
- 의존성이 줄어든다. 
	- 유연하게 변경이 가능하다. 
	- 주입받는 대상이 변하더라도 그 구현 자체를 수정할 일이 없거나 줄어들게 된다. 
- 재사용성이 높은 코드가 된다. 
- 테스트하기 좋은 코드가 된다.
- 가독성이 높아진다. 
	- 기능을 분리하기 때문에 (관심사 분리)


### 종류 
> 결론은 생성자 주입을 사용하는 것이 좋다. 
> 생성자 -> 필드 -> 메서드 순으로 호출됨.

#### 1. 생성자 주입 
생성자의 호출 시점에 1회 호출 되는 것이 보장된다. 
- 주입받은 객체가 변하지 않고 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용할 수 있다. (불변, 필수)
	- 순환 참조 방지 가능
- final 키워드 선언이 가능하다. 
- 테스트 코드 작성이 용이하다.
- 생성자가 단 하나의 경우 `@Autowired` 어노테이션을 생략할 수 있다.

#### 2. 필드 주입 
`@Autowird` 어노테이션을 통해 필드에 바로 의존관계를 주입하는 방법 
- final 키워드 선언이 불가능하다. 
- 의존 관계 파악이 힘들다. 
- 외부에서 접근이 불가능하다. 
	- 테스트가 힘들다.
- 반드시 DI 프레임워크가 필요하다. 
- 스프링 부트 2.6 이후부터 순환 참조 방지 가능


#### 3. 수정자 주입 
setter를 통해 의존 관계를 주입하는 방법
- 변경 가능성이 있는 의존관계에 사용 
- setter 메서드에 `@Autowired` 어노테이션을 붙여야 한다. 


#### 4. 일반 메서드 주입 
일반 메서드를 통해서 주입받을 수 도 있다. 


### 순환 참조 
서로 다른 여러 빈들이 서로를 참조하고 있음을 의미 
수정자 주입의 경우 객체 생성 후 비즈니스 로직 상에서 순환 참조가 일어나기 때문에 컴파일 단계에서 순환 참조를 잡을 수 없게 된다. 
하지만 생성자 주입은 스프링 컨테이너가 빈을 생성하는 시점에서 순환참조를 확인할 수 있기 때문에 컴파일 단계에서 순환 참조를 잡을 수 있다. 


### @Autowired 
DI를 할 때 사용하는 어노테이션으로, 의존 관계의 타입에 해당하는 빈을 찾아 주입하는 역할을 한다. 
실제 타깃에 `@Autowired`가 붙은 빈을 주입하는 것은 BeanPostProcessor 인터페이스에서 진행하며 실제 구현체는 AutowiredAnnotationBeanPostProcessor이다.
해당 구현체에서 실제 타깃에 빈을 주입하는 역할을 할 때 ReflectionUtils를 사용하게 된다. 즉, 리플렉션을 통해 수행되게 되어 지는 것이다. ( 필드 주입은 객체 생성 이후 Reflection으로 우회해서 강제로 값을 할당하게 된다. )
이것은 필드, 수정자 주입에 해당한다. 
생성자 주입의 경우 Reflection을 이용하지 않는다. (Bean 생성 시에 주입하기에 다른 방식과 달리 추가적인 비용이 없음을 의미한다., 다른 Bean 정보를 가져오는 Dependency Lookup까지만 사용하긴 한다고 한다.)



## Bean 
스프링 컨테이너에 의해 관리되는 자바 객체(POJO)를 뜻한다. 

### 스프링 컨테이너 
스프링 빈의 생명 주기를 관리하며, 생성된 스프링 빈들에게 추가적인 기능을 제공하는 역할을 한다. 
IoC와 DI의 원리가 적용되었다. 

### 빈 등록 방식 
#### Component Scan 
컴포넌트 스캔은 `@Component`를 명시하여 빈을 추가하는 방법이다.
`@Component`는 Class 혹인 Interface에만 붙일 수 있다. 
- `@Controller`
	- 스프링 MVC 컨트롤러로 인식 
- `@Repository`
	- 스프링 데이터 접근 계층으로 인식하며 해당 계층에서 발생하는 예외는 모두 DataAccessException으로 변환
- `@Service`
	- 특별한 처리는 하지 않지만 개발자들이 핵심 비즈니스 계층으로 인식하는 데 도움을 준다. 
- `@Configuration`
	- 스프링 설정 정보로 인식하고 빈이 싱글톤을 유지하도록 추가 처리를 한다. 

#### 자바 코드로 등록 (수동)
`@Configuration`, `@Bean` 어노테이션을 통해 등록한다. 
빈을 등록하기 위해 인스턴스를 생성하는 메서드 위에 `@Bean`을 명시한다. (메서드 명으로 빈의 이름이 컨테이너에 등록된다.)
`@Bean`의 경우 메서드나 어노테이션에만 붙일 수 있다. 
- 개발자가 직접 제어가 불가능한 라이브러리를 활용할 때 
- 어플리케이션 전범위적으로 사용되는 클래스를 등록할 때 
- 다형성을 활용하여 여러 구현체를 등록해줘야 할 때 


#### 수동 등록 시 주의점 
주의해야할 점이 `@Bean`은 반드시 `@Configuration` 어노테이션을 활용해야 한다. 
`@Configuration`은 `@Bean`에 추가 설정을 줘서 싱글톤으로 만들지 않는 이상 무조건 빈에 대해 싱글톤을 보장한다. 
가능한 이유는 `@Configuration`이 있는 객체가 빈으로 등록될 때 CGLIB 라이브러리를 사용하여 싱글톤을 보장하게 된다. CGLIB는 프록시 객체의 일종으로 빈을 등록할 때 해당 객체 대신 객체를 상속 받은 객체 즉, 프록시 객체를 컨테이너에 등록하게 된다. 
간단하게 `@Bean`이 등록된 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고 없다면 생성해서 빈으로 등록하여 반환하는 코드가 동적으로 만들어지게 된다. 

Bean Lite Mode는 CGLIB를 이용하여 바이트 코드 조작을 사용 하지 않는 방식을 말한다. 즉, 스프링 빈의 싱글톤을 보장하지 않는다. 
설정하기 위해선 `@Configuration`이 아닌 `@Component`를 사용하거나 `@Configuration` 어노테이션이 갖고 있는 proxyBeanMethods를 false로 설정하면 
호출때마다 새로운 객체를 생성하게 된다. `@Bean`으로만 등록할 때도 마찬가지이다.

### 빈 스코프 
기본적으로 싱클톤, 프로토타입 빈 스코프가 있으며 스프링 MVC에선 웹 스코프도 제공한다. 

#### Singleton 
- 스프링 컨테이너에서 한 번만 생성되며, 컨테이너가 사라질 때 제거된다. 
- 클래스단에 Scope("singleton")으로 지정할 수 있다.
- 생성된 하나의 인스턴스는 Spring Beans Cache에 저장되고, 해당 빈에 대한 요청과 참조가 있으며 캐시된 객체를 반환한다. 하나만 생성되기 때문에 동일 참조를 보장한다. 
- 기본적으로 모든 빈은 스코프가 명시적으로 지정되지 않으면 싱글톤이다. 
- 싱글톤으로 적합한 객체 
	- 상태가 없는 공유 객체 
	- 읽기 전용으로만 상태를 가진 객체 
	- 쓰기가 가능한 상태를 지니면서도 사용 빈도가 매우 높은 객체 
		- 동기화 전략이 필요하다. 

#### Prototype 
- DI가 발생할 때마다 새로운 객체가 생성되어 주입된다. 
- 클래스단에 Scope("prototype")으로 지정할 수 있다.
- 빈 소멸에 스프링 컨테이너가 관여하지 않고, GC에 의해 빈이 제거된다. 
- 프로토 타입으로 적합한 객체 
	- 사용할 때마다 상태가 달라져야 하는 객체 
	- 쓰기가 가능한 상태가 있는 객체 

프로토 타입 객체가 싱글톤 객체를 가지고 있는 것은 문제가 되지 않지만 싱글톤 객체가 프로토 타입 객체를 가지고 있을 경우 의도한 것과 다른 결과를 낼 수 있다. 싱글톤 빈으로 생성되는 시점에 프로토 타입 빈이 생성되어 들어오기 때문에 매번 같은 값을 가져오게 된다. 
이럴 경우 `javax.inject` 의 Provider를 사용하거나 `@Scope`에 proxyMode를 지정하여 해결할 수 있다.

#### 웹 스코프
- 웹 환경에서만 동작하는 스코프이며 프로토 타입과 다르게 특정 주기가 끝날 때까지 관리를 해준다. 따라서 `@PreDestory`와 같은 소멸 콜백이 호출된다는 특징이 있다. 
- 종류 
	- Request 
		- HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프 
		- 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다 
		- `@RequestScope`
	- Session 
		- HTTP Session과 동일한 생명주기를 가지는 스코프 
	- Application 
		- 서블릿 컨텍스트와 동일한 생명 주기를 가지는 스코프 
	- WebSocket 
		- 웹 소켓과 동일한 생명 주기를 가지는 스코프 


### 빈 생명주기 
#### Singleton Bean 
![](https://i.imgur.com/VkCSHyS.png)
1. 스프링 컨테이너 생성 
2. 스프링 빈 생성 
3. 의존 관계 주입 
4. 초기화 콜백 
5. 사용 
6. 소멸 전 콜백 
7. 스프링 종료 
`@PostConstruct`를 사용하면 초기화 콜백이 호출되고, `@PreDestory`를 호출하면 소멸 전 콜백이 호출된다. 

#### Prototype Bean
![](https://i.imgur.com/NSgLPQp.png)

- 스프링 컨테이너 생성 
- 스프링 빈 생성 
- 의존 관계 주입 
- 초기화 콜백 
- 사용 
- GC에 의해 수거 
프로토 타입 빈은 스프링 컨테이너가 빈의 생성까지만 관리하게 되고 이후는 제어권이 사라지게 된다. 
싱글톤과 달리 콜백도 초기화 콜백만 동작하게 된다.

#### 싱글톤 빈은 Thread-Safe 할까? 
스프링은 싱글톤 레지스트리를 통해 private 생성자, static 변수 등의 코드 없이 비즈니스 로직에 집중하고 테스트 코드에 용이한 싱글톤 객체를 제공해주는 것뿐, 동기화 문제는 개발자가 직접  처리해야 한다. 만약 싱글톤 빈이 상태를 갖게 되고, 아무런 동기화 처리를 해주지 않으면 문제가 발생하게 된다. 



## VO vs DTO
### VO 
> 값 표현용 

값 그 자체를 표현하는 객체이다.
불변의 특징을 가지고 있으며 속성값이 모두 같으면 같은 객체로 본다. 
(equals & hashCode를 재정의 해야 한다.)
로직을 가질 수 있다.

### DTO 
> 데이터 전달용 

레이어 간 데이터 전달 하기 위한 객체이다. 
오직 getter/setter 메서드만을 가질 뿐 다른 로직을 갖지 않는다. 
setter 메서드를 가지지 않음으로써 불변 객체로 만들 수 있다.

### DTO와 Entity를 분리하자 
Entity의 경우 데이터베이스와 매핑되어 있는 핵심 클래스이다. 
View의 경우 비즈니스 요구사항에서 자주 변경되는 부분이다. 
Entity를 요청이나 응답 값으로 전달하게 되면 View의 변경이 필요하다면 Entity의 변경도 불가피 할 것이다. Entity가 변경될 시 의존하고 있는 무수히 많은 클래스에도 변경이 필요해질 것 이다. 
그렇기 때문에 응답이나 응답값으로는 View의 영향이 다른 클래스에 영향을 끼치지 않고 자유롭게 변경이 가능한 DTO를 사용해야 한다. 
또한, 응답값으로 여러 테이블의 조인을 통한 조회의 경우 Entity 만으로는 응답값을 표현하기 어려울 때가 많기 때문에 이때도 DTO를 사용한다. 
-   관심사의 분리
-   Validation 로직 및 불필요한 코드 등과의 분리
-   API 스펙의 유지
-   API 스펙의 파악이 용이

## Dao vs Repository 
### Dao 
DAO 패턴은 Data Persistence의 추상화이며, Application code 보다는 데이터 저장소에 더 가까운 것으로 간주된다. 
데이터베이스 벤더들의 API와 로직 사이에 있는 어댑터와 같은 역할을 해줌으로써 구현체와 로직의 결합을 줄이게 된다. 
또한, 레이어가 깨지는 것을 방지하기 위해 DTO를 사용하게 된다. 
인프라 스트럭쳐 레이어에 속한다. 

### Repository
DDD에서 처음 등장한 개념으로 객체 Collection의 추상화이다.
즉, 객체의 상태를 관리하는 저장소로써 Entity(도메인 객체) 그 자체를 저장하고 불러오는 역할을 하게 된다. 
Repository는 객체의 상태를 관리하는 저장소일 뿐, 구현이 파일시스템이든 메모리이든 상관하지 않는다. 그렇기 때문에 일반적으로 Repository의 인터페이스를 도메인 로직에 넣어주며 도메인 레이어에 속하게 된다. (객체의 Collection을 다루듯이 캡슐화, 즉 인터페이스를 제공) 구현의 경우 영속성 레이어에 속한다. 

### 결론 
- 상대적으로 DAO는 하위 모듈, Repository는 상위 모듈이다. 
- DAO는 데이터 매핑, 접근 계층으로 쿼리를 숨기지만 Repository는 도메인과 DAL 사이의 계층으로 데이터를 대조하고 도메인 객체로 매핑하는 로직을 숨긴다. 
- DAO는 Repository를 사용하여 구현할 수 없지만 Repository는 DAO를 사용해 구현할 수 있다. 
- 모두 Data Access한다는 점에서 Repository와 DAO는 공통점이 있지만 Repository는 객체 중심, DAO는 데이터 저장소 즉, DB 테이블 중심이다.
