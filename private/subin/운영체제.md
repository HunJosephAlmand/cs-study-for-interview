---

mindmap-plugin: basic

---

# 운영체제

## 프로세스 vs 스레드
- 정리 ^79bff367-5be1-fed9
   - 자원은 Process 단위로 받고, 작업/스케줄링은 Thread 단위로 진행
   - 여기서 핵심은 컨텍스트 스위칭 비용을 줄이기 위해서인듯?!!!!
      - 코드, 힙, 데이터 영역을 공유해서.
      - 스레드도 컨텍스트 스위칭을 하지만, 프로세스 컨텍스트 스위칭보다 매우 짧게 가져갈 수 있다
   - 동시성 문제가 발생할 수 잇음
- 프로세스( ^28b24817-6571-963d
   - 개념
      - 프로세서에 의해 동작하고 있는 프로그램
         - 프로세스가 동작한다는 것은 프로세스의 특정 스레드가 실행중
         - 그 특정 스레드는 프로세스가 가진 데이터를 참조함
   - 제어블록
      - 프로세스 식별자
      - 프로세스 상태
      - 프로그램카운터
      - CPU 스케줄링 정보
      - 기타 등등..
   - Context Switching
      - 한 프로세스에 할당 된 시간이 끝나거나 인터럽트에 의해 발생한다
   - 프로그램 vs 프로세스
      - 프로그램
         - 저장장치에 저장되어 있는 정적인 상태
         - 레시피
      - 프로세스
         - 실행을 위에 메모리에 올라온 동적인 상태
         - 요리
   - 구조
      - 스택
         - 호출된 함수, 지역변수 등 임시 데이터
      - 힙
         - 동적으로 생긴 데이터
      - 데이터
         - 전역변수 (static, global 등)
      - 코드
         - 프로그램 코드
- 스레드 ^24652666-c496-2283
   - 개념
      - 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위이다
      - 프로세스 내에서 실행되는 작업 흐름의 단위
   - 멀티스레드 구조
   - 멀티스레드 장단점
      - 단점
         - 동시성문제
   - 멀티프로세스 vs 멀티스레드
      - 멀티스레드
         - 프로세스 내 작업을 여러개의 스레드로 분할하여 작업의 부담을 줄이는 `프로세스 운영 기법`
      - 멀티프로세스
         - CPU를 여러개 사용하여 여러 개의 스레드를 동시에 처리하는 작업환경
   - 스프링에서의 Thread Pool
      - Tomcat은 위에서의 다중 요청을 처리하기 위해서 Thread Pool 전략을 사용한다
      - 작업 시 Thread Pool에서 가져가 사용하고, Thread 자원을 해제하는 것이 아닌 Thread Pool에 다시 반납한다
      - server.tomcat.threads.min-spare: 10
         - 아무 작업이 없어도 활성화 되어 있는 Thread 개수
      - server.tomcat.accept-count: 100
         - 요청 대기하는 큐의 크기
- 차이 ^bf856a1b-0454-a171
   - 멀티 프로세스를 하게 된다면,
      - 컨텍스트스위칭 시에 스택, 힙, 데이터, 코드를 모두 재로딩을 해야하고
      - 같은 작업을 하기 위해 만든 프로세스인데 각 영역을 따로 가지기 때문에,
         다른 프로세스의 정보를 사용하기 위해 통신(IPC)이 필요하게 된다
      - 코드 힙 데이터 영역을 공유하고, 이제 스레드에서는 각 Stack만을 포함한다
   - 리눅스 커널에서는 프로세스와 스레드를 동일하게 본다
      - 스레드는 사용자 스레드와 커널 스레드로 나뉜다

## 커널 ^077acd16-71b7-a4e8
- 구성
   - 단일형구조커널
      - 초창기의 운영체제
      - 모듈들이 구분없이 하나로 구성되어있음
      - 대표적인 운영체제
         - MS-DOS
         - VMS
         - 초기의 유닉스 운영체제
      - 장단점
         - 장점
            - 모듈이 거의 분리되지 않아 모듈간 통신비용이 줄어들어 효율적인 운영이 가능하다
            - main에 모든 기능을 넣은것과 유사
         - 단점
            - 디버깅이 힘들다
            - 이식성이 낮다 - 다양한 환경에 적용하기 어렵다
            - 기능간 상호의존성이 높기 때문에 기능상의 작은 결함이 시스템 전체로 확산될 수 있다
   - 계층형구조커널
      - 비슷한 기능을 가진 모듈을 묶어서 하나의 계층을 만들고, 계층간 통신을 통해 운영체제를 구현하는 방식
      - 윈도우를 비롯해 오늘날의 운영체제는 대부분 이 구조로 이루어져 있다
   - 마이크로구조커널
      - 가장 기본적인 기능만 제공한다. 커널의 구조를 살펴보면 운영체제의 많은 부분이 사용자 영역에 구현되어 있따
      - 커널은 메모리 관리와 프로세스간 동기화 서비스를 제공하고
      - 메모리 관리자와  동기화 모듈은 프로세스간 통신모듈로 연결되어 있다
      - 대표적인 운영체제
         - 마하
            - (애플의 OS X와 IOS 커널)
- 커널이 하는 일
   - 프로세스관리
      - CPU 배분하고, 작업에 필요한 제반환경제공
   - 메모리 관리
      - 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공
   - 파일시스템 관리
      - 데이터를 저장하고 접근할 수 있는 인터페이스 제공
   - 입출력 관리
      - 필요한 입력과 출력 서비스를 제공
   - 프로세스간 통신 관리
      - 공동 작업을 위한 각 프로세스 간 통신 환경 지원

## 운영체제
- 역할
   - 자원관리
      - 효율성
         - 같은 작업량을 처리하는데 보다 적은 자원을 사용해야 한다
         - 운영체제가 사용하는 코드를 최적화
            운영체제 크기 최소화
   - 자원보호
      - 안정성
         - 하드웨어적인 보안 문제
         - 문제발생시 이전으로 복구하는 결함 포용 기능
   - 하드웨어 인터페이스 제공
      - 확장성
         - 다양한 시스템 자원을 추가하거나 제거하기 편리해야 한다
            - 플러그&플레이
   - 사용자 인터페이스 제공
      - 편리성
         - 편리하게 작업할 수 있는 환경을 제공하는 것
- 운영체제란
   - 컴퓨터 시스템의 자원을 안정적이고, 효율적으로 관리하며,
      사용자에게 편리한 인터페이스를 제공해주는 소프트웨어입니다
- 구조
   - 커널
      - 시스템호출
         - 내부적으로 인터럽트가 일어나서
            - 시스템호출
               - 사용자모드 -> 커널모드
                  - 접근권한
         - 소프트웨어 인터럽트, 하드웨어 인터럽트
            - 하드웨어 인터럽트
               - 타이머 인터럽트
               - 디바이스 ㅇ??
               - 외부 인터럽트
            - 소프트웨어 인터럽트
               - 트랩
               - 내부인터럽트
      - 커널
      - 드라이버
   - 인터페이스

## 스케줄링
- 종류
   - 단기
      - 어떤 프로세스에게 cpu를 할당해 줄 것인가 ?
      - 시분할 시스템에서 타이머 인터럽트가 발생하면 단기 스케줄러가 호출
      - 미리 정한 스케줄링 알고리즘에 따라 cpu를 할당 할 프로세스를 선택
   - 중기
      - 메모리에 적재된 프로세스 수 관리
      - 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러
      - 중기 스케줄러의 등장으로 프로세스의 상태에는 중지(suspenden, stopped) 상태가 추가
      - 스왑 아웃(swap out)
         - 메모리에 올라와 있는 프로세스 중 일부로 부터 메모리를 통째로 빼앗아
            그 내용을 디스크의 스왑 영역에 저장해 두는 행위
      - 중지상태
         - 중지 준비 상태
            - 준비 상태의 프로세스가 중기 스케줄러에 의해 디스크로 swap out
         - 봉쇄 중지 상태
            - 봉쇄 상태의 프로세스가 중기 스케줄러에 의해 디스크로 swap out
   - 장기
      - 어떤 프로세스를 준비큐에 넣을 것인가
      - 현대의 시분할 시스템에서 사용되는 운영 체제에는 일반적으로 장기 스케줄러를 두지 않는 경우가 대부분
      - 과거에는 적은 양의 메로리를 많은 프로세스들에게 할당하면 프로세스당 메모리 보유량이 적어져 장기 스케줄러가 이를 조절하는 역할
   - 출처
      - https://kosaf04pyh.tistory.com/191
- CPU 스케줄링
   - 비선점 스케줄링
      - 프로세스가 입출력 요구 등으로 CPU를 자진 반납할 때까지 CPU에 의한 실행을 보장해주는 스케줄링
      - 예시
         - FCFS(First Come First Served)
         - SJF(Shortest Job First, 최단 작업 우선)
         - 우선순위(Priority) 스케줄링
   - 선점 스케줄링
      - 현 프로세스로부터 강제로 CPU를 회수하는 것
         - 시분할 시스템에서 타임슬라이스가 소진
         - 인터럽트 혹은 시스템 호출 종료 시
            현 프로세스보다 높은 우선순위의 프로세스가 나타나는 경우
      - 예시
         - 라운드로빈, 다단계 큐, 다단계 피드백 큐 스케줄링
- 알고리즘
   - FCFS
      - 프로세스의 도착순으로 CPU를 배정
   - SJF
      - Shortest Job First Scheduling
      - 최단 작업 우선 스케줄링
   - SRT
      - Shortest Remaining Time Scheduling
      - 최단 `잔여` 시간을 우선으로 하는 스케줄링
   - Priority Scheduling
      - 우선순위가 제일 높은 프로세스에게 CPU를 할당하되, 우선순위가 같은 경우에는 FCFS 방식을 적용
      - 우선순위가 낮은 작업은 준비상태에서 보장 없이 머물게 된다 (기아상태)
         - 에이징(Aging)으로 해결
         - 시스템에 머무는 시간이 증가할수록 우선순위를 높여줌
   - Round Robin
      - 각 프로세스에게 작은 단위의 시간량(타임 퀀텀)만큼씩 CPU를 할당하는 방식
      - 선점형 스케줄링 중 하나로 시분할 시스템을 위해 설계
   - Multilevel Queue(MLQ)
      - 작업(or 우선순위)별 별도의 ready queue를 가진다
      - FIFO + RR 스케줄링
   - Multilevel Feedback Queue(MFQ)
      - MLQ에서 생길 수 있는 Starvation을 보완한 스케줄링 기법
   - MLQ vs MFQ
      - MLQ
         - 큐와 큐 사이에 프로세스들이 이동을 할 수 없음
         - 하위단계큐에 있을 수록 기아현상 발생
      - MFQ
         - 큐 사이에 프로세스들이 이동을 할 수 있음
         - 에이징 기법을 통해 기아 현상을 예방할 수 있음