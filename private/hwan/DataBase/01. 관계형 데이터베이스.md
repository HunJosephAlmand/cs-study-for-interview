## 데이터베이스란? 
데이터베이스는 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음이다.
- DBMS (DataBase Management System) : 데이터베이스를 제어, 관리하는 통합 시스템
- 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 CRUD 등을 수행할 수 있다. 
- 실시간 접근과 동시 공유가 가능하다.


## 관계형 데이터베이스란? 
현재 가장 많이 사용되는 데이터베이스로 행과 열을 가지는 테이블 형식으로 데이터를 저장하며 현실의 데이터를 관계라는 개념을 사용해서 표현한다.
SQL이라는 언어를 통해 조작한다. 

### 구성요소
- **엔티티** 
	- 사람, 장소, 물건 등 여러 개의 속성을 지닌 명사를 의미한다. 
	- 예를 들어 회원이라는 엔티티가 있다면 회원은 이름, 아이디, 주소 등의 속성을 가지게 된다. 
	- 많은 속성이 있지만 서비스의 요구사항에 맞게 속성이 정해지게 된다.
- **테이블** 
	- 행과 열로 이루어진 데이터의 집합을 테이블이라고 한다. 
	- 일반적인 데이터베이스에는 행과 열만 있으면 테이블이라고 하지만, 관계형 데이터베이스에서는 특별한 제약을 추가해서 릴레이션이라고 한다. 
- **릴레이션 (Relation)**
	- 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
	- 릴레이션이 되기 위해 아래 조건을 만족해야 한다. 
		- 모든 값은 유일한 값을 가진다. 
		- 하나의 릴레이션에 중복되는 행이 존재하면 안된다.
	- 하지만 통상적으로 릴레이션과 테이블이란 용어를 구분하지 않고 사용하기도 한다.
-  **행 (Row)**
	- 테이블을 구성하는 데이터들 중 가로로 묶은 데이터셋을 뜻한다. 
	- 관계형 데이터베이스에서는 레코드 또는 튜플이라고도 한다. 
- **열 (Colum)**
	- 테이블을 구성하는 데이터들 중 세로로 묶은 데이터셋을 뜻한다. 
	- 일반적으로 열을 테이블의 속성을 의미하며 구성하는 값들은 같은 도메인으로 되어있다. 
	- 관계형 데이터베이스에서는 속성(attribute)이라도 한다.
		- 릴레이션에서 관리하는 구체적이며 고유한 이름(필드)을 갖는 정보
- **도메인** 
	- 속성이 가질 수 있는 값의 집합이다. 
	- 성별이라는 속성일 시 {남,여} 집합이 도메인이 된다.
- 스키마 
	- 데이터베이스의 구조를 전반적으로 기술한 것 
	- 구체적으로 데이터베이스를 구성하는 데이터의 레코드 크기, 키의 정의, 레코드 간의 관계 등을 정의한 것이다.

### 데이터베이스를 사용하는 이유 
데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다. 데이터를 각각의 파일 단위로 저장하며 이런 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 한다. 
이때 문제점은 데이터의 종속성과 중복성, 무결성이다. 파일 시스템을 사용하면서 발생하는 문제점을 해결하기 위해 데이터베이스를 사용한다. 

1. 데이터의 독립성 
	- 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다. 
	- 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
2. 데이터의 무결성 
	- 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
3. 데이터의 보안성 
	- 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.
4. 데이터의 일관성 
	- 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 
	- 또한, 작업 중 일부 데이터만 벼녕되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.
5. 데이터 중복 최소화
	- 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

### 무결성 제약조건 
> 무결성 : 데이터의 정확성, 일관성, 유효성을 유지하는 것 

데이터베이스의 정확성, 일관성을 보장 즉, 무결성을 보장하기 위해 저장, 삭제, 수정 등을 제약하기 위한 조건이다. 주요 목적은 데이터베이스에 저장된 데이터의 무결성을 보장하고 데이터베이스의 상태를 일관되게 유지하는 것이다.
무결성이 유지되어야 데이터베이스에 저장된 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생기게 된다.

- 개체 무결성 : 기본키로 선택된 필드는 NULL값이나 중복된 값을 가질 수 없다. 
- 참조 무결성 : 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다.
	- 즉, 각 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다.
- 도메인 무결성 : 속성들의 값은 정의된 도메인에 속한 값이어야 한다. 
- 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가진다. 
- NULL 무결성 : 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약조건
- 키 무결성 : 각 릴레이션은 최소한 한 개 이상의 키가 존재해야 한다.

### 장, 단점
#### 장점 
- 데이터의 분류, 정렬, 탐색 속도가 빠르다. 
- 정규화 및 관계를 통해 데이터의 무결성, 신뢰성을 보장한다.

#### 단점
- 관계가 복잡하고, 스키마 수정이 어렵다.
- 조인으로 인해 복잡한 쿼리가 발생하거나 성능 저하가 발생할 수 있다.
- 데이터 베이스의 부하를 분석하기 어렵다.


### DML, DDL, DCL 
- DDL 
	- 데이터 정의어 
	- 데이터베이스의 스키마를 정의한다. 
	- CREATE, ALTER, DROP
- DML 
	- 데이터 조작어 
	- 데이터베이스의 데이터를 삽입, 검색, 수정, 삭제 한다. 
	- INSERT, SELECT, UPDATE, DELETE
- DCL 
	- 데이터 제어어
	- 데이터베이스에 접근하고 데이터를 사용할 수 있는 권하을 제어한다. 
	- GRANT, REVOKE

### Key 
![](https://i.imgur.com/hGlRT7y.png)

#### 슈퍼키 (Super Key)
- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 속성 또는 속성의 집합
	- 유일성 : 하나의 키 값으로 특정 레코드만을 유일하게 찾아낼 수 있다.
- 유일성은 만족하지만 최소성은 만족하지 않는다.
- (학번), (학번, 이름), (학번, 이름, 학과), (주민등록번호), (주민등록번호, 학과 ,성별) 

#### 후보키 (Candidate key)
- 슈퍼키 중에서 더 이상 쪼개질 수 없는 키를 후보키라고 한다. 
- 즉, 각 레코드를 유일하게 식별할 수 있는 최소한의 속성들의 집합이다.
	- 슈퍼키들 중 유일성과 최소성을 모두 만족하는 속성 또는 속성들의 집합
	- 최소성 : 모든 레코드를 유일하게 식별하는 데 꼭 필요한 속성만으로 구성된 것
- 기본키가 될 수 있는 후보들이다.
- (학번), (주민등록번호)

### 기본키 (Primary key)
- 후보키들 중 기본적으로 즉, 가장 메인으로 사용할 키로써 각 레코드를 구분하는 유일한 열을 뜻한다. 
- NULL 값을 가질 수 없고, 중복된 값을 가질 수 없으며 테이블 당 한개만 지정해야 한다. 
	- 기본키로 지정할 시 클러스터형 인덱스가 생성되게 되고 해당 컬럼 기준으로 정렬되게 된다. 하지만 기본키가 두 개 이상으로 지정될 경우 어떤 것을 기준으로 정렬해야할 지 모르게되니 저장하는 것 자체에서 부터 문제가 발생할 수 있다.
- 기본키의 값이 변경되는 경우 매번 기본키로  적합한지 검사해야하므로, **기본키는 절대 바뀌지 않아야 한다.**
	- 기본키를 수정할 경우 여러 테이블의 FK와 인덱스에 영향을 주며 너무나 큰 비용이다.
	- [현실 세계의 속성에 의존하지 않기](https://jojoldu.tistory.com/672?category=1011740)
- 자연키 또는 인조키 중에 골라 설정한다.
	- 자연키 : 속성들중 중복된 값들을 제외하며 중복되지 않는 것을 자연스렙 뽑다가 나오는 키이며 언제가는 변할 수 있는 속성이다.
	- 인조키 : 인위적으로 생성한 키를 뜻하며 MySQL의 auto increment로 설정한다. 자연키와는 대조적으로 변하지 않으므로 보통 기본키로 인조키를 사용하게 된다.

#### 외래키 (Foreign key)
- 다른 테이블의 기본키를 참조하는 컬럼으로 개체와의 관계를 식별하는 데 사용한다.
- 중복되어도 괜찮다. 

#### 대체키 (alternate key)
- 기본키를 제외한 나머지 후보키들을 말한다. 


#### 복합키 (composite key)
- 테이블에서 각 레코드를 식별할 수 있는 두 개 이상의 컬럼으로 구성된 후보키



### 관계 종류 
> 관계형 데이터베이스에서 하나의 엔티티(테이블)가 관계를 맺은 엔티티의 여러 객체를 가질 수 있는 구조 
> 두 테이블간의 관계를 mapping cardinality로 표현

#### 1:1 관계 
어느 엔티티 쪽에서 상대 엔티티와 반드시 단 하나의 관계를 가지는 것
테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만들어 주지만 무조건은 아니다.
- 유저 - 유저 이메일, 국가 - 수도, 예약 - 리뷰 

#### 1 : N 관계 
보통 기본 키 - 외래 키를 사용해 관계를 맺으며 하나의 엔티티(테이블)가 관계를 맺은 엔티티의 여러 객체를 가질 수 있는 구조를 말한다.
만약 고객과 주문 관계일 때 고객의 정보가 변경된다 해도, 주문 내역 테이블은 수정할 필요가 없어 효율적인 데이터베이스 운영이 가능하다.
- 고객(1) - 주문 내역(N), 게시물(1) - 게시물 이미지(N), 팀(1) - 선수(N)

#### N : M 관계 
양쪽 엔티티 모두가 서로에게 1:N 관계를 갖는 구조 
N:M 구조에서는 테이블 두 개를 직접적으로 연결해서 구축하지 않고 보통 새로운 테이블(Mapping table)을 통해서 관계를 맺는다. 즉, 1:N, 1:M이라는 관계를 갖는 테이블 두 개로 나눠서 설정한다. 
( 새로운 테이블을 사용하지 않으면 RDB에서 자체적으로 설정하게 되는 데 이럴 경우 개발자가 직접 관리할 수 없다는 것이 단점이다. )
- 학생(N) - 수업(M) -> 학생(1) - 수강신청(N, M) - 수업(1)
- 게시물(N) - 태그 (M) -> 게시물(1) - 게시물태그(N,M) - 태그(1)


## Join
두 개 이상의 테이블을 서로 연결하여 하나의 결과를 만드는 것이다.  테이블을 연결하기 위해서는 적어도 하나의 컬럼을 서로 공유해야 한다. 
관계형 데이터베이스에서 정규화를 수행하면 의미있는 테이블로 데이터들이 나뉜다. 따라서, 서로 관계가 있는 테이블을 효과적으로 검색하기 위해 사용된다.
MySQL에서는 JOIN이라는 쿼리로 처리한다. 
```
SELECT 필드명
FROM 테이블명
[INNER/LEFT/RIGHT/CROSS] JOIN 테이블명 ON 기준설정(키값매핑)
WHERE 조건
```
- 조인종류를 명시하지 않으면 기본값으로 inner join이 수행된다.
- from에 명시된 테이블이 base가 된다.


### 종류 
![](https://i.imgur.com/HQke1DX.png)


#### INNER JOIN (내부 조인)
- 두 테이블에 모두 있는 내용 즉, 두 행이 모두 일치하는(공통된) 행이 있는 부분만 표기한다. (교집합)
- 조인 구문에 기반한 두 개의 테이블의 컬럼 값을 결합하여 새로운 결과 테이블을 생성한다. 
- 컬럼 값이 동일한 경우만 가져온다. 
- 주로 1:N관계에서 사용하며 기본키-외래키를 통해 조인한다. (상호조인의 경우 기본키-외래키 관계가 아니여도 된다.)

#### OUTER JOIN
- 조인 대상 테이블에서 특정 테이블의 모든 데이터가 필요한 경우 사용한다. 
- **LEFT OUTER JOIN** 
	- 좌측 테이블의 모든 데이터가 필요한 경우 사용한다. 
	- 우측 테이블에 조인 컬럼 데이터가 없는 경우 NULL로 처리된다.
- **RIGHT OUTER JOIN** 
	- 우측 테이블의 모든 데이터가 필요한 경우 사용된다. 
	- 좌측 테이블에 조인 컬럼 데이터가 없는 경우 NULL로 처리된다. 
- **FULL OUTER JOIN** 
	- 양쪽의 모든 데이터가 필요한 경우 사용한다. 
	- 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기한다. 
	- MySQL에서는 지원하지 않기 때문에 필요한 경우 left, right 조인 한 결과를 union으로 묶어버린다.
		- union은 중복된 레코드를 제거하고 union all은 중복된 레코드를 제거하지 않는다.

#### CROSS JOIN
- 조인이 되는 두 테이블의 가르티시안 곱을 한다. 즉, 모든 경우의 수를 전부 표현한다. 
- 테이블 크기가 각 M,N일 경우 M * N 크기의 새로운 테이블이 생성된다.
- QueryDsl나 Spring Data JPA에서 별도의 join절을 선언하지 않고 where문에서 바로 연관관계를 사용할 경우 발생한다.
	- 명시적 join으로 변경

#### SELF JOIN 
한 테이블에서 자기 자신을 조인한다.
자기 자신을 두번 출력하게 된다.



### 원리 
조인의 원리를 기반으로 조인 작업이 이루어진다. 조인의 원리에는 중첩 루프 조인, 정렬 병합 조인, 해시 조인이 있다. 

#### 중첩 루프 조인 
중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법이며 랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에서는 사용하지 않는다. 
예를 들어 `테이블 A,B를 조인한다.`라고 가정했을 시 A 테이블에서 행을 한 번에 하나씩 읽고 그 다음 B테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결과값을 반환하는 것이다. 
```
for each row in A matching reference key {
	for each row in B matching reference key {
		if row satisfies join conditions, send to client
	}
}
```
참고로 중첩 루프 조인에서 발전하여 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인하는 블록 중첩 루프 조인이라는 방식도 있다. 

#### 정렬 병합 조인 
각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인이다. 
조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 `<,>` 등 범위 비교 연산자가 있을 때 사용한다. 

#### 해시 조인 
해시 테이블을 기반으로 조인한다. 
두 개의 테이블을 조인한다고 가정했을 시 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적이다. (메모리에 올릴 수 없을 정도로 크다면 디스크를 사용하는 비용이 발생한다.) 또한, 동등(=) 조인에서만 사용할 수 있다.
MySQL의 경우 MySQL8.0.18부터 사용할 수 있으며 빌드 단계, 프로브 단계로 나뉘어 진행된다. 

- 빌드 단계 
	- 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계 
	- 테이블 A,B가 있을 경우 바이트가 더 작은 테이블을 기반으로 해시 테이블을 빌드한다. 
	- 조인에 사용되는 필드가 해시 테이블의 키로 사용된다. (A_id)
- 프로브 단계
	- 프로브 단계동안 레코드 읽기를 시작하며, 각 레코드에서 A_id에 일차하는 레코드를 찾아 결과값으로 반환한다. 

각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋다.
