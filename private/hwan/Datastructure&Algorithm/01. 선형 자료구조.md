## 선형 자료구조 
> 요소가 일렬로 나열되어 있는 자료구조

### Array (배열)
연관된 data를 메모리상에 연속적이며 순차적으로 미리 할당된 크기만큼 저장하는 자료구조
- 고정된 저장 공간 
- 순차적인 데이터 저장 

#### 장점 
- 조회(lookup)와 마지막 인덱스에 추가(append)가 빠르다. (O(1))
	- 조회를 자주 해야하는 작업일 때 사용한다. 

### 단점 
- 고정된 저장 공간 특성상 선언시에 배열의 크기를 미리 정해야 한다. 
	- 이는 메모리 낭비나 추가적인 overhead가 발생할 수 있다. 
	- 선언된 배열의 크기만큼 데이터가 없다면 메모리 낭비가 일어나고 배열의 크기를 넘어서는 데이터의 저장이 필요하면 더 큰 크기의 배열에 옮겨줘야하는 overhead가 발생한다.

### 시간 복잡도 
- 조회(lookup) : `O(1)` - random access
	- index를 접근하는 방법이 산술적인 연산([배열의 첫 data의 주소값] + offset)으로 이루어져 있기 때문에
- 마지막 인덱스 추가 (append) : `O(1)
- 마지막 인덱스 삭제 : `O(1)
- 삽입(insert) : `O(n)
- 삭제(delete) : `O(n)
- 탐색(search) : `O(n)
삽입, 삭제가 O(n)인 이유는 배열이 메모리상에 연속적으로 존재해야 함으로 삽입 시 그 위치부터 맨 끝까지 요소를 전부 한 칸씩 밀어야 하기 때문에 O(n)이 된다. (삭제의 경우 한 칸씩 땡기기)
> Random Access (랜덤 접근)
> 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능


### Dynamic Array 
Array는 고정된 저장 공간이기 때문에 선언시에 설정한 size보다 많은 갯수의 데이터가 추가되면 저장할 수 없는 한계점이 있다.
이러한 문제를 해결하기 위해 동적 배열이 나타나게 되었다. 
Dynamic Array는 저장공간이 가득 차게 되면 **resize**를 하며 **유동적으로 size를 조절**하여 데이터를 저장하는 자료구조이다.

#### resize 
데이터를 추가하다가 기존에 할당된 메모리를 초과하게 되면, size를 늘린 배열을 선언하고 그곳으로 모든 데이터를 옮김으로써 늘어난 크기의 size를 가진 배열이 된다. 
이로써 새로운 데이터를 저장할 수 있게 되고 size를 미리 고민할 필요가 없게 된다. 
대표적으로 기존 배열 size의 2배 size를 할당하는 doubling이 있다. 
- doubling 
	- 데이터를 추가(append - `O(1)`)하다가 메모리를 초과하게 되면 기존 배열의 size보다 2배 큰 배열을 선언하고 데이터를 일일이 옮기는(`O(n)`)방법 
	- Java의 ArrayList의 경우 1.5배로 사이즈를 늘린다. 
	![](https://i.imgur.com/IbNaFfJ.png)


### 분할상환 시간복잡도 (Amortized time complexity)
Dynamic array에서 데이터를 추가할 때마다 O(1)의 시간이 걸리지만 미리 선언된 size를 넘어서는 순간 resize가 일어나 O(n) 시간이 걸리게 된다. 
그렇다면 append의 경우 시간복잡도가 O(1)일까 O(n)일까? 
사실 append의 과정은 데이터를 마지막 인덱스에 추가하는(O(1))작업이 대다수이고, size를 넘어설 때 size를 늘리고 데이터를 일일이 옮기는 과정인 resize(O(n))은 아주 가끔 발생하게 된다. 
그렇기 때문에 append의 전체적인 시간복잡도는 O(1)이며, 이를 더 정확히 말하면 amortized O(1)이라고 한다. 
즉, 가끔씩 발생하는 resize(O(n))의 시간을 자주 발생하는 O(1)의 작업들이 분담해서 나눠가짐으로써 전체적으로 봤을 때는 O(1)의 시간이 걸리게 된다.


### Java에서는? 
Java에서는 List의 ArrayList와 Vector가 이에 해당한다. (순서가 있는 데이터의 집합으로, 데이터의 중복을 허용)
- ArrayList는 비동기 방식이고, Vector는 동기 방식이다. 
	- Vector는 `synchronized`를 통해 동기화 처리를 진행한다. 
- Vector는 대부분의 메소드에 동기화처리가 되어있지만, 스레드 안전하지는 않다. 
	- 만약 Vector안에 한 개의 데이터가 저장되어 있을 때, 한 스레드에서는 remove를 호출하고 다른 스레드에서는 get을 호출할 경우 잘못하면 Exception이 발생하게 된다. 
- 그렇기 때문에 Vector는 스레드 안전하지도 않고 동기화 처리로 인해 성능도 떨어지기 때문에 사용하지 않는 것이 좋다.
- 멀티스레드 환경에서 ArrayList는 `Collections.synchronizedList()` 를 사용한다.


### List 
> 순서가 있는 데이터의 집합으로, 데이터의 중복을 허용하는 자료구조 
> Java에서는 List인터페이스가 있으며 ArrayList, LinkedList, Vector 구현체가 있다.

### LinkedList 
Node라는 구조체로 이루어지며, Node에는 데이터 값과 다음 Node의 주소를 저장하게 된다. 
LinkedList는 물리적인 메모리상에서는 비연속적으로 저장이 되지만 Linked list를 구성하는 각각의 Node가 다음 Node의 주소를 가리킴으로써 논리적인 연속성을 가진 자료구조이다.

#### 논리적 연속성 
각 Node들은 다음 주소정보를 가지고 있기 때문에 논리적으로 연속성을 유지하면서 연결되어 있다. 
배열의 경우 연속성을 유지하기 위해 물리적 메모리 상에서 순차적으로 저장하는 방법을 사용함에 반해 Linked List는 메모리에서 연속성을 유지하지 않아도 되기 때문에 데이터가 추가 되는 시점에 메모리를 할당하게 되고 메모리를 좀 더 효율적으로 사용할 수 있는 장점을 가진다. 
하지만 데이터 이외에 다음 주소 정보를 추가적으로 저장해야하기 때문에 데이터 하나 당 차지하는 메모리의 크기는 커지게 된다. 

#### 시간 복잡도 
배열은 중간에 데이터를 삽입, 삭제하게 되면 해당 인덱스 뒤에 있는 모든 원소들을 shift 해야 해서 O(n)의 시간복잡도를 가졌다.
하지만 Linked List는 물리적으로 옮길 필요가 없이 다음 주소정보만 변경해주면 되기 때문에 O(1)의 시간복잡도로 삽입,삭제가 가능하다. 
- 조회 : `O(n)
	- 물리적 메모리상에서 비연속적으로 저장되기 때문에 순차적으로 접근해야 한다. 
- 탐색 : `O(n)
- 삽입 : `O(1)
- 삭제 : `O(1)
사실 삽입, 삭제하려는 index까지 도달하는 데 O(n)이 걸리기 때문에 실질적으로는 삽입, 삭제시 시간복잡도는 O(n)의 시간이 걸린다.

#### 종류 
- 싱글 연결 리스트 : next 포인터만 가진다.
- 이중 연결 리스트 : next, prev 포인터를 가진다. 
- 원형 이중 연결 리스트 : 이중 연결 리스트와 같지만 마지막 노드의 next 포인터가 헤드 노드를 가르킨다.


### Array와 LinkedList 
Array와 LinkedList는 메모리 구조의 차이로 인해 각 연산의 시간복잡도가 다르다. 
데이터 조회는 Array의 경우 O(1), LinkedListed의 경우 O(n)의 시간복잡도를 갖는다. 
데이터 삽입,삭제는 Array의 경우 O(n), LinkedListed의 경우 O(1)의 시간복잡도를 갖는다. 
즉, 얼마만큼의 데이터를 저장할지 미리 알고있고, 조회를 많이 한다면 Array를 사용하는 것이 좋다. 
반면에 몇개의 데이터를 저장할 지 불확실하고 삽입, 삭제가 잦다면 LinkedList를 사용하는 것이 좋다. 

#### 메모리 
Array의 장점은 데이터 접근과 append가 빠르다는 것이다. 하지만 메모리 낭비라는 단점이 있다. 배열은 선언시 고정된 저장 공간을 설정하여 메모리를 할당하는 데 이때 데이터가 저장되어 있지 않더라도 메모리를 차지 하고 있기 때문에 메모리 낭비가 발생한다. 
반면 LinkedList는 runtime 중에서도 size를 늘리고 줄일 수 있다. 그렇기 때문에 size를 고민할 필요가 없고, 필요한 만큼 메모리 할당을 하여 메모리 낭비도 없다. 

#### 정리 
**LinkedList보다 Array가 좋은 상황** 
- 조회 작업을 자주 해야할 때 
- 할당할 데이터의 개수를 알고 있을 때 
- 데이터를 반복문을 통해서 빠르게 순회할 때 
- 메모리를 적게 쓰는게 중요한 상황일 때(할당할 데이터의 개수를 알고 있다는 가정하에)

**Array보다 LinkedList가 좋은 상황**
- 삽입,삭제를 자주 해야 될 때 
- 할당할 데이터의 개수를 예측할 수 없을 때
- 조회 작업을 별로 하지 않을 때

### Stack 
시간 순서상 가장 최근에 추가한 데이터가 가장 먼저 나오는 후입선출(LIFO)형식으로 데이터를 저장하는 자료구조
다음과 같은 두 가지 연산을 지원한다. 
- push : 맨 뒤에 데이터를 추가한다. O(1)
- pop : 맨 뒤에 데이터를 삭제한다. O(1)
push, pop 모두 stack의 top에 원소를 추가하거나 삭제하는 형식으로 구현된다. 
stack은 call stack, 웹 브라우저 방문기록(뒤로 가기), 깊이우선탐색 등에 활용된다. 

#### Java에서는 ? 
List 인터페이스의 Vector 구현체를 상속하고 있다. 
그렇기 때문에 오라클에서는 Stack클래스를 사용하기 보단 Deque를 사용할 것을 권고하고 있다.


### Queue 
시간 순서상 먼저 집어 넣은 데이터가 먼저 나오는 선입선출(FIFO)형식으로 데이터를 저장하는 자료구조 
다음과 같은 두 가지 연산을 지원한다. 
- enqueue : 맨 뒤의 데이터를 추가한다. O(1)
- dequeue : 맨 앞의 데이터를 삭제한다. O(1)

#### 구현방식 
- Array-Based queue
	![](https://i.imgur.com/11XUq6Q.jpg)
	- enqueue와 dequeue 과정에서 남는 메모리가 생긴다. 
	- 따라서 메모리의 낭비를 줄이기 위해 Circular queue(원형 큐)형식으로 구현한다.
	- 고정된 저장 공간이기 때문에 dynamic array와 같은 방법으로 resize해야 한다.
	- 그렇기 때문에 전반적인 성능은 좋지만 최악의 경우 훨씬 느릴 수 있다.

- List-Based 
	- 재할당이나 메모리 낭비의 걱정을 할 필요가 없다.
	- enqueue를 할때마다 메모리 할당을 해줘야 하기 때문에 전반적인 runtime이 느릴 수 있다.

#### 활용 
하나의 자원을 공유하는 프린터, CPU task scheduling, Cache 구현, 너비우션탐색 등이 있다. 
추가로 개념을 확장한 자료구조들로 deque, priority queue가 있다.


#### Java에서는? 
Queue인터페이스가 존재하며 LinkedList 구현체를 사용한다. 
여기서 ArrayList가 아닌 LinkedList를 사용하는 이유는 LinkedList의 추가,삭제 시간복잡도가 O(1)이기 때문이다. (사실 O(n)이지만 위치를 알고 있을 경우 O(1)이다.)
Queue의 경우 맨 뒤에 데이터를 추가하고 맨 앞의 요소를 제거해야 하는 데 ArrayList의 경우 삭제 시 shift가 발생해 O(n)의 시간복잡도를 갖게 되므로 LinkedList를 사용하는 것이다.
이외에도 Priority Queue와 Queue를 확장한 Deque인터페이스와 구현체인 ArrayDeque 등이 있다.

### Deque 
Double-Ended Queue로 Queue 양쪽 끝에서 추가와 삭제가 일어날 수 있는 자료구조 
사용 방식에 따라 stack이 될 수 도 있고 Queue가 될 수 도 있다.
Java에서 Deque는 인터페이스로 구현체로는  ArrayDeque, ConcurrentLinkedDeque, LinkedBlockingDeque, LinkedList가 있는 데 주로 ArrayDeque를 사용한다. 

#### ArrayDeque 
Dynamic Array 방식이다. 
Queue 목적으로 구현했을 시 LinkedList보다 빠르다. 
LinkedList의 경우 주소를 변경하는 등의 추가적인 작업이 필요한 반면 ArrayDeque는 그저 값을 할당만 하면 되고 사이즈가 꽉찰 시 늘려주기만 하면 되기 때문이다. 
그렇지만 저장해야할 데이터의 양이 많다면 LinkedList가 더 좋을 수 도 있다. 
또한, ArrayDeque의 경우 배열을 사용하지만 remove의 경우 O(1)의 시간복잡도를 가지는 데 이는 원형 큐 방식으로 구현되어 있기 때문이다.

### Priority Queue
들어간 순서에 상관없이 우선순위가 높은 데이터가 먼저 나오는 자료구조 
Heap과 구현이 일치하며 완전이진 트리 구조를 가지고 있다. 
조건에 따라 min heap, max heap이 된다. 

#### 구현 
트리는 주로 LinkedList를 통해 구현하지만 Heap은 배열을 기반으로 구현한다. 
그 이유는 새로운 노드를 힙의 마지막 위치에 추가해야 하는 데 이때 배열을 기반으로 구현해야 수월하기 때문이다. 
이는 완전이진트리의 특성을 활용하기 때문이다. 
- n번째 node의 left child node = 2n 
- n번째 node의 right child node = 2n + 1
- n번째 node의 parent node = n/2

#### push & pop 
heap의 높이는 logN이다. 
- push : O(log n)
	- swap하는 과정이 최대 logN번 반복되기 때문에 
- pop : O(log n)
	- push와 마찬가지로 swap하는 과정이 최대 logN번 반복된다. 

#### Java에서는?
Queue 인터페이스를 상속받는 Priority Queue가 있다. 
우선순위를 Comparator를 통해 정의하거나 Comparable 인터페이스를 상속한 객체를 이용해줘야 한다.
null을 허용하지 않는다.


### HashTable 
> https://d2.naver.com/helloworld/831311

효율적인 탐색 즉, 빠른 탐색을 위한 자료구조로써 key-value 형태로 저장한다. 
해시 함수를 통해 어떠한 값을 변형시켜 키를 사용하며 이를 해싱이라고 한다. 
저장, 삭제, 검색의 시간복잡도는 모두 O(1)이다. 
HashTable을 구성하고 있는 key,value 데이터를 저장할 수 있는 각각의 공간을 slot 또는 bucket이라고 한다.

#### Direct-address Table 
직접 주소화 테이블이란, key값으로 k를 갖는 원소는 index k에 저장하는 방식이다. 
이런 방식으로 key-value 쌍의 데이터를 저장할 경우 많은 문제가 발생하게 된다. 
- 불필요한 공간 낭비 
	- 만약 key로 학번, value로 이름을 저장한다고 했을 때 2016001, 2022002와 같은 키를 저장할 경우 불필요한 공간이 생기게 된다.
- key가 다양한 자료형을 담을 수 없다. 
	- index 자체는 숫자이기 때문에 String이나 다른 자료형을 담을 수 없다. 
그렇기 때문에 HashTable에서는 해시 함수를 이용해 키 값 즉, index 값을 구하게 된다.
여기서 key는 무조건 존재해야 하며, 중복되는 key가 있어서는 안된다. 

#### Collision
서로 다른 key의 해시값이 똑같을 때 충돌이 일어난다. 즉, 중복되는 key는 없지만 해시값이 중복될 수 있는 데 이때 충돌이 발생했다고 한다. 
따라서 충돌이 최대한 적게 나도록 해시 함수를 잘 설계해야 하고, 충돌이 발생할 경우 seperate chaining 또는 open addressing 등의 방법으로 해결해야 한다.


#### Open Addressing 
충돌이 발생하면 미리 정한 규칙에 따라 hash table의 비어있는 slot을 찾는다. 
추가적인 메모리를 사용하지 않으므로 Seperate Chaining 방식에 비해 메모리를 적게 사용한다. 
빈 slot을 찾는 방법에 따라 크게 3가지로 나뉘게 된다. 
- **Linear Probing (선형 조사법)**
	- 충돌이 발생한 해시값으로부터 일정한 값만큼(+1, +2, + 3...) 건너 뛰어, 비어 있는 slot에 데이터를 저장한다. 
- **Quadractic Probing (이차 조사법)**
	- 제곱수 만큼(+1^2, +2^2, ...) 건너 뛰어 비어 있는 slot를 찾는다.
충돌 횟수가 많아지면 특정 영역에 데이터가 집중적으로 몰리는 클러스터링현상이 발생한다는 단점이 있다. 클러스터링 현상이 발생하면, 평균 탐색 시간이 증가하게 된다.

- **Double Hashing (이중해시, 중복해시)** 
	- Linear Probing, Quadractic Probing을 통해 탐사할 때는 탐사이동폭이 같기 때문에 클러스터링 문제가 발생할 수 있다. 
	- 클러스터링 문제가 발생하지 않도록 2개의 해시함수를 사용한다. 
	- 하나는 최초의 해시값을 얻을 때 사용하며 다른 하나는 해시 충돌이 발생할 때 탐사 이동폭을 얻기 위해 사용한다.


#### Separate Chaining 
LinkedList나 Tree를 이용해 충돌을 해결한다. 
충돌이 발생하면 LinkedList에 노드 즉, slot를 추가하여 데이터를 저장한다. 
- 삽입 : 서로 다른 두 키가 같은 해시값을 갖게 되면 LinkedList에 노드를 추가하여 (key,value) 데이터 쌍을 저장한다. O(1)
- 검색 : 기본적으로 O(1) 이지만 최악의 경우 O(n)의 시간복잡도를 갖는다. 
- 삭제 : 삭제를 하기 위해 검색을 먼저 해야하므로 검색의 시작복잡도와 동일하다
최악의 경우 n개의 모든 key가 동일한 해시값을 갖게 되면 길이가 n인 LinkedList가 생성되게 된다.
기본적으로 LinkedList를 이용해서 데이터를 저장하지만, 충돌이 많이 발생해 LinkedList의 길이가 길어지면 Binary Search Tree(BST)자료구조를 이용하여 데이터를 저장하기도 한다. 
BST를 사용함으로써 검색의 최악 시간복잡도를 O(n) -> O(logn)으로 낮출 수 있다. 
그렇기에 자바의 경우 Separate Chaining방식으로 충돌을 해결하며 자바 7까지는 LinkedList를 사용하고 자바 8 이후부터는 LinkedList와 Red-Black Tree를 병행하여 사용하여 해결한다.
> 자바에서 Separate Chaining 방식을 사용하는 이유는 Open Addressing은 데이터를 삭제 할 때 처리가 효율적이기 어려운 데 삭제는 빈번하게 일어나기 때문이다. 
> 또한, 데이터의 개수가 많아지게 되면 일반적으로 Open Addressing은 Separate Chaining 방식보다 느리게 된다. 
> 반면, Separate Chaining방식의 경우 해시 충돌이 발생하지 않도록 조정할 수 있다면 최악에 가까운 일이 발생하는 것을 줄일 수 있다. (자바의 HashMap은 보조 해시 함수를 통해 이를 해결한다.)


#### 시간복잡도 & 공간복잡도 
- 시간복잡도는 저장,삭제,검색 모두 기본적으로 O(1)이지만, 충돌로 인해 최악의 경우 O(n)이 될 수 있다. 
- 공간효율성은 떨어진다. 데이터가 저장되기 전에 미리 저장공간을 확보해야 하기 때문이다. 
	- 저장공간이 부족하거나 채워지지 않은 부분이 많은 경우가 생길 수 있다.


### Java에서의 Map 
Map인터페이스를 가지고 있으며 구현체로는 HashTable, HashMap, LinkedHashMap, TreeMap 등이 있다.
hashCode() 메서드가 반환하는 값은 32비트 정수 자료형으로 완전한 자료 해시 함수를 만들 수 없다. 논리적으로 생성 가능한 객체의 수가 2^32보다 많을 수 있기 때문이다. 또한, Map 객체에서 O(1)을 보장하기 위해 랜덤 접근이 가능하게 하려면 원소가 2^32인 배열을 모든 Map이 가지고 있어야 할 것이다. 
따라서 메모리의 낭비를 줄이기 위해 실제 해시 함수의 표현 정수 범위보다 작은 M개의 원소가 있는 배열만을 사용하게 된다.
```
int index = X.hashCode() % M;
```


#### HashTable 
- key, value가 null값이 되면 안되고, 동기화가 되어 있다.
- 버킷의 수는 고정되어 있고 저장된 데이터만 증가하다가 load factor(저장된 데이터 / 용량)가 0.75가 되었을 때 리사이징 작업을 수행한다. 



#### HashMap 
- HashTable을 보완하였다.
- key, value에 null이 허용된다.
- 비동기로 작동하며 HashTable보다 싱글 스레드 환경에서 성능이 좋다. 
- 멀티 스레드 환경에서는 ConcurrentHashMap을 사용한다.  
	- 버킷마다 락을 걸어 처리하기 때문에 효율성이 좋다. (DB의 레코드락과 비슷)
	- https://roynus.tistory.com/672
