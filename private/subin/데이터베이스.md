---

mindmap-plugin: basic

---

# 데이터베이스

## 정규화
- 이상현상

## 트랜잭션
- 개념
- 격리수준
   - ACID의 격리성을 보장하면서도 성능을 보장하기 위한 trade off의 정도
   - ANSI 표준은 4단계로 나눔

## ACID
- Atomicity (원자성)
   - 모두 성공하거나 혹은 모두 실패
   - All or Nothing
- Consistency (일관성)
   - 일관성 있는 데이터베이스 상태를 유지해야 한다
   - ex) 무결성 제약조건
- Isolation (격리성)
   - 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리해야 한다
   - 격리성은 동시성과 관련된 성능 이슈로 인해 격리수준을 선택할 수 있다
   - 단점
      - 트랜잭션간에 격리성을 완벽히 보장하려면 동시에 처리되는 트랜잭션을 거의 차례대로 실행을 해야함
         -> 처리성능 매우 bad
      - 따라서 ANSI 표준은 트랜잭션 격리 수준을 4단계로 나누어 정의함
- Durability (지속성)
   - 트랜잭션이 끝났다면 그 결과가 기록되어야 한다

## LOCK

## 샤딩
- stateless
   - API 서버들은 대부분 Stateless
      - 로드밸런서에 추가
   - DB서버는 stateful한 서버
      - scale up
      - 읽기 분산 (Query off)
         - 8Read:2Write
- Database Partitioning
   - Vertical
      - 하나의 Table을 컬럼 기준으로 나눈다 (스키마 변경)
         - 자주 사용하는 컬럼과 자주 사용하지 않는 컬럼으로 나누어서 성능 향상
   - Horizontal (샤딩)
      - 같은 Table을 데이터 기준으로 나눈다 (스키마 동일)
      - 1 2 3 4 -> 1 2 / 3 4
      - 여러대의 DB와 연결이 되어야 한다
      - 이슈
         - 어떤 데이터를 어디에 저장할까?
         - 특정 키를 저장하는 방법
            (특정 키를 찾는 방법)
      - 방법
         - Range
            - 특정 범위대역으로 나누닉
               - 장점
                  - 새로운 Shard를 추가하는것이 다른것보다 쉽다
               - 단점
                  - Shard간 데이터가 균등하지 못할 가능성이 높다
         - Modular
            - 서버 대수로 나누기 (ID%N)
               - 장점
                  - 데이터의 분배가 균등한 편
               - 단점
                  - 서버 대수의 변화에 굉장히 취약하다
                  - 데이터의 이동이 심해진다
                  - 두배로 늘리면 편함
         - Indexed
            - 특정 데이터의 위치를 가리키는 서버가 존재
               - 장점
                  - 데이터의 분배를 원하는 형태로 하기 쉽다
               - 단점
                  - Indexed 자체가 하나의 서비스가 되어야 한다 (SPOF될수있음)
                     - 완화
                        - 요청후에 User 위치정보를 저장후, 이후 요청은 해당 데이터로 한다
                           재요청시 -> 유저정보가 없는경우 / 유저 정보가 변경되어 유저정보가 없다는 응답을 받는 경우
                        - 단, 이에 대한 구현이 필요하다

## Replication
- 데이터의 복제
   - Primary의 데이터를 Secondary에 복사해서 데이터의 싱크를 맞추는 작업
   - 만약 이런 Replication이 제대로 동작하지 않는다면, 데이터 유실이 많이 발생하게 된다
- 장애시 FailOver
   - Active/StandBy 패턴
      - Active
         - Primary는 읽기/쓰기를 모두 담당한다
      - StandBy
         - Primary의 데이터를 Replication 받다가
            primary 장애시에 Primary로 승격되어 읽기/쓰기를 담당하게 된다
         - 처리되지 않은 로그들을 모두 처리 후 Primary로 승격
         - MySQL의 MHA, MMM 방식등이 있음
      - 몇대의 StandBy가 좋을까?
         - 데이터의 갭이 크면 데이터의 복제에 많은 부하가 발생한다
         - 기본적으로 2대의 Secondary를 추천하지만 비용이 더 든다
      - StandBy 서버도 Active와 같은 규모의 장비
         - 서비스의 성능을 높이기 위해서 Primary에서 Write를 하고, Secondary에서 Read를 사용할 수 있음
      - Replication Lag
         - Primary와 Secondary의 데이터가 다르므로, 이미 쓰여진 데이터를 읽지 못할 수 있다
            - 내가 쓴 SNS 댓글이 보이지 않는다
            - 내가 송금한 금액이 보이지 않는다
               - 크리티컬함
            - 서비스에서 허용할 수 있는 경우와 허용할 수 없는 경우가 존재한다
         - Primary의 데이터를 Secondary가 복제할 경우 데이터의 시간차가 발생한다
         - 데이터 복제는 Eventual Consistency를 제공한다
         - Replication Lag가 발생한 상황에서 데이터를 캐시하게 되면 문제가 오래 지속될 수 있음

## FailOver
- 서비스 가용성을 제공하기 위해 사용