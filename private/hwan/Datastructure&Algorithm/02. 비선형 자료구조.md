> 하나의 자료 뒤에 여러 개의 자료가 존재할 수 있는 것

## Graph 
노드(정점, node, vertext)와 그 노드를 연결하는 간선(E, edge)로 이루어진 자료구조이다.
간선은 가중치를 가질 수 도 있으며 방향 유무에 따라 방향그래프(한 쪽으로만)와 무방향(양 방향) 그래프로 나뉘어진다. 또한, 모든 정점 사이에 간선이 존재할 경우 완전 그래프라고 불린다. (무방향일 시 정점의 수가 n이면 간선의 수가 (n * n-1) / 2이다.)

### 용어 
- 차수 : 무방향 그래프에서 한 정점에 인접한 정점 수 (간선 수)
- 진입 차수 : 방향 그래프에서 내부로 향하는 간선 수 
- 진출 차수 : 방향 그래프에서 외부로 향하는 간선 수 
- 사이클 : 경로의 시작 정점과 종료 정점이 동일한 것 


### 연결, 비연결 그래프 
- 연결 그래프 
	- 무방향 그래프에 있는 모든 정점쌍에 대해서 항상 경로가 존재하는 경우 
	- Tree
- 비연결 그래프 
	- 무방향 그래프에서 특정 정점쌍 사이에 경로가 존재하지 않는 경우


### 구현 
#### 인접행렬 방식 
그래프의 노드를 2차원 배열로 만든 것 
인정 정점이라면 1, 아니면 0으로 표현한다. 
간선의 수와 무관하게 항상 n^2 메모리 공간이 필요하며 무방향 그래프일 시 대칭 행렬이 된다. 
2차원 배열 안에 모든 정점들의 간선 정보를 담기 때문에 배열의 위치를 확인한다면 두 점에 대한 연결 정보를 조회할 시 O(1)의 시간복잡도면 가능하고 구현이 비교적 간편하다는 장점이 있다. 
하지만 무조건 2차원 배열이 필요하므로 메모리 낭비가 있고 BFS, DFS 등과 같은 그래프 알고리즘들을 사용할 시 인접한 노드를 찾기 위해서는 모든 노드를 전부 순회해야 하는 단점이 있다.

#### 인접 리스트 
그래프의 노드들을 리스트로 표현한 것 
필요한 만큼의 메모리만 사용하기 때문에 메모리 낭비가 없고 정점들의 연결 정보를 확인하려 할 때는 간선의 갯수만큼의 탐색이 필요하다. (O(n), n : 간선의 갯수)
하지만 특정 두 점이 연결되었는 지 확인하려면 인접행렬에 비해 시간이 오래 걸리며 구현이 비교적 어렵다는 단점이 있다. 

#### 어떤 기준으로 선택해야 할까? 
- 인접 리스트 
	- 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프의 경우 
	- 장점 
		- 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있다. 
		- 그래프에 존재하는 모든 간선의 수는 O(N + E)안에 알 수 있다. 
	- 단점 
		- 간선의 존재 여부와 정점의 차수
- 인접 행렬 
	- 그래프에 간선이 많이 존재하는 밀집 그래프의 경우 
	- 장점 
		- 두 정점을 연결하는 간선의 존재 여부 
		- 정점의 차수는 O(N)안에 알 수 있다. 
	- 단점 
		- 어떤 노드에 인접한 노드들을 찾기 위해서는 모든 노드를 전부 순회해야 한다. 
		- 그래프에 존재하는 모든 간선의 수는 O(N^2)안에 알 수 있다.


### 그래프 탐색 
#### 깊이 우선 탐색 (DFS)
루트 노드(또는 임의의 노드)에서 시작해 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법 
즉, 갈 수 있는 만큼 최대한 깊이 가고 더 이상 갈 곳이 없다면 이전 정점으로 돌아가는 방식으로 그래프를 순회하는 방식이다. 
**모든 노드를 방문하고자 하는 경우**에 선택하며 재귀호출이나 스택을 사용하여 구현한다.
-   인접 행렬 : O(V^2)
-   인접 리스트 : O(V+E)


#### 넓이 우선 탐색 (BFS)
루트 노드(또는 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법 
즉, 시작정점을 방문한 후 시작 정점에 인접한 모든 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선방문하는 방법이다.
두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 선택하며 큐를 사용하여 구현한다.
-   인접 행렬 : O(V^2)
-   인접 리스트 : O(V+E)


## Tree 
값을 가진 노드(Node)와 이 노드들을 연결해주는 간선(Edge)로 이루어져 있다. 
모든 노드들은 0개 이상의 자식 노드를 가지고 있으며 부모-자식 관계 즉, 계층적 관계를 표현하는 자료구조이다.

### 구성 요소 
#### 노드 
값을 가지고 있는 트리의 구성 요소이다. 
모든 노드는 0개 이상의 자식 노드를 가지고 있으며, 그런 관계를 자식-부모 관계라고한다. 
- 루트 노드 : 트리 구조에서 최상위에 있는 노드 
- 단말 노드 : 하위에 다른 노드가 연결되어 있지 않은 노드 
- 비단말 노드 : 단말 노드를 제외한 모든 노드 

#### 간선 
트리를 구성하기 위해 노드와 노드를 연결하는 선 

#### 층 (level)
각 층별로 숫자를 매겨 트리의 레벨로 사용한다. 
트리의 최고 레벨을 트리의 높이라고 한다. 


### 특징 
단 하나의 루트 노드를 가지며 루트에서 한 노드로 가는 경로는 유일하다. 
계층 모델이며 노드가 N개인 트리는 항상 N-1개의 간선을 가진다.
트리는 방향성이 잇는 비순환 그래프로 **사이클이 없다.** (그래프와 트리의 차이)

### 그래프와 트리의 차이 
![](https://i.imgur.com/43aeBs8.png)
[출처](https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html)
- 무조건 방향 그래프 
- 사이클 불가능 
- 루트 노드 개념 
- 계층 구조 
- 노드가 N이라면 트리는 항상 N-1개의 간선 존재 

### 순회 방식 
- 전위 순회 : Root -> Left Child -> Right Child 
- 중위 순회 : Left Child -> Root -> Rigth Child 
- 후위 순회 : Left Child -> Rigth Child -> Root 
- 레벨 순회 : 루트로부터 계층별로 방문하는 방식



## Binary Tree (이진 트리)
루트 노드를 중심으로 두 개의 서브 트리로 나뉘어 지며, 각 서브 트리 또한 이진 트리이다. 
즉, 각 노드가 최대 두개의 자식을 갖는 트리이며 자식 노드들도 이진 트리를 만족해야 한다. 
이진 트리를 배열로 구성할 경우, i번째 노드에 대하여 parent(i) = i / 2, left_child(i) = 2 * i, right_child(i) = 2 * i + 1 의 index를 갖는다. 


### 종류 
![](https://i.imgur.com/PinYU8B.png)


#### 포화 이진 트리(Perfect Binary Tree)
![](https://i.imgur.com/cZQ0vOK.png)
모든 레벨이 꽉 찬 이진 트리이다.
즉, 모든 말단 노드는 같은 높이에 있어야 하며, 마지막 단계에서 노드의 개수가 최대가 되어야 한다. 
모든 내부 노드가 두 개의 자식 노드를 가지며 노드의 개수는 정확히 2^(h - 1)개여야 한다. (h : 트리의 높이)
정 이진 트리이며 완전 이진 트리인 경우이다.


#### 정 이진 트리 (Full Binary Tree)
![](https://i.imgur.com/lNJkgG1.png)
모든 노드가 0개 또는 2개의 자식 노드를 갖는 이진 트리이다.


#### 완전 이진 트리 (Complete Binary Tree) 
![](https://i.imgur.com/YX7Rt5h.png)
위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 채워진 이진 트리이다. (마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있다.)
배열을 통해 효율적으로 표현이 가능하다.


## Binary Search Tree (이진 탐색 트리)
이진 트리의 일종으로, 데이터를 저장하는 규칙들을 규정하여 데이터를 효율적으로 탐색할 수 있게 합니다. 
정렬된 트리로 볼 수 있고 검색과 저장, 삭제의 시간복잡도는 모두 O(log n)이고, 최악의 경우 O(n)이다. (한쪽으로 치우진 트리일 경우)
- 모든 왼쪽 자식들 < n < 모든 오른쪽 자식들 (모든 노드 n에 대해서 반드시 참)


### 데이터 저장 규칙 
1. 이진 탐색 트리의 노드에 저장된 키는 유일하다. (중복 허용 X)
	- 검색 목적 자료구조이니 중복이 많은 경우 트리를 사용하여 검색 속도를 느리게 할 필요가 없다. (트리에 삽입하는 것보다, 노드에 count값을 가지게 하여 처리하는 것이 훨씬 효율적)
2. 부모의 키가 왼쪽 자식 노드의 키보다 크다. 
3. 부모의 키가 오른쪽 자식 노드의 키보다 작다. 
4. 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.


### 필요성 
이진 탐색 트리는 이진탐색과 연결리스트를 합하여 각각의 단점을 보완하고 장점을 모두 얻는다. 
이진 탐색의 경우 탐색에 소요되는 시간 복잡도가 O(log n)이라는 장점을 가지고 있지만, 데이터의 삽입 및 삭제가 불가능하다는 한계가 존재한다. (정렬때문인가..?)
연결 리스트의 경우 삽입과 삭제의 시간 복잡도는 O(1)이지만, 탐색은 O(N)이라는 단점이 있다.
이렇게 두 가지 장점을 합하여 효율적인 탐색 능력을 가지고 ,자료의 삽입 및 삭제가 가능한 자료구조가 탄생한 것이다.


### 검색 
![](https://i.imgur.com/Cp8MzwG.png)
[출처](https://www.inflearn.com/course/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%A0%84%EA%B3%B5%EB%A9%B4%EC%A0%91-cs-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B5/dashboard)
중위 순회 방식을 따르며 이를 통해 정렬된 순서로 자료를 탐색할 수 있다. 

### 삭제 
- 자식이 없는 단말 노드의 경우 : 삭제 
- 자식이 1개인 노드인 경우 : 지워진 노드의 자식을 올린다. 
- 자식이 2개인 노드인 경우 : 오른쪽 노드의 가장 작은 값 또는 왼쪽 자식 노드의 가장 큰 값을 올린다.

### 장,단점 
- 장점 
	- 탐색 연산의 시간복잡도가 O(log n)이다. 정확히는 트리의 높이 h에 대하여 O(h)의 시간복잡도를 갖는다. 
- 단점 
	- 편향 트리 즉, 한쪽으로 치우치게 되면 시간복잡도가 O(n)이 될 수 있다. 이렇게 되면 Linked list와 다를게 없어진다.
단점을 보완하기 위해 트리의 균형을 맞춰주는 재조정이 필요하며, 이러한 기법을 이용한 트리를 자가 균형 이진 탐색 트리라고 한다. 알고리즘으로 이진 트리의 균형이 잘 맞도록 유지하여 높이를 가능한 낮게 유지하며 종류로는 AVL트리와 Red-black Tree가 있다.


## 신장 트리 
그래프 내 모든 정점이 연결되어 있으면서 사이클이 없는 트리를 말한다. 
간선들을 통해서 모든 노드들이 연결되어 있고 그 안에서 사이클이 존재 하지 않아야 한다.


## Heap 
> 우선순위 큐 : 데이터들이 우선순위를 가지고 있고 우선순위가 높은 데이터가 먼저 나가는 자료구조 
> 힙을 통해 구현한다. 

완전 이진 트리이며, 자식 노드들이 특정한 성질을 가지고 정렬 즉, 부모 - 노드 간에 정렬되어 있는 자료 구조이다. (모든 정점이 자신의 자식 요소보다 우선순위가 높다는 성질을 가지고 있다.)
반정렬된 상태라고도 부르며 중복된 값을 허용한다. (큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도)
각 힙의 루트에 저장된 값이 가장 큰/작은 값이기 때문에 최대/최소 값을 탐색하는 시간은 O(1)이라는 장점을 가진다.

### 종류 
최대힙과 최소힙 2종류가 존재한다. 
- 최대 힙 : 각 노드의 값이 자식들보다 크거나 같다. 
- 최소 힙 : 각 노드의 값이 자식들보다 작거나 같다.

### 구현 
주로 배열을 통해 구현된다. 그 이유는 새로운 노드를 힙의 마지막 위치에 추가해야 하는 데, 이때 배열기반으로 구현해야 이 과정이 수월해지기 때문이다. 즉, 완전이진트리의 특성을 활용해 배열의 index만으로 부모 자식 간의 관계를 정의할 수 있기 때문에 배열을 사용한다. (Linked List를 사용할 시 마지막 위치를 찾아야 할 때 시간이 오래걸리기 때문...?)

구현의 편의를 위해 배열의 0번째 index는 사용하지 않고 1번 index에 루트 노드가 들어간다. 
- 부모 노드와 자식 노드 관계 (완전 이진 트리의 특성)
	- n번째 노드이 left child node = 2n 
	- n번째 노드의 right child node = 2n + 1
	- n번째 노드의 parent node = n/2


### 삽입 (push)
1. 원소를 힙의 가장 마지막 노드에 추가 
2. 추가한 원소를 부모와 비교하여 조건과 일치한다면 중지
	- 최대 힙 기준 부모 노드의 값이 더 클 경우 
3. 일치하지 않는다면 부모와 위치를 교환 후 2~3번 반복
	- 최대 힙 기준 부모 노드이 값이 더 작을 경우

힙의 높이는 log n이다. 
교환하는 과정이 최대 log n번 반복되기 때문에 시간복잡도는 O(log n)이다.

### 삭제 (pop)
힙에서 다음 값(최대값/최소값)을 추출하고 다음 값을 루트 노드로 만드는 작업이다.
1. 힙의 루트 노드 삭제 
2. 마지막 노드를 루트로 이동 
3. 루트를 자식 노드와 비교하여 조건과 일치한다면 중지 
	- 최대 힙 기준 루트 노드의 값이 자식 노드 보다 더 클 경우
4. 루트와 위치를 교환한 후 3~4번 반복
	- 최대 힙 기준 루트 노드의 값이 자식 노드 보다 더 작을 경우
	- 자식 노드가 더 크지 않을 때까지 과정 반복


## 트라이(Trie) 
> https://rebro.kr/86


![](https://i.imgur.com/4ShGgmT.png)

문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조이다. 
이진 탐색 트리는 원소를 찾는데 O(log n)의 시간복잡도를 가지게 된다. 하지만 문자열의 경우 두 문자열을 비교하기 위해서는 문자열의 길이만큼 시간이 걸리기 때문에 원하는 문자열을 찾기 위해서는 O(MlogN)의 시간이 걸리게 된다. (M : 문자열의 길이)
이 단점을 해결하기 위한 자료구조가 트라이이다.
트라이의 경우 탐색 시 시간복잡도가 O(L)이다. (L == 가장 긴 문자열의 크기)


## 자가 균형 이진 탐색 트리 
> 균형 트리 : 모든 하위 트리의 높이 차이가 1 이하인 트리

트리에서 노드의 삽입, 삭제와 같은 연산이 일어날 때 자동으로 균형 트리를 유지하는 이진 탐색 트리이다.
균형을 유지하기 위해 사용되는 균형도란 왼쪽과 오른쪽 하위 트리 높이의 차이를 뜻한다. 
트리에는 여러 가지 균형 조정방법이 있지만 보통 두 작업을 기반으로 한다. 
- 노드 분할 및 병합 : 노드의 자식은 두 개를 초과하지 못하며, 노드가 많으면 두 개의 하위 노드로 나눈다. 
- 노드 회전 : 간선을 전환한다. 즉, x가 y의 부모이면 y를 x의 부모로 만들고 x는 y의 자식 중 하나를 거둔다.


## AVL Tree 
스스로 균형을 잡는 이진 탐색 트리이다.
왼쪽, 오른쪽 서브 트리의 높이 차이는 최대 1이 되며 어떤 시점에서 높이 차이가 1보다 커지면 회전을 통해 균형을 잡아 높이 차이를 줄이게 된다. 

### 회전 
![](https://i.imgur.com/aTdOoAg.png)
https://yoongrammer.tistory.com/72




## Red-Black Tree 
> https://zeddios.tistory.com/237
> https://blogshine.tistory.com/102
![](https://i.imgur.com/uR6NIXN.png)

이진 탐색 트리를 기반으로 한 자료구조로, 데이터의 탐색, 삽입, 삭제 연산이 전부 O(log n)이라는 시간복잡도가 소요되는 장점을 가지고 있다. 
이진 탐색 트리에서 높이를 최소화한 완전 이진 탐색 트리를 구현하여 시간복잡도를 줄이는 것이 핵심이다. (노드의 자식이 없을 경우 NIL 값을 저장한 후 단말 노드로 간주하게 된다.)
즉, 레드-블랙 트리는 트리 연산의 복잡성에 영향을 미치지 않으면서 트리 균형을 유지하는 것을 목표로 한다.
이진 탐색 트리의 단점 중 편향된 트리의 경우에 발생하는 단점을 보완하기 위해 균형 상태로 트리를 유지한다. 즉, 루트 노드부터 단말 노드까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. 
AVL 트리는 레드-블랙 트리에 비해 더 균형적이지만, 노드의 삽입과 삭제 과정에 더 많은 회전 연산이 일어날 수 있다. 따라서, 노드의 삽입 및 삭제 연산의 빈도가 높은 경우 레드-블랙 트리를 사용하는 것이 좋다. 

### 규칙 
- 모든 노드는 Black 또는 Red의 색을 갖는다. 
- 루트 노드의 색은 Black이다. 
- 단말 노드의 색은 Black이다. 
- 어떤 노드의 색이 Red라면 다른 두 개의 자식의 색은 Black이다. 
- 각 노드에 대해서 노드로부터 descendant leaves 까지의 단순 경로는 전부 같은 수의 Black 노드를 포함하고 있다 이때, 해당 Black 노드의 수를 **Black Height**라고 부른다