## 인터럽트란? 
인터럽트란 CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등 예외상황이 발생하여 처리가 필요한 경우 CPU에게 알리는 일종의 이벤트를 뜻한다. 
인터럽트의 발생은 CPU 옆에 있는 인터럽트 라인이 감지하게 된다. 기본적으로 CPU는 매 시점 메모리에서 명령을 하나씩 읽어와서 수행할 때마다 인터럽트가 발생했는 지 확인한다.
인터럽트가 발생되면 인터럽트 핸들러 함수가 모여 있는 인터럽트 백터로 가서 인터럽트 핸들러 함수가 실행된다. 인터럽트 간에는 우선순위가 있고 우선순위에 따라 실행되며 인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다.

> 인터럽트 핸들러 함수 
> 인터럽트가 발생했을 때 이를 핸들링하기 위한 함수 
> 커널 내부의 IRQ를 통해 호출되며 request_irq()를 통해 인터럽트 핸들러 함수를 등록할 수 있다.


### 왜 필요한가? 
하나의 CPU에서는 매 순간 하나의 프로그램만 실행시킬 수 있다. 
그렇기 때문에 CPU를 할당받아 실행되고 있는 프로그램이 I/O처리와 같이 수행하는데 오래 걸리는 작업을 할 때에도 CPU를 점유하고 있다면, 자원을 낭비하는 꼴이 될 것이다. 
따라서 운영체제는 자원의 효율적 관리라는 가장 중요한 목표를 달성하기 위해 인터럽트라는 방식을 사용한다. 

또한, 선점형 스케줄러에서 프로세스가 Running 중에 스케줄러에 의해 중단되게 된다. 그렇게 하기 위해서는 스케줄러의 코드가 실행이 되어 현재 진행중인 프로세스를 중지시킬 수 있어야 한다. 스케줄러도 하나의 프로그램이니 말이다. 
프로세스가 스스로 중단하는 것이 아닌 스케줄러가 강제로 중단을 시키는 것이고 인터럽트는 이러한 부분에서도 필요한 기능이다.


### 하드웨어 인터럽트 (비동기적 인터럽트)
![](https://i.imgur.com/rp4Cop2.png)
키보드를 연결한다거나 마우스를 연결하는 일 등의 I/O 디바이스에서 발생하는 인터럽트를 뜻한다. 실행 중인 명렁어와 무관하게 발생하는 인터럽트이기 때문에 비동기적 인터럽트라고 부르기도 한다. 그렇기에 하드디스크 읽기 오류나 메모리 불량과 같은 하드웨어적인 오류시에도 일어난다.

컴퓨터와 연결되는 하드웨어에는 기본적으로 하드웨어의 CPU와도 같은 역할을 하는 컨트롤러와 로컬 버퍼라는 작은 메모리가 존재한다. 
프로그램이 하드웨어에 어떤 데이터를 요청하면, 하드웨어는 필요한 데이터를 하드웨어의 로컬 버퍼에 임시로 저장한다. 이후 로컬 버퍼에 프로그램으로 전달할 데이터가 충분히 쌓이면 프로그램으로 데이터를 전달하기 위해 CPU에 작업을 요청하는데, 이때 작업 요청을 하기 위해 하드웨어의 컨트롤러가 인터럽트를 발생시킨다. 
즉, 하드웨어가 요청된 데이터를 모두 준비했다고 CPU에게 알리는 것이다.

이때 인터럽트 라인이 설계된 이후 순차적으로 인터럽트 실행을 중지하고 운영체제에 시스템콜을 요청해서 원하는 디바이스로 향해 디바이스에 있는 작은 로컬 버퍼에 접근하여 일을 수행한다. 
예를 들어 디스크 컨트롤러가 인터럽트를 발생시키면 CPU는 하던 일을 잠시 멈추고 이 인터럽트가 발생했을 때 수행하도록 정의된 코드를 찾아 수행한다. 이때 수행하는 일은 디스크의 로컬버퍼에 있는 내용을 사용자 프로그램의 메모리로 전달하고, 해당 프로그램이 CPU를 할당받을 경우 다음 명령을 수행할 수 있음을 표시해두는 일이다.

- 하드디스크 읽기 오류나 메모리 불량과 같은 하드웨어적인 오류 
- 키보드, 마우스와 같은 사용자 입력에 의한 인터럽트


### 소프트웨어 인터럽트 (동기적 인터럽트)
트랩이라고도 불리며, 소프트웨어가 발생시키는 인터럽트이다. 프로그램 오류가 발생하여 예외가 발생하거나, 시스템 콜을 통해 커널 함수를 호출할 때 작동한다.
프로세스가 실행 중인 명령어로 인해 발생하기 때문에 동기적 인터럽트라고도 불린다.

- 예외 상황 
	- 프로세스가 0으로 나누는 연산 등 불가능한 작업을 시도하거나, 자신의 메모리 영역 바깥을 접근하려는 시도를 할 때 이에 대한 처리를 위해 발생시키는 인터럽트
- 시스템 콜 
	- 프로그램이 자신이 작성하지 않은 코드를 운영체제로부터 서비스받기 위해 발생시키는 인터럽트이다.
	- 운영 체제의 서비스를 받기 위해 커널 함수를 호출하는 것이라고 생각하면 된다.
	- 예를 들어 애플리케이션 개발자가 프로그램 작성 중 키보드 입력이나 화면 출력 등의 입출력 작업이 필요할 경우 본인이 직접 입출력을 수행하는 코드를 작성하는 것이 아닌 이미 존재하는 커널의 코드를 호출해서 처리한다.


### 하드웨어 인터럽트 VS 소프트웨어 인터럽트 
CPU 인터럽트 라인에 신호를 보내서 인터럽트를 알려주는 방식은 똑같다. 
다만 하드웨어 인터럽트는 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅하는 반면, 소프트웨어 인터럽트는 소프트웨어가 CPU의 인터럽트 라인을 세팅한다.

시스템 콜이나 예외상황은 모두 사용자 프로세스로부터 CPU의 제어권이 운영체제에 이양되어 처리되는데, 이 과정에서 프로그램 코드가 직접 인터럽트 라인을 세팅하는 명령을 실행하여 제우권이 넘어가게 되므로 이들도 넓은 의미에서는 인터럽트의 범주에 포함시키게 된다.


### 인터럽트 벡터 
운영 체제는 할 일을 쉽게 찾아가기 위해 인터럽트 벡터를 가지고 있다. 
인터럽트 백테란 인터럽트 종류마다 번호를 정해서 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키고 있는 자료구조를 뜻한다.


### 인터럽트 처리 루틴 (인터럽트 핸들러)
인터럽트 벡터에서 실제 처리해야 할 코드를 인터럽트 처리 루틴 혹은 인터럽트 핸들러라고 부른다. 

인터럽트 처리 루틴을 통해 해당하는 인터럽트 처리를 완료하고 나면 원래 수행하던 작업으로 돌아갈 위치를 알아야 하므로 인터럽트 처리 전에 수행 중이던 작업이 무엇이었느 지 반드시 저장해야 하는데, 이러한 정보를 저장하기 위해 운영 체제는 PCB라는 공간을 별도로 가지고 있다.

### 인터럽트 핸들링 
인터럽트가 발생한 경우 처리해야 할 일의 절차를 의미한다. 
프로그램 A가 실행되고 있을 때 인터럽트가 발생하면 A의 현재 상태를 먼저 저장한다. 여기서 현재 상태란 현재 CPU에서 실행 중인 명령의 메모리 주소를 포함해 몇 가지 부가적인 정보들을 의미한다. 
CPU에서 명령이 실행될 때에는 CPU 내부에 있는 임시 기억장치인 레지스터에 데이터를 읽거나 쓰면서 작업을 하는 데, 이때 인터럽트가 발생해 새로운 명령을 실행하면 기존의 레지스터값들이 지워지게 되므로 CPU 내의 이러한 상태를 저장해두어야 한다. 이것을 모두 저장한 후에야 인터럽트 처리가 이루어질 수 있는 것이다. 

그렇기에 운영체제는 현재 시스템 내에서 실행되는 프로그램을 관리하기 위해 프로세스 제어블록 즉, PCB라는 자료구조를 둔다. 

PCB는 각각의 프로그램마다 하나씩 존재하며 해당 프로그램의 어느 부분이 실행 중이었는지를 저장하고 있다. 구체적으로는 프로그램이 실행 중이던 코드의 메모리 주소와 레지스터값, 하드웨어 상태 등이 저장된다.
만약 어떤 프로그램이 실행되던 중에 인터럽트가 발생하면 그 프로그램의 실행 상태를 PCB에 저장한 후 CPU의 제어권이 인터럽트 처리루틴으로 넘어가게 되고, 인터럽트 처리가 끝나면 저장된 상태를 PCB로부터 CPU상에 복원해 인터럽트 당하기 직전의 위치부터 실행이 이어지게 되는 것이다. 

결국 운영체제는 인터럽트가 발생할 때에만 실행된다. CPU는 항상 사용자 프로그램에 의해 사용되며, 운영체제는 단지 인터럽트가 발생했을 때에만 잠깐 CPU의 제어권을 획득할 수 있기 때문이다. 즉, 인터럽트가 발생할 때에만 운영체제 코드 부분으로 CPU가 이양되어 인터럽트 처리를 수행하게 된다. 



## 인터럽트 처리 과정 
![](https://i.imgur.com/20WDv8n.jpg)
앞써 운영체제에는 인터럽트에 대한 처리 행위가 미리 정의되어 있다고 했고 이를 인터럽트 벡터라고 했다. 
인터럽트 종류마다 번호를 정해서 번호에 따라 처리해야 할 코드가 쌍으로 이루어져 있으며 인터럽트 번호를 IRQ(Interrupt ReQuest lines)라고 한다. 

그리고 인터럽트는 한 번에 하나씩 발생하는 것이 아니라 한 순간에 여러개가 동시에 발생할 수 있다. 이렇게 동시에 발생하는 인터럽트를 하나로 묶어서 처리하는 것이다. 

위에서 말한 인터럽트 핸들링에 대해 더 자세히 알아보자. 
1. 인터럽트가 발생하면 현재 실행 중인 프로세스는 일시 중지되며, 인터럽트 처리 후 인터럽트가 발생한 지점부터 다시 실행시키기 위해 현재 상태를 PCB에 저장한다.
2. 인터럽트 컨트롤러가 실행되어 인터럽트 처리 순서를 결정한다. 이때 여러 개의 인터럽트가 동시에 발생했다면 인터럽트의 우선순위를 고려하여 중요한 인터럽트를 먼저 처리한다. 
3. 처리할 인터럽트를 선정되었다면 인터럽트 벡터에서 인터럽트 처리 루틴의 주소를 찾는다.
	- 운영체제의 전부를 메모리에 항상 적재시키는 것은 어렵기 때문에, 운영체제의 가장 핵심적인 부분인 커널만을 메모리에 상주시켜놓는다. 즉, 운영체제 역시 메모리에 존재하는 프로그램이다. 
	- 인터럽트 처리는 커널의 코드를 수행하는 것을 말한다. 따라서 인터럽트를 처리하기 위해서는 커널이 실행되도록 CPU를 할당한 뒤, 커널에 존재하는 인터럽트 처리 코드의 시작 주소를 찾아야 한다. 이 주소는 인터럽트 벡터에 저장되어 있다.
4. 인터럽트 처리 루틴의 주소로 이동하여 처리 루틴을 수행한다. 
5. 인터럽트 처리 루틴이 모두 실행되면, 일시 정지된 프로세스의 상태를 복원한다. 
	- 인터럽트 처리가 끝나면, PCB에 저장된 프로세스 A의 다음 실행 주소를 불러온 뒤, 코드의 나머지 부분을 수행한다.


## 인터럽트 처리 중 또 다른 인터럽트가 발생한다면??
원칙적으로 인터럽트 처리 중에 또 다른 인터럽트가 발생하는 것은 허용하지 않는다. 
이는 데이터의 일관성을 유지하기 위함이다. 
만약 인터럽트가 발생해서 운영체제 커널에 정의된 데이터를 변경하고 있는 상황에 또 다른 인터럽트가 발생하여 같은 데이터를 수정하게 된다면, 데이터가 원래 의도하지 않았던 값으로 변경될 수 있다. 

그러나, 예외가 존재할 필요성도 있다.
예를 들어 현재 인터럽트 처리 루틴보다 우선순위가 높은 인터럽트가 발생하는 경우이다. 
이 때는 현재 처리 중이던 인터럽트 코드의 수행 지점을 커널 스택에 저장한 뒤, 우선적으로 처리할 인터럽트를 처리하고, 이전에 실행중이던 인터럽트 코드 부분으로 되돌아와 남은 부분을 처리하게 된다.

## 인터럽트와 이중모드 
이중모드는 커널이 스스로를 보호하기 위한 기법으로 사용자 모드와 커널 모드로 나누어 작업을 수행하는 것을 말한다. 
사용자 모드는 사용자 프로세스가 실행되는 상태를 말하고, 커널 모드는 운영체제와 관련된 커널 프로세스가 실행되는 상태를 말한다. 

사용자 모드에서는 입출력 같은 특권 명령을 수행하지 못한다. 그렇기에 커널이 제공하는 시스템 호출을 통해서 커널 모드로 전환된 후 커널이 특권 명령을 수행하게 된다. 

중요한 연산을 운영체제만이 수행할 수 있도록 정의하더라도 사용자 프로그램이 프로그램 내에서 그런 종류의 연산을 수행해버리면 제어가 아무런 소용이 없게 된다. 사용자 프로글매이 CPU를 가지고 있는 동안에는 운영체제가 자신의 코드를 실ㄹ행하지 못하므로 사용자 프로그램을 감시할 방법이 없기 때문이다.그러므로 이러한 상황을 방지하기 위해서 컴퓨터 시스템은 CPU 내부에 mode bit를 두어 사용자 프로그램을 감시하게 된다. 
mode bit가 0으로 세팅되어 있으면 커널모드로서 모든 명령을 수행할 수 있고, 모드비트가 1로 세팅되어 있으면 사용자모드로서 제한된 명령만을 수행할 수 있다. CPU는 보안과 관련된 명령을 수행하기 전에는 항상 모드비트를 조사해 그 값이 0으로 세팅된 경우에만 그 명령을 수행한다. 그리고 운영체제가 CPU를 점유해 자신의 코드를 수행하다가 사용자 프로그램에게 CPU의 제어권을 넘길 때 모드비트를 1로 세팅해 넘기게 된다.
사용자 프로그램이 수행되다가 하드웨어 접근 등 명령을 수행해야 할 경우네느 시스템 콜을 통해 운영체제가 대신해줄 것을 요청한다. 그러면 CPU의 제어권은 다시 운영체제로 넘어가게 되며 인터럽트가 발생할 때 mode bit는 자동으로 0이 세팅되게 된다. 
정리하자면 아래와 같은 동작 과정을 거치게 된다. 

mode bit가 1인 상태로 사용자 프로그램이 실행되고 있다가 입출력과 같은 특권 명령을 수행해야 하는 상황이 오면 바로 OS의 주소로 점프를 할 수 없다. 그래서 프로그램이 직접 인터럽트 라인을 세팅 한 후 , CPU에게 인터럽트를 보내게 된다. (시스템 호출)
그러면 운영체제가 CPU를 할당받고 인터럽트 벡터의 특정 위치를 통해 해당 인터럽트 처리루틴으로 이동할텐데 이때 인터럽트 하드웨어에 의해 mode bit가 0으로 세팅되어 운영체제는 입출력을 수행할 수 있게 된다. 또한, 운영체제는 입출력 요청이 올바른 요청인지 확인한 후 입출력을 실행하기 때문에 파일에 대한 보안을 유지할 수 있다. 
요청된 입출력이 완료되면 CPU의 제어권을 다시 사용자 프로그램에게 넘길 수 잇게 되며, 사용자 프로그램이 다시 CPU를 할당받으면 시스템 콜 이후의 명령을 수행할 수 있게 된다. 

### 이중 모드 사용하는 이유 
우리가 흔히 사용하는 운영체제는 여러 프로그램이 동시에 실행될 수 있는 멀티 프로그래밍 환경에서 동작한다. 
그러므로 각 프로그램이 다른 프로그램의 실행을 방해하거나 프로그램 간에 충돌을 일으키는 문제를 막기 위해 하드웨어에 대한 각종 보안 기법이 필요하다. 
즉 ,하드웨어적 보안을 유지하기 위해서 운영체제는 기본적으로 이중 모드를 지원한다.

예를 들어 어떤 프로그램이 이상한 명령을 수행시켜 다른 프로그램의 메모리 영역이나 파일 영역을 침법하는 경우가 발생할 수 있다. 따라서 중요한 정보에 접근해 위험한 상황을 초래할 수 있는 연산은 커널모드에서만 실행되도록 하여 일반 사용자 프로그램이 직접 위험한 명령을 수행할 수 없도록 하는 것이다. 



## DMA 컨트롤러
원칙적으로 메모리는 CPU에 의해서만 접근할 수 있는 장치이다. CPU 외의 장치가 메모리의 데이터에 접근하기 위해서는 CPU에게 인터럽트를 발생시켜 CPU가 대신 컨트롤러의 로컬 버퍼와 메모리 사이에서 데이터를 옮겨 준다. 하지만 작업 처리 속도가 매우 빠른 CPU가 인터럽트를 많이 당하면 비효율적일 것이다. 그래서 CPU 이외에 메모리 접근이 가능한 DMA 컨트롤러를 둔다.

DMA를 사용하게 되면 로컬 버퍼에서 메모리로 읽어오는 작업을 CPU가 담당하는 것이 아니라 DMA가 대행함으로써 CPU는 원래 하던 작업을 멈추고 인터럽트를 처리할 필요가 없어지는 것이다. 이때, DMA는 바이트 단위가 아니라 블록이라는 큰 단위로 정보를 메모리로 읽어온 후에 인터럽트를 발생시켜서 작업 완료 신호를 CPU에게 보낸다.

이러한 방식으로 CPU에ㅐ 발생하는 인터럽트의 빈도를 줄여 CPU를 효율적으로 이용할 수 있다. 
다만, CPU가 DMA가 동시에 메인 메모리에 접근할 수 있다는 문제점이 있어서 누가 메모리에 먼저 접근하게 만들지 Memory Controller가 교통 정리하는 역할을 한다.

### 메모리 매핑 출력 
메모리의 일정 공간을 입출력에 할당하는 기법을 메모리 매핑 입출력이라고 한다. 

DMA로 인해 메모리에는 CPU가 사용하는 데이터와 입출력 장치가 사용하는 데이터가 혼재될 수 있다. 이로 인해 메모리 관리가 어려워질 수 있어 CPU가 직접 사용하는 메모리 공간과 DMA을 통해 들어오거나 나가는 공간을 분리한다.

### 사이클 훔치기 
CPU와 DMA Controller가 동시에 메모리에 접근했을 때 CPU가 메모리 사용권한을 양보하는 데 이를 사이클 훔치기라고 한다. 
즉, CPU가 가지는 제어권(사이클)을 DMA가 할당받아 업무를 수행하고, 그동안 CPU는 메모리로의 접근을 할 수 없다.


