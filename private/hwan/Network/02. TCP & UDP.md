## 전송 계층 
송신자와 수진자를 연결하는 통신 서비스를 제공하는 계층으로, 데이터의 전달을 담당한다.  해당 계층에서 IP에 의해 전달되는 패킷의 오류를 검사하고 재전송 요구 등의 제어를 담당하게 된다. 
추가적으로 설명하자면, 두 응용 계층 사이에서의 process-to-process 통신을 제공하며 응용 계층으로부터 메시지를 받아 전송계층 패킷으로 캡슐화하여 전송한다. 이를 세그먼트 또는 데이터그램이라고 부른다.
전송 계층에서 데이터를 전달하기 위해 사용하는 프로토콜이 바로 TCP와 UDP이다.
![](https://i.imgur.com/gVQYcAA.png)


## TCP 
> 연결형, 신뢰성 전송 프로토콜 

![](https://i.imgur.com/6rogTBF.png)
[출처](https://www.inflearn.com/course/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%A0%84%EA%B3%B5%EB%A9%B4%EC%A0%91-cs-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B5/dashboard)
연결지향적 서비스를 제공하기 위해 데이터를 전송하기 전에 먼저 두 호스트의 전송 계층 사이에 논리적 연결을 설립한다. 그 후 데이터 전송을 하고 데이터 전송을 완료했으면 연결을 해제한다. 
TCP 통신은 크게 connection setup, data transfer, connection terminate의 세 단계로 나뉜다. 
신뢰성 있는 서비스를 제공하기 위해 TCP가 전체 스트림을 순서에 맞고 요류 없이, 또한 부분적인 손실이나 중복 없이 전송하는 것을 보장한다. 이를 가능하게 하는 방법으로 오류제어, 흐름제어, 혼잡제어 등이 있다. 

### 3way-handshake
![](https://i.imgur.com/rN4ofsv.png)

TCP/IP 프로토콜로 통신하기 전, 정확한 정보 전송을 위해 상대방 컴퓨터와 세션을 수립하는 과정이다.
간단하게 설명하자면 클라이언트가 서버에게 접속을 요청하는 SYN 패킷을 보내면, 서버는 요청을 수락하는 ACK를 포함하여 SYN+ACK 패킷을 클라이언트에게 발송한다. 클라이언트가 이를 수신한 후, 다시 ACKJ를 서버에게 발송하면 연결이 이루어지게 되고, 이로써 데이터를 주고받을 수 있게 된다. 


#### TCP Flags
> SYN : 연결 요청 
> ACK : 확인 응답 

TCP 헤더의 TCP Flags는 6비트로 이루어져 있으며 URG, ACK, PSH, RST, SYN, FIN으로 이루어져있다. 해당 필드들이 1로 활성화되면서 연결을 확립시키는 것이다. 
3way-handshake로 설명하자면 클라이언트가 SYN필드를 1로 표기해 패킷을 전송한다. 이후 서버는 ACK와 SYN 필드를 1로 표기해 응답한다. 마지막으로 클라이언트는 ACK필드를 1로 표기해 전달하게 되는 것이다.


#### 패킷 순서, 응답 번호
> 시퀀스 번호(일련 번호) : 송신 측에서 수신 측에 이 데이터가 몇 번째 데이터인지 알려 주는 역할, 수신자는 원래 데이터의 몇 번째 데이터를 받았는 지 알 수 있다.
> 
> 응답 번호 (확인 응답 번호) : 수신 측이 몇 번째 데이터를 수신했는 지 송신 측에 알려주는 역할, 해당 번호는 다음 번호의 데이터를 요청하는 데도 사용한다.

TCP는 분할된 패킷을 수신측이 잘 조합하도록 패킷에 순서를 주고 응답 번호를 부여한다. 패킷의 순서를 시퀀스 번호, 응답 번호를 부여하는 것을 ACK라고 한다. TCP 그림에서도 볼 수 있듯이 패킷 순서가 순서대로 오지 않으면 TCP에서 Hold했다가 순서에 맞게 수신하면 그때 애플리케이션에 전송하게 된다. (패킷 3이 패킷2보다 먼저 수신되었을 경우 데패킷 2는 홀드하고 있다가 패킷 3가 수신되었을 때 전송하게 됨)

![](https://i.imgur.com/3UbMzNp.png)

![](https://i.imgur.com/cjwHLFn.png)
데이터를 전송하기 전 단계에서 3-way-handshake으로 연결수립이 이루어질 때, 이번 통신에 사용하는 일련번호인 3001번과 응답 번호인 4001번이 결정된다.
1. 송신측은 수신측으로 200바이트의 데이터를 전송한다. 
2. 수신측은 200바이트를 수신하고 다음에 수신하고자 하는 데이터 번호를 응답 번호에 넣는다. 다음에 수신하고자 하는 데이터는 3001 + 200 = 3201로 3201번부터 보내 달라고 요청한다. 
3. 송신측은 수신측으로 3201번부터 200바이트의 데이터를 전송한다. 
4. 수신측은 200바이트를 수신하고 다음에 수신하고자 하는 데이터의 번호를 응답 번호에 넣는다.
이러한 일련 번호와 응답 번호를 사용해서 데이터가 손상되거나 유실된 경우에 데이터를 재전송할 수 있다.


#### 시퀀스 번호가 난수?
사실 처음 클라이언트에서 SYN 패킷을 보낼 때 Sequence Number에는 랜덤한 숫자가 담겨진다. 초기 sequence number를 ISN이라고 한다.
ISN이 0부터 시작하지 않고 난수를 생성해서 number를 설정하는 이유는 무엇인가?
Connection을 맺을 때 사용하는 포트(port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다.
따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다.
서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 number가 전송된다면 이전의 connection으로부터 오는 패킷으로 인식할 수 있다. 이러한 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정하는 것이다.


### 윈도우 사이즈 
세그먼틀 하나를 보낼 때마다 확인 응답을 한 번 반화하는 통신은 통신을 한 번 보낼때마다 한 번 응답을 반환하는 방식이기 때문에 효율이 좋지 못하다. 
하지만 매번 확인 응답을 기다리는 대신 세그먼트를 연속해서 보내고 난 다음에 확인 응답을 반환하면 효율이 높아지게 된다. 
상대방이 세그먼트를 받기 위해서 받은 세그먼트를 일시적으로 보관하는 장소인 버퍼가 있다. 버퍼 덕분에 세그먼트를 연속해서 보내도 수신 측은 대응할 수 있고 확인 응답 효율도 높아지게 된다. 
하지만 수신 측은 대량으로 데이터가 전송되면 보관하지 못하고 넘쳐 버리는 오버플로가 발생할 수 있다. 이를 방지하기 위해 버퍼의 한계 크기를 알고 있어야 하며 이는 TCP 헤더의 윈도우 크기에 해당한다. 
즉, 윈도우 크기는 얼마나 많은 용량의 데이터를 저장해 둘 수 있는 지 나타내는 값으로 확인 응답을 일일이 하지 않고 연속해서 송수신할 수 있는 데이터 크기이다.
이 윈도우 크기의 초깃값은 3-way-handshake를 할 때 판단한다.

![](https://i.imgur.com/NH5eQ4I.png)
송신 측의 한 계값이 3000바이트이고 수신측의 한계값이 2000바이트일 시 위와 같은 방식으로 서로의 윈도우 크기를 확인한다. 
이를 통해 확인 응답을 기다리지 않고 세그먼트를 연속해서 보낼 수 있게 된다. (첫번째 세그먼트를 보내고 확인 응답을 받기도 전에 두번째 세그먼트를 보낼 수 있다.)

### 정리하자면 
1. SYN 단계 : 송신측은 수신측에 송신측의 ISN을 담아 SYN을 보낸다. ISN은 새로운 TCP 연결의 첫 번째 패킷에 할당된 임의의 시퀀스 번호를 말한다. 
2. SYN + ACK 단계 : 수신측은 송신측의 SYN를 수신하고 수신측의 ISN을 보내며 승인 번호로 수신측의 ISN + 1을 보낸다. 
3. ACK 단계 : 송신측은 수신측의 ISN+1한 값인 승인번호를 담아 ACK를 수신측에 보낸다.
이후 통신할 때 만약 1,2 패킷을 수신측에 보냈을 경우 수신측에서는 3번에 해당하는 ACK를 송신측에 보내게 된다. 이때 송신측은 3번에 해당하는 ACK를 받기 위해 wait하고 있는 상태이다. 이 wait때문에 속도 지연이 일어나게 되고 이때문에 UDP보다 느려지게 되는 것이다.
또한, 수신측의 윈도우 사이즈가 세그먼트의 크기보다 작을 경우 보내게 되지만 클 경우에도 wait가 발생하게 된다. 그렇기 때문에 수신측의 버퍼에서는 빠르게 I/O 버퍼에 옮겨야 하므로 읽는 속도가 빨라야 한다. 읽는 속도가 수신 속도보다 느려지게 되면 점점 TCP 버퍼가 줄어들게 되어 장애가 발생할 수 있다. (이때는 네트워크에서 장애를 찾는 것이 아닌 애플리케이션 단에서 찾아야한다. 읽기 속도를 향상시켜야 한다.)


### 오류제어 
ARQ(Automatic Repeat Request) 즉, 재전송 기반 오류 제어 기법을 사용해 프레임이 손상되었거나 손실되었을 경우 재전송을 통해 오류를 복구한다. 
- Stop and Wait ARQ 
	- 송신측에서 패킷을 전송하고 ACK를 받을 경우 재전송하는 기법이다. 
	- 데이터나 ACK를 유실했을 경우 타임 아웃이 발생해 재전송된다. 
- Go-Back-n ARQ 
	- 전송된 프레임이 손실되거나 유실되어 타임아웃이 발생한 경우 마지막으로 확인된 패킷 이후의 전체 패킷을 재전송한다. 
- Selective-Reject ARQ 
	- 손실되거나 유실된 프레임만 재전송하는 기법 
	- 버퍼의 데이터가 순차적이지않아 프레임의 재정렬을 수행해야하므로 별도의 버퍼가 빌표하다.


### 흐름제어 
> TCP 버퍼 
> 송신 측은 버퍼에 TCP 세그먼트를 보관한 후 순차적으로 전송하고, 수신 측은 도착한 TCP 세그먼트를 애플리케이션이 읽을 때까지 버퍼에 보관한다.

수신 측이 송신 측보다 데이터 처리 속도가 빠르면 문제가 없지만, 송신 측의 속도가 빠를 경우 문제가 생긴다. 수신 측에서 제한된 저장 용량을 초과한 이후에도 도착하는 패킷은 손실될 수 있으며, 만약 손실된다면 불필요한 추가 패킷 전송이 발생하게 된다. 
즉, 흐름 제어는 위와 같이 송신 측과 수신 측의 TCP 버퍼 크기 차이로 인해 생기는 데이터 처리 속도 차이를 해결하기 위한 기법이다.

#### 1. Stop and Wait
매번 전송한 패킷에 대해 확인 응답 즉, ACK를 받으면 다음 패킷을 전송하는 방법이다. 그러나 패킷을 하나씩 보내기 때문에 비효율적인 방법이다. 

#### 2. Sliding Window 
수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답 즉, ACK없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법이다.
먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송한다.
- 재전송 
	- 송신 측은 일정 시간 동안 수신 측으로부터 확인 응답(ACK)를 받지 못하면, 패킷을 재전송한다. 만약, 송신 측에서 재전송을 했는데 패킷이 소실된 경우가 아니라 수신 측의 버퍼에 남는 공간이 없는 경우면 문제가 생긴다. 이를 해결하기 위해 송신 측은 해결 응답(ACK)을 보내면서 남은 버퍼의 크기 즉, 윈도우의 크기도 함께 보내 준다.


### 혼잡제어 
네트워크 혼잡시에 제어
- AIMD(Additive Increse/Multicative Decrease) - 합 증가/곱 감소 방식 
	- 처음에 패킷을 하나씩 보내고 문제 없이 도착하면 윈도우의 크기를 1씩 증가시키는 방식 
	- 만약 전송에 실패하면 윈도우 크기를 반으로 줄인다. 
	- 윈도우 크기를 너무 조금씩 늘리기 때문에 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 오래 걸린다는 단점이 있다.
- Slow Start - 느린 시작 
	- AIMD와 다르게 윈도우의 크기를 1, 2, 4, 8 .. 과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식 
	- 이때 윈도우 사이즈를 Threshold로 기억하고 다시 윈도우를 증가시키다가 Threshold의 절반 크기가 된 경우 윈도우 사이즈를 1씩 증가시킨다.
	- 보낸 데이터의 ACK가 도착할 때마다 윈도우 크기를 증가시키기 때문에 처음에는 윈도우 크기가 조금 느리게 증가할지라도, 시간이 가면 갈수록 윈도우 크기가 점점 빠르게 증가한다는 장점이 있다.
- Fast Retransmit - 빠른 재전송 
	- 패킷을 받는 수신자 입장에서는 세그먼트로 분할된 내용들이 순서대로 도착하지 않는 경우가 생길 수 있다. 
	- 이런 상황이 발생했을 때 수신 측에서는 순서대로 잘 도착한 마지막 패킷의 다음 순번은 ACK 패킷에 실어서 보낸다. 이런 중복 ACK를 3개 받으면 재전송이 이루어진다. 
	- 송신 측은 자신이 설정한 타임 아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 재전송률을 유지할 수 있다.
- Fast Recovery - 빠른 회복 
	- 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 바능로 줄이고 선형 증가시키는 방법이다. 
	- 이 방법을 적용하면 혼잡 상황을 한 번 겪고나서부터는 AIMD 방식으로 동작한다.



### 4way-handshake
TCP는 세션을 안전하게 종료하기 위한 4개의 패킷을 교환한다. (위에서 설명한 과정 중 Connection termination 과정)
TCP는 양방향으로 2개의 연결이 독립적으로 닫히기 때문에 4-way 단계를 밟게 된다.
![](https://i.imgur.com/ySjttWh.png)
1. 클라이언트 프로세스에서 active close를 하면, clinect tcp에서 FIN 세그먼트를 보낸다.
2. 서버는 FIN 세그먼트를 받았다는 응답에 대한 ACK를 클라이언트로 보낸다. 이때, 서버내의 프로세스에게 EOF를 보내지만, 아직 프로세스는 close되지 않을 수 있다. 
3. 서버 프로세스로 부터 passive close를 받으면 서버 tcp에서 FIN 세그먼트를 클라이언트 TCP에게 보낸다. 
4. 서버 TCP가 ACK를 받게 되면 연결이 종료된다.


#### 클라이언트는 TIME WAIT 상태가 되어 어느 정도의 시간을 대기한 후 연결을 닫게 되는 이유
첫 번째로는 지연 패킷이 발생할 경우를 대비하기 위함이다. 패킷이 뒤늦게 도달하고 이를 처리하지 못한다면 데이터 무결성 문제가 발생하게 된다. 
두 번째로는 두 장치가 연결이 닫혔는지 확인하기 위해서이다. 만약 LAST_ACK 상태에서 닫히게 된다면 다시 새로운 연결을 하려고 할 때 장치는 줄곧 LAST_ACK로 되어 있기 때문에 접속 오류가 나타나게 될 것이다. 
이러한 이유때문에 TIME_WAIT라는 잠시 기다릴 시간이 필요하다.



## UDP 
> 비연결형, 비신뢰성 전송 프로토콜 

![](https://i.imgur.com/0DhozD9.png)
[출처](https://www.inflearn.com/course/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%A0%84%EA%B3%B5%EB%A9%B4%EC%A0%91-cs-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B5/dashboard)

논리적 연결을 성립하지 않고 데이터그램을 전송하는 비연결형 프로토콜이다. 또한 흐름제어, 오류제어, 혼잡제어를 제공하지 않는 간단한 프로토콜이다. 
이러한 단순성은 적응 양의 오버헤드를 갖기 때문에 작은 메시지를 보내거나 신뢰성을 크게 고려하지 않아도 되는 상황에서 사용한다.
추가적으로, TCP와 다르게 데이터를 쪼개주지 않기 때문에 애플리케이션 단에서 패킷을 쪼개야 한다.

UDP는 실시간 스트리밍과 같이 시간에 민감한 애플리케이션(실시간 상호작용을 하는 애플리케이션)에 사용된다. 보통 음성이나 동영상과 같은 데이터를 전송할 때 사용된다. 만약 전송계층에서 훼손되거나 손실된 프레임을 재전송 해야 된다면 전체적으로 지연이 일어날 것이다. 그렇기 때문에 UDP를 통해 한프레임씩 데이터그램으로 전송한다면 훼손되거나 손실된 패킷은 그냥 무시하고 나머지 패킷을 애플리케이션에 전송하게 된다. 손실된 패킷으로 인해 짧은 시간동안 화면의 일부분이 공백으로 표시되더라도 대부분의 시청자들은 인식하지 못한다. 즉, 신뢰성보다 실시간성이 더 중요하기 때문에 UDP를 사용한다. 

> 넷플릭스처럼 시간에 민감하지 않는 단일 시청자를 위한 연결을 TCP를 사용한다. 원활한 시청을 위해 미리 데이터를 받아 놓고 네트워크에 문제가 생기더라도 동영상이 끊기지 않도록 캐시에 저장한다. 
> [참고링크](https://victoria-k.tistory.com/entry/%EC%99%9C-%EB%84%B7%ED%94%8C%EB%A6%AD%EC%8A%A4%EB%8A%94-%EB%B9%84%EB%94%94%EC%98%A4-%EC%8A%A4%ED%8A%B8%EB%A6%AC%EB%B0%8D%EC%97%90-UDP-%EB%8C%80%EC%8B%A0-TCP%EB%A5%BC-%EC%93%B0%EB%8A%94%EA%B0%80)


## 패킷으로 나누는 이유?
### 장점 
1. 네트워크 리소스 점유 시간이 적어진다. 
2. 클라이언트에서 서버로 이동하는 경로가 고정되어 있는 것이 아니기 때문에 경로상에 장애가 발생한다 해도 다른 경로를 통해 전송할 수 있게 된다. (안정성이 높다.)
3. 나누어진 패킷은 순서가 매겨지기에 중간에 유실된 패킷에 대한 재요청이 가능하며 전체 내용을 재전송하지 않아도 된다.

### 단점 
모든 패킷에 대한 3-way-handshake 즉, 확인과정이 추가되는 것과 헤더가 붙어야하는 등 오버헤드가 발생할 수 있다.


## IP란? 
인터넷 프로토콜의 약자로, 송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 정보 위주의 규약이며, OSI 네트워크 계층에서 호스트의 주소 지정과 패킷 분할 및 조립 기능을 담당한다. 

### 특징 
- 비신뢰성
	- 흐름에 관여하지 않기 때문에 보낸 정보가 제대로 갔는지 보장하지 않는다. 
	- 때문에 패킷 전송과 정확한 순서를 보장하기 위해 TCP 프로토콜과 같은 IP의 상우 ㅣ프로토콜을 이용해야 한다.
- 비연결성

## IP 주소 
네트워크 환경에서 컴퓨터(노드) 간 통신하기 위해 각 컴퓨터에 부여된 네트워크 상 주소이다.
-   사용자가 변경이 가능한 주소이다.
-   주소에 레벨이 있다. 그룹을 의미하는 네트워크 주소와 호스트 주소로 나뉜다.

### IP 주소 형식 

#### IPv4 주소 
![](https://i.imgur.com/T1Np66P.png)

IP 주소는 보통 4개의 10진수로 이루어진 IPv4 체계를 택하고 있는데, 각 10진수는 8자의 2진수로 변환되며, 총32개의 0과 1로 이루어져 있다. 즉, 0.0.0.0부터 255.255.255.255까지 약 42억개의 주소를 표현할 수 있다. 

#### IPv6주소 
![](https://i.imgur.com/BIGWdDU.png)

IP주소라는 개념이 처음 생겼을 당시에는 지금처럼 네트워킹이 가능한 장비의 종류가 다양하지 않았지만, 기술이 발전하고 단말기가 증가하면서 IPv4주소의 수가 부족했다. 이를 해결하고자 주소 길이를 128비트로 늘려 사용 가능한 주소의 개수를 2^128로 늘린 IPv6주소가 등장했다. 
보통 두 자리 16진수 여덟 개를 쓰며 각각 :기호로 구분한다.
Base Header와 Extension Header를 분리함으로써 라우터간 전송 과정에서 불필요한 과정을 줄여 전송 효율을 높였다.

![](https://i.imgur.com/HlFa13u.png)


### IP주소의 클래스
> 네트워크 주소: 호스트들을 모은 네트워크를 지징하는 주소이다. 네트워크 주소가 동일한 네트워크를 로컬 네트워크라 한다.
> 호스트 주소: 하나의 네트워크 내에 존재하는 호스트를 구분하기 위한 주소이다.

IP주소에는 클래스라는 개념이 있고 클래스는 하나의 IP주소에서 네트워크 주소와 호스트 주소를 나누는 방법이자 약속이다. 
IP 주소를 여러 클래스로 나누는 이유는 네트워크 크기에 따라 구분하기 위해서다. 네트워크 범위가 커질수록 호스트 주소 범위는 작아지는 반비례 관계이기 때문이다.
![](https://i.imgur.com/m0FxwKJ.png)
-   A클래스: 네트워크 주소 1옥텟 + 호스트 주소 3옥텟
-   B클래스: 네트워크 주소 2옥텟 + 호스트 주소 2옥텟
-   C클래스: 네트워크 주소 3옥텟 + 호스트 주소 1옥텟

### 서브 네팅 
네트워크 -  호스트 구분 기준을 사용자가 정해, 원래 클래스 단위의 네트워크보다 더 쪼개 사용하는 것을 뜻한다. 
부여된 주소를 다시 잘라 사용하는 것을 뜻하며, 클래스리스 네트워크의 가장 큰 특징이다.

### 서브넷 마스크 
IP 주소와 네트워크 주소를 구분할 때 사용하는 구분자이다. 2진수 숫자 1(255)은 네트워크 주소, 0은 호스트 주소로 표시한다. 
![](https://i.imgur.com/pDNvaiU.png)

IP주소를 서브넷 마스크와 &연산하면 네트워크 주소를 확인할 수 있다. 
![](https://i.imgur.com/5e6YFom.png)





### IP주소 분류 
#### 사용 범위 
- 공인 IP 
	- 공인 기관에서 할당한 IP 주소 
	- 통신에서 쓰이는 실제 주소이자 공개된 주소로 누구라도 주소를 토대로 연결된 기기에 접근이 가능하다.
- 사설 IP 
	- 개인적인 네트워크를 구성할 때 사용한다.
	- 공유기를 통해 인터넷에 접속하게 되면 사설 IP 주소가 부여된다. 
	- 공유기는 엄밀히 말하면 공인 IP와 사설 IP 모두 가지고 있으며, 외부에서는 공인 IP를 사용하고 내부에서는 사설 IP를 사용한다. 
	- NAT 기능을 사용해서 사설 IP를 공인 IP로 바꿀 수 있다.

#### 할당 방식 
- 고정 IP
- 유동 IP
사설 IP의 경우 컴퓨터가 네트워크에 접속할 때마다 서버에 IP주소 할당을 요청하고, 서버는 IP주소등의 네트워크 정보를 다시 전달해 최종적으로 컴퓨터가 IP주소를 등록하는 과정을 거친다. 즉, 네트워크에 접속할 때마다 IP 주소가 변경될 수 있다.


