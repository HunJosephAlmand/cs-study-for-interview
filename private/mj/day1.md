# 1일차

# 객체지향

---

객체지향이란 컴퓨터 프로그래밍 패러다임 중 하나로, **프로그래밍에서 필요한 기능을 추상화**시켜 **상태와 행위를 가진 객체**를 만들고 객체들 간의 메세지를 통해 프로그램을 작성하는 프로그래밍 기법.

## 4가지 특징

1. 추상화 : 필요로 하는 속성이나 행동을 추출하는 작업
2. 캡슐화 : 낮은 결합도를 유지할 수 있도록 설계하는것
3. 상속성 : 여러 개체들이 지닌 공통된 특성을 묶어 하나의 개념이나 법칙으로 성립시키는 과정
4. 다형성 : 서로 다른 클래스의 객체가 같은 메세지를 받았을 때 각자의 방식으로 동작하는 능력(오버라이딩 오버로딩)

## SOLID 원칙

S 단일책임 : 원칙클래스는 단 한개의 책임을 가져야한다.

O 개방 폐쇄 : 확장에는 열려있고 변경에는 닫혀있어야 한다

L 리스코프 치환 : 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야한다.

I 인터페이스 분리 : 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

D 의존 역전 : 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 

## 객체지향 vs 절차지향 vs 함수형 프로그래밍

### 객체지향, 절차지향 (무엇을 어떻게에서 어떻게가 더 중요)

절차지향 프로그래밍은 프로그램이 수행해야할 기능을 중심으로 바라보아 “기능을 어떤 절차로 수행해야 하는가”를 중점적으로 생각해야하는 프로그래밍 기법입니다. 

반면에 객체 지향은 객체가 중심이 되어 “누가 어떤 일을 할 것인가”가 핵심이 됩니다. 즉 프로그램이 수행해야 할 일에 대해 알맞는 객체를 도출하고 각각의 역할을 정의해 나가는 것에 초점을 맞춥니다. 

### 함수형 프로그래밍(무엇을 어떻게에서 무엇을이 더 중요)

모든 것을 부수 효과가 없는 순수 함수로 나누어 문제를 해결하는 기법으로, 작은 문제를 해결하기 위한 함수들을 작성하고 함수의 조합을 통해 프로그램을 작성하는 기법

# JDK, JRE, JVM

---

JDK : Java Development Kit의 약자로 자바 프로그램 개발을 위한 키트를 의미하며 컴파일러, JRE 등의 도구를 가지고 있다.

JRE : 자바 런타임 환경으로 자바 프로그래밍을 실행하기 위한 도구들을 의미한다. 자바 클래스 라이브러리, JVM, 자바 클래스 로더를 포함한다.

JVM : 자바 프로그램이 실행되는 가상 머신. 운영체제 위에서 동작하기 때문에 자바 코드 자체는 플랫폼에 종속되지 않음. 인터프리터, jit 컴파일러, 클래스로더, 가비지 콜렉터를 포함.

![image](https://user-images.githubusercontent.com/65841596/186297638-78039941-ed2a-42e3-bb23-c57c1226c2fd.png)

## 컴파일 과정

1. java 파일 작성
2. 자바 컴파일러가 바이트코드로 컴파일 (.java → .class)
3. 컴파일된 바이트코드를 JVM의 클래스로더에 전달
4. 클래스로더는 동적로딩을 통해 필요한 클래스들을 로딩 및 링크하여 JVM 메모리에 올림
5. 실행 엔진은 JVM 메모리에 올라온 바이트 코드들을 JIT 컴파일러, 인터프리터를 이용해 실행

## 컴파일 언어 vs 인터프리터 언어

컴파일러 언어 : 코드 실행 전 컴파일 타임에 소스 코드 전체를 한번에 기계어로 변환 후 실행. 한번 컴파일 된 이후론 실행만 수행하면 되기 때문에 실행 속도가 빠름

인터프리터 언어 : 코드 실행 시점에 코드를 한 줄씩 변환 후 실행. 실행 마다 인터프리팅 과정을 반복하기 때문에 실행 속도가 느림

## JVM 메모리 구조

![image](https://user-images.githubusercontent.com/65841596/186297705-4b180d7f-aaa1-4168-8f76-221afcbbc394.png)

1. Method Area : 모든 쓰레드가 공유하는 메모리 영역. 클래스, 인터페이스, 메소드, 필드, static 변수등의 바이트 코드를 보관
2. Heap Area : 모든 쓰레드 공유 가능 new 키워드로 생성된 객체와 배열이 할당되는 영역. 가비지 컬렉터의 청소 대상
3. Stack Area : 메서드 호출 시마다 각각의 스택 프레임이 생성되는데, 메서드 안에서 사용된 값을을 저장 하고 호출된 메서드의 매개변수 지역변수 리턴 값 및 연산시 일어나는 값들을 임시 저장하는 영역. 메소드 호출이 끝나면 프레임별로 삭제
4. PC Register : 쓰레드에 대한 정보를 저장하는 영역. 생성된 쓰레드가 어떤 명령을 처리하고 있는지 저장
5. Native Method Stack : java가 아닌 다른 언어로 구성된 메소드를 실행할 때 사용되는 공간

## 가비지 콜렉터 동작 과정

![image](https://user-images.githubusercontent.com/65841596/186297854-a4a52e07-c485-4b8f-91d6-aa9672486a0c.png)

힙 영역은 Eden과 Survivor로 구성된 Young generation과, old generation으로 구분

가비지 컬렉션은 두 가지 단계로 실행

1. stop the word : 실행중인 모든 스레드의 작업을 일시 중지
2. mark and sweep : 참조가 헤제된 객체들을 찾아내어 메모리에서 제거

### **Minor GC가 일어나는 과정**

1. 새롭게 생성된 객체는 Eden 영역에 할당된다.
2. 객체가 계속 새로 생성되어 Eden 영역이 꽉 차게 되면 **Minor GC**가 실행된다.참조되지 않는 객체의 메모리 할당을 해제하고 참조되고 있는 객체는 Survivor 영역으로 이동한다.
3. 1~2번 과정이 반복되다가 Survivor 영역이 꽉차게 되면 Survivor 영역의 살아남은 객체를 다른 Survivor 영역으로 이동시킨다.(1개의 Survivor 영역은 반드시 빈 상태여야 한다. 만약 두 Survivor 영역에 모두 데이터가 존재하거나, 두 영역 모두 사용량이 0이라면 정상적인 상황이 아니다.)
4. 이러한 과정을 반복해서 계속 살아남은 객체는 Old 영역으로 이동(Promotion)한다.

Survivor 영역에서 다른 Survivor 영역으로 이동할 때마다 **객체의 살아남은 횟수를 나타내는 age의 값을 증가**시킨다.Object Header에 기록하며 age를 보고 Minor GC 때 Old로 이동(Promotion)시킬지를 결정한다.

### **Major GC가 일어나는 과정**

1. Promotion 작업이 계속되다보면 Old Generation이 가득 차게 되면서 **Major GC**가 발생하게 된다.
2. 참조되지 않는 객체는 메모리 할당을 해제한다.

## **Minor GC와 Major GC의 차이점**

Young Generation은 Old Generation보다 크기가 작기 때문에 Minor GC가 일어나는 속도가 빠르다. (대략 0.5초에서 1초) 그렇기 때문에 애플리케이션에 큰 영향을 주지 않는다.

하지만 Old Generation에서의 Major GC는 Minor GC에 비해 10배 이상의 시간이 소요된다.

# 자바8의 큰 특징, 자바 11과의 차이점

자바8 : 람다, 스트림, 인터페이스의 디폴트 메소드, 옵셔널

자바 10 : var 키워드 등장

자바 11 :  람다를 사용할 때 지역변수에 브라켓() 생략 가능

자바 15 : Sealed Class, record 클래스 등장

자바 17 : sealed class 확정, switch문에 객체를 전달하여 instanceof 연산자처럼 사용 가능