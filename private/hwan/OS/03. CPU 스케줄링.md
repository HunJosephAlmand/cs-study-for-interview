## 프로세스를 스케줄링하기 위한 큐 
운영체제는 준비 상태에 있는 프로세스들을 줄 세우기 위한 **준비 큐**를 두고 준비 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당하게 된다. 여기서 준비 큐에 프로세스를 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라진다. 
위와 같은 CPU를 기다리는 프로세스를 줄 세우는 준비 큐 외에도 운영체제는 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 장치 큐를 둔다. 예를 들어 디스크 입출력 서비스를 위한 디스크 입출력 큐가 있다. 디스크 컨트롤러는 디스크 입출력 큐에 줄 서 있는 순서대로 프로세스들의 입출력 작업을 수행하며 프로세스별 입출력 작업이 완료되었을 때 CPU에 인터럽트를 발생시킨다. 그러면 인터럽트 처리루틴에 의해 디스크 입출력이 완료된 프로세스는 입출력 큐에서 빠져나와 CPU를 기다리는 준비 큐에 줄서게 된다. 
이외에도 소프트웨어 자원을 기다리는 경우에도 큐가 필요하다. 여러 프로세스가 공유 데이터에 동시에 접근하려고 할 때 데이터의 일관성을 위해 공유 데이터를 기다리는 큐에 줄 서게 하여 현재 그 데이터를 사용하고 있는 프로세스가 데이터를 반납하기 전까지는 접근하지 못하게 하고, 반납할 경우 큐에 줄 서 있는 순서대로 데이터의 접근 권한을 주는 방식이다. 

이와 같이 프로세스의 상태 관리는 **커널의 주소 영역 중 데이터 영역**에 다양한 큐를 두어 수행하게 된다. 
위에서 말한 큐 외에도 운영체제는 작업 큐를 추가로 유지한다. 작업 큐는 시스템 내의 모든 프로세스를 관리하기 위한 큐로, 프로세스의 상태와 무관하게 현재 시스템내에 있는 모든 프로세스가 작업 큐에 속하게 된다. 그러므로 작업 큐에 있는 프로세스가 모두 메모리를 가지고 있는 것이 아니며, 준비 큐에 속한 프로세스들은 준비 상태에 있고, 장치 큐에 속한 프로세스들은 봉쇄 상태에 있다. 그러므로 프로세스는 상태 변화에 따라 준비 큐와 장치 큐를 오가며 실행되게 된다. 즉, 작업 큐가 가장 넓은 개념이고 준비 큐와 장치 큐에 있는 프로세슫들은 모두 작업 큐에 속해 있다고 본다. 

![](https://i.imgur.com/UDtTAz7.png)
준비 큐와 다양한 장치 큐를 운영체제는 다음과 같은 자료구조로 구현한다. 
장치 큐는 각 자원마다 큐가 하나씩 존재하게 되며, 큐는 각 프로세스의 PCB를 연결 리스트 형태로 관리하고 포인터를 사용해 순서를 결정한다. 

- 작업 큐 
	- 현재 시스템 내에 있는 모든 프로세스의 집합 
	- 즉, 준비 큐 + 장치 큐 
- 준비 큐 
	- 현재 메모리에 있으면서 CPU를 할당받아 실행되기를 기다리는 준비 상태의 프로세스 집합 
- 장치 큐 
	- I/O 디바이스의 처리를 기다리는 봉쇄 상태의 프로세스 집합 ㅂ


## 스케줄러 
스케줄러란 어떤 프로세스에게 자원을 할당할지 결정하는 운영체제 커널의 코드를 지칭하며 3가지 스케줄러가 존재한다. 

### 장기 스케줄러 
작업 스케줄러라고도 부르며, 어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할을 한다. 
프로세스에게 메모리를 할당하는 문제에 관여한다. (준비 큐가 CPU만 얻으면 당장 실행될 수 있는 프로세스의 집합이고, CPU에서 실행되기 위해서는 프로세스가 메모리를 보유해야 하므로) 
시작 상태의 프로세스들 중 어떤 프로세스를 준비 큐에 삽입할 것인지 결정한다.
즉, 메모리에 동시에 올라가 있는 프로세스의 수 (degree of Multiprogramming)을 조절하는 역할을 한다. 
하지만 현대의 시분할 시스템에는 장기 스케줄러가 없다. 과거에는 적은 양의 메모리를 가지고 있어 시스템의 효율때문에 장기 스케줄러가 역할을 다 했지만 지금은 프로세스가 시작 상태가 되면 곧바로 메모리를 할당해 준비 큐에 넣어주게 된다. (대신 중기 스케줄러를 두는 경우가 많다.)


### 단기 스케줄러 
CPU 스케줄러라고도 하며, 준비 상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들 것인지 결정한다. 즉, 준비 큐에 있는 여러 프로세스들 중 어떤 프로세스에게 CPU를 할당할 지 결정하게 된다. 시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.
단기 스케줄러는 밀리초 정도의 시간 단위로 매우 빈번하게 호출되기 때문에 수행 속도가 충분히 빨라야 한다. 


### 중기 스케줄러
너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러이다. 
너무 많은 프로세스가 메모리에 적재되어 프로세스당 보유하고 있는 메모리양이 극도로 적어지게 되면 CPU수행에 당장 필요한 프로세스 주소 공간조차도 메모리에 올려놓기 힘들게 된다. 그렇게 되면 디스크 입출력이 수시로 발생하게 되어 시스템의 성능이 심각하게 저하될 수 있다. 중기 스케줄러는 이런 상황에  메모리에 올라와 있는 프로세스 중 일부를 선정해 이들로부터 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장하는 역할을 하며 이와 같은 행동을 스왑 아웃이라고 부른다. 
즉, 프로세스당 보유 메모리양이 지나치게 적어진 경우 이를 완하시키기 위해 일부 프로세스를 메모리에서 디스크로 스왑 아웃시키는 역할을 한다.
주로 봉쇄 상태에 있는 프로세드들(0순위)을 스왑아웃하고, 그래도 메모리 공간이 부족하면 준비 큐 대기열 후반부에 있는 프로세스들을 스왑 아웃하게 된다. 
장기 스케줄러와 마찬가지로 메모리에 올라와 있는 프로세스의 수를 조절하는 역할을 수행한다.
이런 중기 스케줄러 등장으로 프로세스의 상태에는 실행, 준비, 봉쇄 외에도 중지 상태가 추가된다. 
- 중지 준비 상태 
	- 준비 상태에 있던 프로세스가 중기 스케줄러에 의해 디스크로 스왑 아웃된 경우 
- 중지 봉쇄 상태 
	- 봉쇄 상태에 있던 프로세스가 중기 스케줄러에 의해 스왑 아웃된 경우 
	- 프로세스가 봉쇄되었던 조건을 만족하면 중지 준비 상태로 바뀐다.



## CPU 스케줄링
![](https://i.imgur.com/wXayfjr.png)

### CPU 버스트(burst)
사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 단계이며 사용자 프로그램은 CPU 내에서 일어나는 명령(add 등)이나 메모리에 접근하는 일반 명령(Store, Load)를 사용한다. 

### I/O 버스트 
I/O버스트는 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계이다. 이 단계에서는 모든
입출력 명령을 특권 명령으로 규정하여 사용자 프로그램이 직접 수행할 수 없도록 하고, 대신 운영체제를 통해 서비스를 대행하도록 한다. 
이처럼 사용자 프로그램이 수행되는 과정은 CPU 작업과 I/O작업의 반복으로 구성된다. 
즉, 프로세스의 실행은 CPU 실행과 I/O 요청 대기가 번갈아가며 이루어지는 데, 이를 CPU I/O Burst Cycle라고 하며 CPU 스케줄러를 통해 이 CPU Burst Distribution을 관리하게 된다.

### CPU 스케줄링 왜 필요하죠?
> I/O 바운드 프로세스 : I/O 요청이 빈번해 CPU 버스트가 짧게 나타나느 프로세스 (대화형 프로그램 등 )
> CPU 바운드 프로세스 : I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나느 프로세스 (계산 위주 프로그램 등)

컴퓨터 시스템 내에서 수행되는 프로세스의 CPU 버스트를 분석해보면 대부분의 경우 짧은 CPU 버스트를 가지며, 극히 일부분만 긴 CPU 버스트를 갖는다. 즉, CPU를 한 번에 오래 사용하기보다는 잠깐 사용하고 I/O 작업을 수행하는 프로세스가 많다는 것이다. 대화형 작업에서는 사용자에 대한 빠른 응답을 위해 해당 프로세스에게 우선를 할당하는 것이 바람직하다. 따라서 CPU 스케줄링을 할 때 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 사용할 수 있도록 하는 스케줄링이 필요하다. 즉, I/O 바운드 프로세스의 우선순위를 높여주는 것이 바람직하며 CPU를 짬깐만 사용한 후 I/O 작업을 수행할 수 있어 I/O 장치의 이용륭이 높아진다. 하지만 CPU 바운드 프로세스에게 먼저 CPU를 할당할 경우 그 프로세스가 CPU를 다 사용할 때까지 I/O 바운디 프로세스는 응답시간이 길어지므로 비효율적이게 된다. 

### CPU 스케줄링이란? 
> 어떤 작업에 CPU를 할당할 지 결정하는 작업
> 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드

작업을 처리하기 위해 프로세스들에게 CPU를 할당하기 위한 정책을 계획하는 것이다.
CPU 스케줄링 대상 프로세스는 준비 큐에 있는 프로세스들로, 스케줄링 정책에 따라 큐에 정렬을 한 후, 앞에 있는 프로세스부터 CPU를 주게 된다. 

- 디스패처 
	- 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드 
	- 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정(Context Switch) 수행 
	- 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 디스패치 지연시간이라고 하고 문맥교환 오버헤드에 해당된다.

### 프로세스의 우선순위 
대부분의 CPU 스케줄러는 프로세스마다 우선순위를 부여한다. 중요한 프로세스를 더 빨리, 더 자주 실행해야하기 때문이다. 
따라서 커널 프로세스는 일반 프로세스보다 우선 순위가 더 높다. 

### 스케줄링 성능 평가 
시스템 관점의 지표로 CPU 이용률과 처리량이 있으며, 사용자 관점의 지표로 소요시간, 대기시간, 응답시간 등 기다린 시간과 관련된 지표가 있다. 

1. CPU 이용률 : 전체 시간 중에서 CPU가 일을 한 시간의 비율 
2. 처리량 : 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는 지를 나타냄.
3. 소요시간 : 준비 큐에서 기다린 시간과 실제로 CPU를 사용한 시간의 합
4. 대기시간 : CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합
5. 응답시간 : 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기 전까지 걸린 시간 

CPU 이용률과 처리량은 높이고, 사용자 관점 지표는 감소시키는 것이 스케줄링의 목표이다.

### 시스템별 목표 
CPU 스케줄링의 세부적인 목표는 시스템 마다 다르다. 
- Batch System 
	- 한 번에 하나의 프로그램만 수행하는 것 
	- 가능한 많은 일을 수행하기 위해 처리량과 CPU 이용률이 중요
- Interacive System 
	- 사용자가 컴퓨터 앞에서 대화형으로 동작하는 시스테 
	- 응답 시간 : 프로세스가 준비 큐에서 대기하는 시간을 최소화한다. 
	- 대기 시간 : 프로세스가 대기 큐에서 대기하는 시간을 최소화한다. 
	- Time Sharing 기법을 이용해야 한다. 
- Real-Time System 
	- 시간 제약 조건이 걸려있는 시스템 
	- Meeting Deadlines, Predictabillity


## CPU 스케줄링 알고리즘 
### 분류 
> 방법에 따라 

#### 1. 비선점 (Nonpreemptive)
CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지 CPU를 빼앗기지 않는 방법이며 프로세스 종료 또는 입출력 등의 이벤트가 있을 때까지 실행을 보장한다. 

장점 
- 선점방식보다 스케줄러의 작업량이 적고 문맥 교환에 의한 오버헤드도 적다.
- 모든 프로세스들에게 공정 
- 응답 시간 예측 가능 
- 일괄 처리 시스템에 적절 

단점 
- 짧은 작업을 수행하는 프로세스라도 긴 작업이 종료될 까지 기다려야하는 경우 발생

#### 2. 선점 (Preemptive)
프로세스가 CPU를 계속 사용하기를 원하더라도 운영체제가 강제로 빼앗을 수 있는 스케줄링 방법이다. 대부분의 저수준 스케줄러는 해당 방식을 사용하며 할당시간을 붕한 후 타이머 인터럽트를 발생시키는 방법이 대표적이다.

장점 
- 높은 우선순위를 가진 프로세스를 빠르게 처리하려는 시스템에 유용
- 빠른 응답 시간을 요구하는 시분할 시스템에 유용 

단점 
- 높은 우선순위를 가진 프로세스들이 들어오는 경우 오버헤드 발생

### 종류 
- 비선점형 알고리즘 : FCFS, SJF, HRN 
- 선점형 알고리즘 : Round Robin, SRT, 다단계 큐, 다단계 피드백 큐 
- 둘 다 가능 : 우선순위

#### FCFS (First Come First Serve)
준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 알고리즘 이다. 
CPU 버스트가 완료될 때까지 CPU를 반환하지 않으며 할당되었던 CPU가 반환될 때에만 스케줄링이 이루어진다. 
초기 일괄처리 시스템에서 사용되었으며 큐가 하나라 모든 프로세스의 우선순위가 동일하다. 

처리 시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려 시스템의 효율성이 떨어지는 **콘보이 효과**가 발생한다. (실행 시간이 짧은 작업이어도 뒤로 가면 대기 시간이 길어진다.)

장점 
- 개발 용이 
- 공평성 유지 

한계 
- 콘보이 효과  :  CPU 사용시간이 긴 프로세스에 의해 사용시간이 짧은 프로세스들의 대기 시간이 늘어나는 현상
	- 이를 극복하기 위해 SJF 알고리즘 탄생


### SJF (Shortest Job First)
준비 큐에 있는  프로세스 중 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 스케줄링이다.  FCFS의 콘보이 효과를 완화하기 위해 탄생했다. 
평균대기 시간이 짧으며, 짧은 작업에 유리하지만 다음과 같은 문제로 실질적으로 사용하기 어렵다. 
- 운영체제가 프로세스의 종료시간을 정확하게 예측할 수 없다. 
	- 현대 프로세스는 사용자와 상호작용이 빈번하기 때문에 프로그램 종료 시간을 파악하기 어렵다. 
- 공평하지 못하다. 
	- 작업 시간이 긴 프로세스가 준비 큐에 위치할 경우 작업이 계속 연기되는 기아(Starvation) 현상이 발생할 수 있다.
	- 기아 현상 : 우선순위가 낮은 프로세스가 순서가 계속 밀려 공평성 위배

그에 대한 해결책은 다음과 같다. 
- 프로세스가 자신의 작업 시간을 운영체제에게 알려준다. 
	- 프로세스가 자신의 작업 시간을 정확하게 알기 어렵고, 악의적인 프로세스가 작업 시간을 속인다면 시스템의 효율성이 나빠질 수 있다. 
- 에이징 
	- 오래 기다린 프로세스는 에이징 카운트를 올려 우선순위를 높여준다.
	- 에이징 값을 어떤 기준으로 정할 지 자체가 문제가 되는 한계 


### HRN (Highest Response-ratio Next)
SJF에서 발생할 수 있는 기아 현상을 해결하기 위해 만들어진 비선점형 알고리즘으로 서비스를 받기 위한 대기시간과 실행시간을 고려하여 우선순위를 계산해 점유 불평등을 보완한다.
하지만 우선순위를 계산해야 하므로 오버헤드가 증가한다.
```
우선순위 = (대기시간 + 실행시간) / 실행시간(CPU 사용시간)
```


### Round Robin 
> Time Quantum (Time Slice) : 실행의 최소 단위 시간 

한 프로세스가 할당받은 시간(타임 슬라이스)동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식이다.
FSFC와 유사하지만 선점이 가능하고 타임 슬라이스가 존재하는 것이다. 타임 슬라이스를 모두 사용한 프로세스는 강제로 준비 큐 맨 뒤로 이동하기 때문에 콘 보이 효과를 완화한다.  (프로세스의 Context를 저장하기 때문에 가능)

장점 
- CPU 사용시간이 랜덤한 프로세스들이 섞여 있을 경우 효율적 
- 응답 시간이 빨라진다. 

한계 
- 타임 슬라이스가 크면 FCFS와 다를빠가 없다. 
- 타음 슬라이스가 작으면 Context Switching이 잦아져서 Overhead가 증가한다. 


### SRT (Sortest Remaing Time)
현재 수행 중인 프로세스의 남은 작업 시간보다 더 짧은 CPU 작업 시간을 가진 새로운 프로세수가 도착할 경우 CPU 강제 회수하는 SJF의 선점형 방식이다. (새로운 프로세스가 도착할 때마다 스케줄링이 이루어진다. )
현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산해야 하고, 남은 시간이 더 적은 프로세스와 문맥 교환을 해야 하므로 SJF에는 없는 작업이 추가된다. 

한계 
- 기아 현상 
- 새로운 프로세스가 도달할 때마다 스케줄링을 다시 하기 때문에 CPU 사용 시간을 측정할 수 없다.

### 우선순위 스케줄링 (Priority Scheduling)
프로세스의 중요도를 기준으로 우선순위를 부여한 스케줄링 방식 
선점형과 비선점형 스케줄링 방식 모두 적용이 가능하다. 
우선순위는 내부, 외부적으로 정의될 수 있다. 
- 내부 : 시간 제한, 메모리 요구량, CPU burst 비율 등 어떤 측정 가능한 변수를 사용하여 우선순위를 계산하는 것 
- 외부 : 운영체제 스스로 정하는 것이 아닌 바깥에 이미 설정된 기준
	- 프로세스 중요도, 자원의 유형, 들어가는 자원의 비용, 사용자 선호도 등 

우선순위 스케줄링은 정적 우선순위 알고리즘과 동적 우선순위 알고리즘으로 나뉜다. 
- 정적 우선순위 알고리즘 
	- 한번 우선순위를 부여 받으면 종료될 때까지 우선순위가 고정된다. 
	- 구현이 단순하지만 변하는 시스템 상황을 반영하지 못함 
- 동적 우선순위 알고리즘 
	- 일정 시간마다 우선순위가 변함 
	- 구현이 복잡하지만, 시스템의 상황을 반영하여 효율적으로 운영 가능 

한계 
- 기아 현상
	- 에이징 기법으로 문제 해결 가능 
	- 우선순위가 낮은 프로세스도 최대 한도의 대기 시간을 가질 수 있다.


### 다단계 큐 (Multilevel-Queue)
> Multilevel : 프로세스들을 여러 레벨의 그룹으로 분류하는 것 

- 우선순위에 따라 다양한 스케줄링이 가능한 선점형 방식 

어떤 프로세스냐에 따라 어려 종류의 그룹으로 나누고 여러 개의 큐에 다양한 알고리즘을 적용하는 스케줄링 기법이다. 
운영체제는 프로세스들을 분류할 때 보통 사용자와 상호작용하는 앞단의 프로세스들은 중요하다고 판단하고 백그라운드에서 돌아가는 프로세스(일괄처리형 batch process)들은 상대적으로 덜 중요하다고 판단하여 분류하는 것이 일반적이다.
앞단에서 작동하는 프로세스는 요구되는 응답시간이 백그라운드 프로세스보다 짧아야 하기 때문에 앞단의 프로세스들은 백그라운드에서 돌아가는 프로세스들보다 더 높은 우선순위를 갖게 되고, 빠른 응답 시간을 주기 위해서 다른 알고리즘을 적용하여 효율적으로 성능을 끌어낸다.
상단 큐에 있는 모든 프로세스의 작업이 끝나야 다음 큐에 위치한 프로세스의 작업을 수행하며 우선순위가 낮은 큐들이 실행 못하는 것을 방지하고자 큐마다 다른 Time Quantum을 설정해준다 우선 순위가 높은 큐에는 작은 Time Quantum을, 낮은 큐에는 큰 Time Quantum을 할당하는 식이다





### 다단계 피드백 큐 (Multilevel-Feedback-Queue)
![](https://i.imgur.com/399qDlb.png)

한 번 해당 큐에 들어가면 프로세스는 다른 큐로 이동되거나 변경되는 것이 불가능한 다단계 큐의 단점을 보완한 기법이다. 즉, 변동형 우선순위 방식을 사용한다. 
다단계 큐가 우선순위에 따라 들어가는 입구가 달랐다면 다단계 피드백 큐는 모든 프로세스들이 제일 위에 있는 큐로 들어온다.
자신에게 할당된 Time Quantum을 다 사용한 프로세스는 그 밑의 레벨에 있는 큐로 내려가고 Time Quantum을 다 채우지 못한 프로세스는 원래 큐로 이동한다. 특징은, 밑에 있는 큐는 Time Quantum 크기를 첫 번째 있는 큐의 두 배로 돌린다. 
마지막 큐는 백그라운드 프로세스가 보통 그랬듯이 FCFS로 처리된다. 

#### 왜 그렇게 하는 가? 
Time Quantum을 다 채웠다는 것은 CPU burst process일 가능성이 높아 한 레벨 아래로 보내는 것이다. CPU bound process들은 사용자하고 대화형으로 동작하는 것이 아니니 context swtiching을 하지 않고 쭉 수행시켜주는 FCFS방식을 사용하는 것이다. 
즉, 다음 단계로 넘어갈 수록 CPU burst가 크다는 뜻이니 우선순위가 점점 낮아지게 된다. 
반면 I/O bound process는 사용자하고 대화형으로 동작하기 때문에 먼저 수행시켜줘야 한다.

#### 문제점 
우선순위가 높은 프로세스가 들어오면 낮은 우선순위를 가진 프로세스는 밀리는 기아 현상이 발생한다. 
- 에이징 방식을 도입해서 해결할 수 있다. (낮은 우선순위 큐에서 너무 오래 기다리는 프로세스들은 높은 우선순위 큐에 올리는 방식)


#### 다단계 큐 VS 다단계 피드백 큐 
구현이 복잡하지만 사용하는 이유는 다음과 같다.
- 유연성이 뛰어나다. 
- SJF알고리즘처럼 turnaround 시간에 최적화 되어 있다. Time Quantum을 보고 우선순위를 예측하고 변경한다. 즉, 이런 방법은 더 짧은 프로세스가 먼저 돌게 해주니 turnaround의 평균시간을 줄일 수 있따. 
- 대화형 프로세스가 앞으로 오니 response time이 짧다.