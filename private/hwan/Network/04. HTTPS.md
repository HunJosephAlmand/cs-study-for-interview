## HTTPS 
> HTTP 에 암호화와 인증, 그리고 완전성 보호를 더한 HTTPS

HTTP는 평문 통신이기 때문에 도청이 가능하고 통신 상대를 확인하지 않기 때문에 위장이 가능하며 완정성을 증명할 수 없기 때문에 변조가 가능하다. 

이런 HTTP의 보안적 약점을 보완하기 위한 프로토콜이 HTTPS이다. HTTPS는 SSL(Secure Socket Layer) 라는 보안 프로토콜 위에서 동작하는 HTTP 즉, 보안이 강화된 HTTP를 뜻한다. 

### HTTP 문제점 더 자세히 알아보기 
#### TCP/IP는 도청 가능한 프로토콜이다 .
> HTTP는 평문 통신이기 때문에 도청이 가능하다. 

TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼  수 있다. 패킷을 수집하는 것만으로 도청할 수 있기 때문에 평문으로 통신을 할 경우 암호화하여 통신해야 한다. 

**보완 방법**
1. 통신 자체를 암호화하는 SSL/TLS라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있따. SSL을 조합한 HTTP를 HTTPS라고 부른다. 
2. 콘텐츠를 암호화 즉, HTTP를 사용해서 운반하는 내용인 HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다. 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다. 

#### 통신 상대를 확인하지 않기 때문에 위장이 가능하다. 
HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리가 없기 때문에 누구든지 요청을 보낼 수 있따. IP주소나 포트 등에서 그 웹 서버에 엑세스 제한이 없는 경우 요청이 오면 상대가 누구든지 무엇인가의 응답을 반환한다. 이러한 특징은 아래와 같은 문제점을 유발하게 된다. 
1. 요청을 보낸 곳의 웹 서버가 원래 의도한 응답을 보내야 하는 웹 서버인지를 확인할 수 없다. 
2. 응답을 반환한 곳의 클라이언트가 원래 의도한 요청을 보낸 클라이언트인지를 확인할 수 없다. 
3. 통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다. 
4. 어디에서 누가 요청 했는 지 확인할 수 없다. 
5. 의미없는 요청도 수신하여 DoS 공격을 방지할 수 없다. 

**보완 방법**
SSL로 상대를 확인할 수 있다. SSL은 상대를 확인하는 수단으로 증명서를 제공하고 있다. 증명서는 신뢰할 수 있는 제 3 자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다. 이 증명서를 이용함으로써 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 


### 완정성을 증명할 수 없기 때문에 변조가 가능하다. 
여기서 완정성이란 정보의 정확성을 뜻하며 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것이다. 즉, 요청과 응답이 발신된 후에 상대가 수신하는 사이 누군가에 의해 변조되더라도 이 사실을 알 수 없다. 이와 같은 공격을 중간자 공격이라고 부른다. 

**보완 방법**
MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기 위해서는 HTTPS를 사용해야 한다. SSL에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있다.

### 특징 
- HTTPS의 기본 TCP/IP포트는 443번이다. 
- HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에 웹 상에서 정보를 암호화하는 SSL이나 TSL 프로토콜을 사용해 세션 데이터를 암호화한다. 
- HTTPS의 SSL에서는 대칭키 암호화 방식과 공개키 암호화 방식을 모두 사용한다.
- 인증서를 이용해서, 접속 사이트를 신뢰할 수 있는지 평가할 수 있다.
- HTTP에 비해 느리다. 

## SSL? TLS? 
SSL(Secure Socket Layer)은 SSL 1.0부터 시작해서 SSL 2.0, SSL 3.0, TLS(Transport Layer Security Protocol) 1.0, TLS 1.3 까지 버전이 올라가며 마지막으로 TLS로 명칭이 변경되었으나, 보통 이를 합쳐 SSL/TLS로 많이 불린다. 

![](https://i.imgur.com/cWbTosc.png)
SSL/TLS는 응용 계층과 전송 계층 사이에서 동작하는 보안 소켓 계층을 뜻하는 프로토콜로써, 클라이언트와 서버가 통신할 때 SSL/TLS를 통해 제3자가 메시지를 도청하거나 변조하지 못하도록 해준다. 
SSL/TLS는 응용 계층과 전송 계층 사이에서 동작하는 독립적인 프로토콜이라고 생각하며 되며 응용계층의 HTTP 프로토콜에서 사용자의 데이터를 받고 전송계층으로 캡슐화되기 이전에 SSL 프로토콜에 의해서 사용자의 데이터가 암호화된다. 이후 서버는 전송계층에서 세그먼트를 받아 SSL계층에서 데이터를 복호화하여 응용계층까지 보내게 되게 된다. 
즉, 우리는 SSL 프로토콜만 적용하면 마치 애플리케이션은 SSL을 TCP로 인식하고 TCP는 SSL을 애플리케이션으로 인식하는 것처럼 통신하기 때문에 우리가 별도로 통신에 대해 손댈 것은 없다. 

SSL은 TCP 위에서 Record Protocol을 통해 실질적인 보안서비스를 제공하고 Handshake Protocol, Change Clipher Spec Protocol, Alert Protocol을 통해 SSL 동작에 관한 관리를 하게 된다.
SSL/TLS는 보안 세션을 기반으로 데이터를 암호화하며 보안 세션이 만들어질 때 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용된다.

### 암호화 방식 
SSL의 과정을 알기전에 알아야 할 암호화 방식의 개념을 짚어보자. 

#### 암호화 
데이터를 알아볼 수 없는 모습으로 변경하여 감추는 것을 뜻한다. 

#### 복호화 
암호화된 데이터를 해독이 가능한 평문 데이터로 되돌리는 것을 뜻한다. 

### 키 
암호화, 복호화에 사용되는 것으로 해당 키가 없으면 데이터를 암호화할 수 도, 복호화할 수 도 없다. 키에는 여러 종류가 있다.

### 대칭키 
암호화에 사용되는 키와 복호화에 사용되는 키가 동일한 암호화 기법이다. 
그렇기 때문에 하나의 키를 통신하는 사용자끼리 공유하고 암호화를 해야 한다. 암호화를 함으로써 제3자 정보를 탈취해도 복호화할 키가 없기 때문에 내용을 보지 못할 것이다.
같은 키를 사용하기 때문에 암호화와 복호화가 쉽고 (비대칭 암호보다) 연산량이 적고 빠르다는 장점을 가지고 있다. (빠르기 때문에 대용량 데이터 암호화도 가능하다.)
하지만 암호키 자체는 암호화되지 않은 평문이기 때문에 타인에게 노출되면 그 키로 암호화 되었던 데이터들은 모두 유출되는 문제가 발생하여 보안적으로 취약해진다. 즉, 키 전달 및 관리에 어려움을 가지고 있는 것이다.

**종류**
- 블록 암호 
	- 암호화를 할 때 평문은 블록끼리 단위로 암호화하는 기법 
	- 블록 길이는 보통 키 길이로 정해지며 128bit, 192bit, 256bit로 이루어져 있다.
	- 만약 블록 길이가 맞지 않으면 맞추기 위해 패딩을 추가한다.
	- Feisel, SPN구조이며 SEED, DES, AES 등 알고리즘이 존재한다. 
- 스트림 암호 
	- 1bit 단위로 암호화하며 XOR를 사용하여 암호화한다. 
	- 블록 암호보다 빠르지만 안전하지 않아 무선 환경에서 주로 사용한다. 


### 비대칭키, 공개키 
![](https://i.imgur.com/JVwRJKz.png)
암호화, 복호화 시 사용하는 키가 다른 방식 즉, 서로 다른 키로 암호화와 복호화를 수행 하는 방법이다.
여기서 보통 데이터를 암호화하는 키를 공개키, 복호화하는 키를 개인키라고 한다. 공개키로 암호화한 데이터는 오직 개인키로만 복호화할 수 있다. (반대로 개인키로 암호화한 데이터는 공개키로만 복호화 가능)

#### 공개키 
암호화 과정에 참여하는 웹브라우저, 서버 같은 키 발행자 뿐만 아니라 해커 등 누구든지 알아도 상관없는 키를 말한다. 개인키와 쌍을 이루어 존재하며 주로 데이터를 암호화하는 데 사용한다. (그렇다고 해서 복호화에 사용할 수 없는 뜻은 아니다.)

#### 개인키(비밀키) 
공개키와 달리 키 발행자만이 갖는 키이다. 공개키와 쌍을 이루어 존재하며 주로 데이터를 복호화하는데 사용한다. (공개키와 마찬가지로 암호화에 사용할 수 없는 뜻은 아니다.)
- 암호화 - 공개키, 복호화 - 비공개키 : 데이터를 암호화하여 보호하기 위한 목적 
- 암호화 - 비공개키, 복호화 - 공개키 : 인증을 위한 목적이다. 즉, 서버에서 비공개키로 데이터를 암호화하여 보냈을 경우 클라이언트에서 공개키로 복호화가 된다면 최소한 해당 서버는 클라이언트 입장에서 신뢰할 수 있다는 인증과정을 거치게 된다. 정리하자면 공개키가 데이터를 제공한 사람의 신원을 보장해주는 것이며 이것을 전자서명이라고 부른다.


#### 과정 예시 
이 방식을 사용하면 해커가 공개키를 가져도 문제가 되지 않는다. 예를 들어 클라이언트에서 서버의 공개키로 암호화하여 서버에게 데이터를 전송했을 때 해커가 이를 탈취해서 공개키로 복호화할려 해도 복호화할 수 없게 된다. 그렇기 때문에 공개키를 무한대로 나눠줘도 상관없어 키 배송 문제는 없어지게 된다.

#### 공개키 방식만 사용하면 될까? 
공개키 방식을 통해 대칭키의 단점이였던 키 전달 및 관리 문제는 사라지게 되었다. 하지만 공개키 방식은 대칭키 방식보다 암호화 연산 시간이 더 소요되어 비용이 크기 때문에 사이트를 이용할 때 주고받을 다량의 데이터를 비대칭키로 일일이 암호화, 복호화 하는 것은 무리이다.
또한, 암호화에 사용하는 공개키가 특정 사용자의 공개키가 맞는지 보장할 수 없다. 만약 네이버를 사용하기 위해 네이버의 공개키를 받았는 데 이 공개키가 정말 네이버의 공개키일지 확인할 방법이 없다. 
이러한 문제점 때문에 SSL에서는 비대칭키, 공개키 방식을 혼합하여 사용하며 인증서를 이용하게 된다. 

### CA와 디지털 인증서 
디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다. 즉, 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 한다. 서버 인증서는 조직의 이름, 주소, 서버 DMS 도메인 이름과 같은 정보를 담고 있다. 

위에서 말한 신뢰할 수 있는 기관을 CA(Certificate authority)라고 부른다. CA는 비밀키를 이용해 암호화된 인증서를 주게 된다. 이 인증서에는 위에서 말한 서비스의 정보(인증서를 발급한 CA, 서비스의 도메인 등), 서버 측 공개키(공개키의 내용, 공개키의 암호화 방법)가 들어가 있다. 
여기서 의문인 것이 클라이언트가 사용할 공개키는 인증서 안에 담겨져 있다면, CA의 비밀키로 암호화된 인증서를 복호화할 공개키는 어디에 있을까? 답은 브라우저에 있다. 우리가 사용하는 크롬, 사파리 등에는 이미 신뢰할 수 있는 CA 기관의 리스트와 해당 기관의 공개키를 이미 가지고 있다. 만약 자신이 가지고 있지 않은 인증기관의 공개키를 사용해야 한다면 외부 인터넷으로 나가 인증기관 관련 정보와 공개키를 확보하게 된다. (SSL인증서를 사용할 때 최소한의 인터넷 접속이 필요한 이유)


### HTTPS 통신 흐름 
![](https://i.imgur.com/Lt6NZQ4.png)

**사이트 접속 전** 
1. 서버 : 한 쌍의 공개키와 개인 키를 생성한다. 그리고 서버 내 사이트의 각종 정보와 자신의 공개키를 인증 기관에 전달하여 SSL 인증서 생성을 요청한다. 
2. 인증 기관(CA) : SSL 인증서를 발급한다. 이 인증서에는 서버의 도메인을 비롯하여 서버임을 인증하는 각종 정보와 서버의 공개키를 담고 있다. 이때 인증기관은 자신만의 한 쌍의 공개키와 개인키를 생성하고, SSL 인증서를 인증기관의 개인키로 암호화하여 서버에게 전달하고, 서버는 이 SSL인증서를 게시하게 된다. (인증기관의 공개키는 브라우저에 내장)

**사이트 접속 후** 
3. 클라이언트 : 사이트로 접속을 요청한다. 
4. 서버 : 사이트는 자신이 신뢰할 수 있는 사이트 임을 증명하기 위해 클라이언트에게 자신의 인증서를 전달한다.
5. 클라이언트 : 인증기관의 개인키로 암호화된 SSL 인증서를 전달받았지만 이 인증서가 CA로부터 서명된 것인지 판단한다. 브라우저에 내장된 CA의 공개키를 활용하여 인증서가 복호화 가능하다면 접속한 사이트가 CA에 의해 인증되었음을 알게 될 것이고 서버가 신뢰할 수 있는 서버라는 것을 알게 된다. 
6. 클라이언트 : CA의 공개키를 이용해 인증서를 복호화하고 서버의 공개키를 획득한다.
7. 클라이언트 : 서버의 공개키를 사용해 랜덤 대칭 암호화키(대칭키), 데이터 등을 암호화하여 서버로 전송한다. 
8. 서버 : 서버의 공개키로 암호화된 데이터를 서버의 개인키로 복호화하여 랜덤 대칭 암호화키(대칭키), 데이터 등을 획득한다. 
9. 서버 : 대칭키로 클라이언트의 요청에 대한 응답을 암호화하여 잔달한다. 
10. 클라이언트 : 대칭키를 이용해 복호화하고 데이터를 이용한다.


### SSL handshake 
![](https://i.imgur.com/weCdfh5.png)
![](https://i.imgur.com/OatKcwP.png)

HTTPS 통신과정에서 송신자와 수신자가 암호화 통신을 하기 위한 방법과 수단에 대해 공유하게 된다. 이를 SSL Handshake라고 하며 이 과정에서 SSL 인증서 전달, 대칭키 전달, 암호화 알고리즘 결정, SSL/TLS 프로토콜 결정 등이 포함된다. 
- 암호화 알고리즘(Cipher Suite) 결정 
- 데이터를 암호화할 대칭키 전달 

### 1. Client Hello 
클라이언트가 서버에 연결을 시도하며 전송하는 패킷이다. 자신이 사용 가능한 Ciper Suite 목록, Session ID, SSL Protocol Version, Random Byte 등을 전달한다. Ciper Suite란 SSL Protocol version, 데이터 암호화 프로토콜,해싱 알고리즘 등이 나열된 규약으로 선택된 사이퍼 슈트의 알고리즘에 따라 데이터를 암호화하게 된다. 

![](https://i.imgur.com/vgNCoD8.png)
> https://rsec.kr/?p=455

> 세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 [기존의 세션]을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.

### 2-1. Server Hello 
클라이언트가 보내온 패킷을 받아 Cipher Suite 중 하나를 선택한 다음 클라이언트에게 이를 알린다. 선택된 암호화 방식으로 클라이언트 - 서버 간 통신이 진행되며 만약 지원하지 않는 암호화 방식밖에 없다면 암호화 협상 결렬로 악수는 불발된다. 
또한, 자신의 SSL Protocol Version, Random Byte도 전달한다. 

### 2-2. Certificate 
서버가 자신의 SSL 인증서를 클라이언트에게 전달한다. 인증서 내부에는 서버가 발행한 공개키가 들어있다. 클라이언트는 서버가 보낸 인증서를 브라우저에 내장된 CA의 공개키를 사용하여 복호화한다. 복호화에 성공한다면 이 인증서는 CA가 서명한 것이 맞는 것이니 진짜임이 증명된다. (인증서 검증)


### 2-3. Server Key Excahnge / ServerHello Done 
서버의 공개키가 SSL 인증서 내부에 없는 경우, 서버가 직접 전달한다. 공개키가 SSL 인증서 내부에 있을 경우 해당 과정은 생략된다.


### 3. Client Key Exchange 
대칭키를 클라이언트가 생성하여 SSL 인증서 내부에서 추출한 서버의 공개키를 이용해 암호화한 후 서버에게 전달한다. 여기서 전달된 대칭키가 바로 SSL Handshake의 목적이자 가장 중요한 수단인 데이터를 실제로 암호화할 대칭키이다. 클라이언트는 서버로부터 받은 랜덤 값과 클라이언트에서 생성한 랜덤값을 대칭키로 만들게 된다. (이를 pre master secret 라고 함.)

- RSA 
	- 클라이언트가 대칭키를 생성하여 서버의 공개키로 암호화 한 후 전달 
- 디피-헬만 알고리즘 
	- 클라이언트가 데이터를 암호화할 대칭키를 보내는 것이 아닌 대칭키를 생성할 재료를 클라이언트와 교환하게 된다. 
	- 서로 교환한 재료를 합쳐 동일한 대칭키를 만들어 낸다.
	- 공개 값을 공유하고 각자의 비밀 값과 혼합한 후 혼합 값을 공유한다. 그 다음 각자의 비밀 값과 혼합하여 공통의 암호키를 생성한다. 
	- 클라이언트와 서버 모두 개인키와 공개키를 생성하고 서로에게 공개키를 보내고 공개키와 개인키를 결합하여 PSK(사전 합의된 비밀키)가 생성된다면, 악의적인 공격자가 개인키 또는 공개키를 가지고도 PSK가 없기 때문에 안전하다.
- 대수곡선 기반의 ECDHE 
- 묘듈식 기반의 DHE

### 4. ChangeCipherSpec / Finished 
클라이어트, 서버 모두가 서로에게 보내는 패킷으로 교환할 정보를 모두 교환한 뒤 통신할 준비가 다 되었음을 알리는 패킷이다. 그리고 `Finished` 패킷을 통해 SSL Handshake를 종료하게 된다.
만약 세션(session)이 여전히 유지되고 있다면, 클라이언트는 SSL handshake 요청이 아닌 세션 ID만 서버에게 알려주면 된다.


정리하자면 
1. ClinentHello - 암호화 알고리즘 나열 및 전달
2-1. ServerHello - 암호화 알고리즘 선택 
2-2. Server Certificate - 인증서 전달
3. Client Key Exchange - 데이터를 암호화할 대칭키 전달 
4. Client / ServerHello done - 정보 전달 완료 
5. Finished - SSL HandShake 종료
이런 과정을 거치게 되며 과정이 끝날 경우 Client와 Server는 데이터를 암호화할 동일한 대칭키를 갖게 된다.
모든 웹 콘텐츠의 전달을 공개키 방식으로 한다면 웹 서버와 브라우저에 많은 부담이 되기 때문에 SSL Handshake 단계까지는 공개키 방식, 그 이후의 HTTPS 통신은 대칭키 방식을 사용하는 것이다.

### HTTPS 장,단점 
**장점** 
- 네트워크 상에서 열람 및 수정이 불가능하므로 안전하다. 

**단점**
- 암호화를 하는 과정이 웹 서버에 부하를 준다. 
- HTTPS는 설치 및 인증서를 유지하는 데 추가 비용이 든다. 
- HTTP에 비해 느리다. 
- 인터넷의 연결이 끊긴 경우 재인증 시간이 소요된다. 
	- HTTP는 비연결형으로 웹 페이지를 보는 중 인터넷이 연결이 끊겼다가 다시 연결되어도 페이지를 계속 볼 수 있다. 
	- HTTPS는 소켓 자체에서 인증을 하기 때문에 인터넷이 끊기면 소켓도 끊겨 다시 HTTPS 인증이 필요하다.


## 모든 웹 페이지에 HTTPS를 사용해도 될까? 
평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구한다. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 많은 부담이 가게 된다. 
하지만 최근에는 하드웨어의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않는다. 새로운 표준인 HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 더 빠르게 동작하고 구글은 HTTPS를 사용하는 웹 사이트에 가산점을 부여한다. 
따라서 웹은 과거의 민감한 정보를 다룰때만 HTPS에 의한 암호화 통신을 사용하는 방식에서 현재 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어가고 있다.


> SEO (Search Engine Optimization)
> 검색 엔진 최적화를 뜻하며, 사용자들이 구글, 네이버 같은 검색엔진으로 웹 사이트를 검색했을 때  그 결과를 페이지 상단에 노출시켜 많은 사람들이 볼 수 있도록 최적화하는 방법



## HTTPS 구축 방법 
1. 직접 CA에서 구매한 인증키를 기반으로 HTTPS 서비스 구축 
2. 서버 앞단의 HTTPS를 제공하는 로드밸런서(웹 서버) 구축 
3. 서버 앞단에 HTTPS를 제공하는 CDN 구축 
> https://blog.naver.com/PostView.naver?blogId=n_cloudplatform&logNo=221918957658&redirect=Dlog&widgetTypeCall=true&directAccess=false