[toc]



# OSI 7계층



## 1. 물리 계층


*  bitstream을 두 노드 사이에 연결된 물리적인 데이터 링크를 통해 전송.
* 기기 예시
  * 네트워크 인터페이스 컨트롤러
  * 이더넷(유선 인터넷) 허브
  * 네트워크 스위치
* 디지털 비트를 특정 신호로 인코딩
  * 전자
  * 라디오
  * 광학
* 특정 아날로그 신호로의 인코딩이 어떻게 이루어지는지 결정
  * ex) 1 비트 : 5v -> 0v로 바뀔 때

## 2. 데이터 링크 계층


* 같은 네트워크에 직접적으로 연결된 두 노드의 데이터 전송 프로토콜
* 물리 계층에서 나타날 수 있는 오류들을 감지하고 수정한다.
  * 두 개 이상의 호스트가 같은 회선을 통해 데이터를 동시에 전송할 때

* 물리적으로 연결된 두 기기의 커넥션을 생성하고 제거하는 프로토콜을 결정한다.
* 흐름 제어
  * 수신 노드의 수신 속도가 송신 노드의 송신 속도보다 느릴 때 발생하는 문제 방지.
  * 송신 노드에게 수신 노드가 feedback을 보내는 여부에 따라 분류
* 두 개의 하위 계층으로 나뉜다.
  * Medium Access Control(MAC)
    * 네트워크에 있는 기기들이 어떤 방식으로 전송을 위한 중개 매체에 접근하고, 접근을 허용 받는지를 결정
  * Logical Link Control(LLC) 
    * 네트워크 계층들을 식별하고, 캡슐화한다.
    * 오류 체크
    * 프레임 동기화
  * 이더넷, 와이파이, 지그비

## 3. 네트워크 계층

* **다른 네트워크**에 있는 노드들 간의 연결 기능 및 절차적 수단 제공.
* 네트워크
  * 다수의 노드들이 연결될 수 있는 중간 매체
  * 네트워크 안에서 모든 노드들은 고유의 주소를 갖는다.
  * 기기들은 메시지를 전송할 때 전송 메시지 내용과 목적지 주소만 네트워크에 제시하면 네트워크가 내부적으로 구현된 방법으로 메시지를 전달한다.
  * 보통 routing을 통해 중간 노드들을 거쳐서 목적지 노드까지 전달한다.
* 데이터가 너무 클 경우, 네트워크에서 메시지를 나눠서 전송한다. 
  * 나눠진 메시지는 목적지 노드가 재결합한다.
* 네트워크 계층에서는 신뢰성 있는 메시지 전송을 보장하지 않는다.
* IP 뿐만 아니라 다른 프로토콜들도 존재
  * ARP : 논리 주소 -> 물리 주소(broadcast)
  * RARP : 물리 주소 -> 논리 주소
  * ICMP
    * 연결 상태 제어 및 관리(서버가 닫혀 있는가 등)


## 4. 전송 계층


* 소스 호스트의 애플리케이션과 목적지 호스트의 애플리케이션 사이의 **신뢰성 있는 데이터 전송**을 위한 수단을 제공한다.
* 종류
  * Connection-oriented(연결형)
    * TCP, COTP
    * segment를 추적하고, segment 전송이 실패했을 경우, 다시 전송 요청(hand-shake)
    * 전송한 데이터가 제대로 전송되었는지 acknowlegement, 확인이 되었을 경우 다음 데이터 전송

  * Connectionless(비연결형)
    * UDP, CLTP
    * 신뢰성 보장 X
    * 패킷 손실, 순서, 오류, 중복 허용
      * 사용하는 애플리케이션에서 치명적이지 않음
    * 스트리밍에서 사용
* 거대한 Protocol Data Unit 또는 데이터 스트림을 "segment" 라는 덩어리로 나눈다.=> segmentation

  * 네트워크 계층의 최대 전송 패킷 사이즈(Maximum Transmission Unit) 이내여야 한다.
  * 네트워크 계층과 데이터 계층이 허용할 정도로 segment 단위의 최대 데이터 크기가 결정된다.
    * 이더넷의 MTU - 1500 bytes
* 흐름 제어
* 오류 제어
  * 변조
    * 체크섬으로 확인
    * 송신쪽 헤더에서 보낸 체크섬과 수신 쪽에서 계산한 체크섬을 비교
  * 누락
  * 순서
* 순서 제어

  *  acknowledgement
* cf) TLS는 전송 계층과 세션 계층의 특징을 골고루 갖고있다.(정확하게 OSI 모델과 일치하지 않음)

## 5. 세션 계층

* 두 애플리케이션 사이의 연결(세션) 관리

  * 연결 수립, 종료, 동기화, 유지 관리

* 사용자 로그인, 사용자 로그오프

* 인증 프로토콜
  * FTP NFS 클라이언트

* 통신 방식
  * 동시 송수신 방식(duplex)
  * 반 이중 방식(half-duplex)
  * 전 이중 방식(full duplex)

* 토큰 관리

* 체크포인트를 두어서 연결이 실패했을 경우, 실패한 지점부터 연결을 재개시킬 수 있게 한다.

* 음성이나 비디오 스트림 관련 세션 제어 절차를 성립

* 요청 / 응답 구조

* 자바에서의 예시 : session beans

  * 세션이 수립된 동안에만 저장.
  * 사용자 정보 저장

  

## 6. 표현 계층

* 코드 사이의 번역 담당

* 데이터 포맷
* 데이터 변환
* 애플리케이션에서 전송하는 데이터를 특정 형태로 인코딩/디코딩
* 프로토콜 변환, 데이터 암호화, 데이터 복호화, 데이터 압축, 데이터 압축 해제, OS 간의 데이터 표현 비호환성
* 애플리케이션 계층이 수용할 수 있는 형태로 데이터를 변환
* 예시
  * 객체, 기타 자료 구조의 직렬화(XML, JSON);
  * EBCDIC -> ASCII

## 7. 응용 계층

* 프로토콜 스택을 통해 전달받은 패킷을 다시 파싱해 응용 소프트웨어를 통해 최종적으로 사용자까지 전달

* 사용자와 가장 가까이 있는 계층

* 응용 프로그램들을 매개로 사용자와 직접적인 상호작용.

* 파일 공유, 메시지 처리, 데이터베이스 접근

* HTTP, FTP, SMB/CIFS, TFTP, SMTP, DNS

* 애플리케이션 개체와, 애플리케이션의 구분

  * 예약 웹사이트 애플리케이션의 개체들

    1. HTTP
       * 사용자의 HTTP 프로토콜 요청/응답

    2. RPC
       * 예약 데이터베이스 예약 요청 저장

# TCP/IP 4계층

* 인터넷 혹은 유사 컴퓨너 네트워크에서 사용되는 통신 프로토콜의 집합

## 응용 계층

* OSI 7계층의 응용 계층 + 표현 계층 + 세션 계층
* process to process

## 전송 계층

* host to host

## 인터넷 계층

* 독립적인 네트워크들의 연결 (= 라우팅)

## 링크 계층

* OSI 7 계층의 물리 계층 + 데이터 링크 계층
* 호스트와 직접 연결된 로컬 네트워크 연결 (= link)
  * 라우터를 거치지 않은 직접 연결된 호스트들을 포함한다.

# TCP/UDP

## TCP

가상 회선 구축(vs UDP)

### 연결 성립(3-way handshake)

* 클라이언트가 SYN(n) 패킷 전송
  * 연결 요청 패킷
* 서버는 패킷을 받아서 ACK(n + 1), SYN(m) 패킷 전송
  * ack를 통해 서버가 성공적으로 클라이언트의 요청을 받을 수 있는 상태임 알 수 있음
* 클라이언트는 패킷을 받아서 ACK(m + 1)과 데이터가 담긴 패킷을 전송
  * ack를 통해 클라이언트가 서버의 패킷을 제대로 받았다는 것을 알 수 있음
* 연결 수립

### 연결 종료(4-way handshake)

* 데이터를 모두 받은 클라이언트는 서버에게 FIN 패킷 전송
  * 이 때 연결은 유지한다. 서버가 다 보내지 못한 패킷이 존재할 수 있으므로
*  서버는 FIN 패킷을 성공적으로 받았다고 클라이언트에게 ACK 패킷을 전송
* 서버는 연결을 닫을 준비(CLOSE_WAIT) 상태가 되고, 데이터를 전부 전송한 서버는 클라이언트에게 FIN 패킷을 전송
* 서버로부터 FIN 패킷을 받은 클라이언트는 서버에게 FIN 패킷을 받았다는 ACK 패킷을 보내고, 일정 시간 뒤에 커넥션을 종료(TIME_WAIT)
  * TIME_WAIT이 있는 이유
    * 서버가 커넥션을 성공적으로 종료시키기를 보장
    * 서버가 ACK를 받고 커넥션을 종료하기 까지 시간이 걸림
    * 없을 경우 서버가 커넥션을 종료하기 전에 클라이언트가 새로운 커넥션 형성 요청을 보낼 수 있음
* ACK 패킷을 받은 서버는 커넥션을 종료한다.

### 흐름 제어

* 패킷 전송 호스트와 과 수신 호스트의 처리 속도 조절
  * 수신 호스트의 패킷 처리 속도가 느릴 경우 송신 호스트에서 초당 전송 패킷 수 감소

#### 대표 알고리즘

* stop and wait
  * 전송한 패킷에 대한  ack 응답을 받으면 다음 패킷 전송
  * 매우 느림
* sliding window
  * 수신 호스트는 TCP 헤더에 있는 receive window 필드를 통해 버퍼에 추가 데이터를 얼마나 더 받을 수 있는지 알려준다.
  * ack 확인을 하지 않고 전송한다.
  * 3-way handshake에서 송신, 수신 윈도우가 동기화된다.
  * 수신 호스트는 receive window 필드를 읽고, receive window에 작성된 데이터만큼 데이터를 전송한다.(ack를 확인하지 않고)
  * receive window가 0이 되면

### 혼잡 제어

* 네트워크 성능이 저하되는 혼잡 충돌 상황을 피하기 위해 사용
* 네트워크에 전송되는 패킷의 상-하한선 조정
* slow-start, 
  * MSS(최대 세그먼트 크기)를 낮은 숫자에서 점진적으로 증가시키는 방식
  * 패킷이 성공적으로 도착하면 윈도우 크기를 지수적으로 증가
  * CWND(congestion window size)가 한계점(sshthreshold)에 도달하면 윈도우 크기를 1로 줄인다.
* fast retransmit
  * 타이머를 이용해 보낸 패킷이 손실되었는지 파악한다.(기존)
  * 같은 acknowledgment를 3번 이상 받을 경우, 순서대로 보낸 패킷이 중간에 손실되었다고 간주하고 타이머를 기다리지 않고 해당 패킷부터 다시 재전송한다.
* fast recovery
  * 혼잡 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄인 다음에, 선형적으로 증가시킨다.

### 오류 제어

* checksum 필드를 통해 패킷이 변조되었는지 확인할 수 있다.
* sequence number로 중복된 패킷이나 순서에서 벗어난 패킷을 제거할 수 있다.
* acknowledgement로 전송에 실패한 패킷을 재전송할 수 있다.
* sequence number가 난수
  * 중복 가능성 배제

## IPV4 vs IPV6

* IPV4
  * 32비트
  * 43억
  * 자리수 별 10진수 포맷
  * IP 주소 부족 현상
* IPV6
  * 128 비트
  * 자리수 별 16진수 포맷
  * IP 주소 부족 현상 없음
  * 더 간단한 라우터
  * 모바일 최적화
  * 더 많은 데이터 송신
  * 1%만 사용
  * 통신 방식의 변경
    * unicast
      * ipv4, ipv6
    * multicast
      * 선택해서 뿌린다.
      * 연결 되어 있으면 보낼 수 있음
      * ipv4, iv6
    * broadcast
      * 한 네트워크 안에 있는 모든 기기한테 뿌림
      * ipv4
    * anycast
      * 가장 가까운 노드랑 통신 방식
      * ipv6
