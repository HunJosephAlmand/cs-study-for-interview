## Generic 
컴파일 타임에 타입을 체크함으로써 코드의 안정성을 높여주는 기능 
즉, 다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다. 
객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여주며 자연스럽게 코드도 간결해지는 효과가 있다.

> 타입 안정성을 높인다는 뜻은 의도하지 않은 타입의 객체가 저장되는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환 되어 발생할 수 있는 오류를 줄어준다는 것이다.

### 장점 
- 타입 안정성을 제공한다. 
	- 컴파일 타임에 타입 체크를 하기 때문에 
- 타입 체크와 형 변환을 생략함으로써 코드가 간결해진다.

### 왜 사용할까? 
- 제너릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있기 때문이다. 
	- 즉, 실행 시 타입 에러가 나기 전에 컴파일 시에 미리 타입을 강하게 체크하여 에러를 사전에 방지한다.
- 캐스팅 즉, 타입 변환을 제거함으로써 별도의 로직 처리가 필요없어진다. 

### 특징 
#### 1. 불공변 
제너릭과 비교하여 배열은 공변이다. 
공변이란, Sub가 Super의 하위 타입일 때 Sub[]는 Super[]의 하위타입인 것이다. 
예를 들어, String은 Object의 하위 타입이기 때문에 String[]은 Object[]의 하위타입이다. 
그렇기 때문에 아래와 같은 코드는 컴파일시에 오류를 뱉지 않으며, 런타임에서야 예외를 던지게 된다. 
```java 
Object[] arr = new String[5];
arr[0] = "1"; // ArrayStoreExpcetion예외가 런타임시에 발생
```


그에 반해 제너릭은 불공변이다. 
즉, `List<String>`은 `List<Object>`의 하위타입이 되지 않는다는 것이다. 
그렇기 때문에 아래와 같은 코드는 컴파일 타임에 에러를 발생하여 사전에 차단한다.
```java 
List<Object> list = new ArrayList<String>(); // 컴파일 에러 
```


### 2. 타입 추론 
타입추론이란 메서드를 호출하는 코드에서 타입인자가 정의한대로 제대로 쓰였는 지 살펴보는 컴파일러의 기능이다. 즉, 컴파일러가 타입을 추론하는 것을 말한다. 
이 타입추론을 하기 위해 메서드 호출과 호출할 때 사용하는 인수을 결정하기 위한 선언부를 살펴본다. 추론 알고리즘를 통해 인수 타입을 결정하고 가능하다면 결과가 할당되는 타입(인수타입)이나 반환 타입도 추론한다.


##### 제너릭 메서드의 타입 추론 
```java 
public Class BoxDemo {
	public static <T> void addBox(T t, List<Box<T>> boxes) {
		Box<T> box = new Box<>(); 
		box.set(t);
		boxes.add(box);
	}

	public static void main(String[] args) {
		List<Box<Integer>> integerBoxes = new ArrayList<>(); 
		BoxDemo.<Integer>addBox(Integer.valueOf(10), integerBoxes); // (1)
		BoxDemo.addBox(Integer.valueOf(20), integerBoxes); // (2)
	}
}
```
`(1)` :  addBox라는 제너릭 메서드를 호출할 때 `<Integer>` type witness와 함께 type parameter를 명시하여 사용할 수 있다. 이를 명시적 타입인수라고 한다. 
`(2)` : Java 컴파일러가 메서드의 인자로부터 자동으로 Integer type임을 추론해주기 때문에 type witness를 생략할 수 도 있다. (자바 7부터 가능)


#### 제너릭 클래스의 인스턴스 
Java 컴파일러가 컨텍스트로부터 타입추론이 가능하다면 제너릭 클래스의 생성자를 호출하기 위해 필요한 type arguments를 비어있는 type withness로 대처 할 수 있다. 
```java 
List<String> names = new ArrayList<String>(); 
-->
List<String> names = new ArrayList<>(); 
```

#### 3. 타입 소거 
제너릭은 타입의 정보가 런타임에는 소거된다. 즉, 원소의 타입을 컴파일타임에만 검사하고 보증함으로써 런타임에는 타입의 정보를 알 수 없게끔 한다. (이를 실체화가 되지 않는다 라고 한다.)
이는 제너릭이 자바5부터 나옴으로써 이전의 레거시코드도 호환될 수 있도록 하기 위해서이다. 
- 타입 매개변수의 경계가 없는 경우에 Object로, 경계가 있는 경우에는 경계 타입으로 타입 파라미터를 변경한다. 
	- `<T>` -> Object 
	- `<T extends Number>` -> Number
- 타입 안정성을 유지하기 위해, 필요한 경우 타입 변환을 추가한다. 
- 제너릭 타입을 상속받은 클래스의 다형성을 유지하기 위해 Bridge Method를 생성한다.


### 제너릭 타입 
매개 변수화된 자료형을 사용하는 제너릭 클래스 또는 인스턴스를 뜻한다. 
```java 
public class Box {
	private Object object; 

	public void set(Object object) {
		this.object = object; 
	}

	public Object get() {
		return object;
	}
}
```
다음과 같은 Box 클래스는 모든 자료형의 객체를 넣고 뺄 수 있다. 하지만 컴파일 타임에 클래스가 어떻게 사용되는지 확인할 방법이 없다. 
예를 들어 Integer를 Box에 넣어서 Integer를 얻을 것으로 예상했지만 다른 부분에서 실수로 String을 전달하면 런타임 에러가 발생할 수 있다. 
이외에도 형변환을 해서 사용해야 하는 단점이 있다.

이를 제너릭 타입으로 변경해보자. 
```java 
public class Box<T> {
	private T t;

	public void set(T t) {
		this.t = t;
	}

	public T get() {
		return t;
	}
}
```
제너릭을 사용함으로써 모든 자료형의 객체를 담을 수 있고 앞써 말한 문제점도 컴파일 시점에 알 수 있게 된다. 

#### 멀티 타입 파라미터 
제너릭 타입은 두 개 이상의 파라미터가 필요한 경우 필요한 만큼 선언할 수 있다.
```java 
public class Student<K, V> {
	private K studentNumber; 
	private V name; 

	...
}
```


### 제너릭 메서드 
매개 타입과 리턴 타입으로 타입 파라미터를 갖는 메서드이다.
리턴 타입 앞에 <>를 추가하여 타입 파라미터를 적는다. 
매개변수의 타입과 리턴타입, 메서드 안에서 타입 파라미터를 사용한다.
제너릭 타입을 선언하는 것과 비슷하지만 제너릭 메서드에서 타입 매겨변수의 scpore는 선언된 메서드로 제한된다. 즉, 제너릭 타입과 제너릭 메서드의 타입이 T로 동일하더라도 둘은 다르다는 것이다. 
```java 
// Collections.sort() 메서드 
static <T> void sort(List<T> list, Comparator<? super T> c)
```
Java SE 8부터는 컴파일러의 타입 추론 개념이 확장되어 메소드 인자에 포함된 매개변수화된 타입까지 검사한다.


### 제너릭 타입 제한 
> 바운디드 타입 매개변수 

타입 문자로 사용할 타입을 명시하면 한 종류의 타입만 저장할 수 있도록 제한할 수 있지만, 그래도 여전히 모든 종류의 타입을 지정할 수 있다는 것은 변함없다. 
즉, `FruitBox<Toy> fruitBox = new FruitBox<>();`와 같이 개념적으로 과일상자이지만 Toy라는 장난감을 넣을 수 있는 구조라는 것이다. 
그래서 타입 매개변수 T에 지정할 수 있는 타입의 종류를 제한하기 위해 제너릭 타입에 `extends`를 사용하여 제한된 제너릭 타입으로 바꿀 수 있다.
제너릭 타입에 extends를 사용하면 특정 타입의 하위 타입들만 대입할 수 있게 제한하게 된다. 
```java 
// Fruit 포함 Fruit의 하위 타입만 가능하다.
public class FruitBox<T extends Fruit> {   
}
```

만약 클래스가 아닌 인터페이스를 구현해야 한다는 제약이 생긴다면? 
이땐 implements가 아닌 extends를 사용한다. 
```java 
public class FruitBox<T extends Fruit> extends Box {   
}
```

만약 Fruit의 자식이면서 Eatable 인터페이스도 구현해야한다면? 
`&` 키워드로 연결한다. 
```java 
public class FruitBox<T extends Fruit & Eatable> extends Box {   
}
```

 ### 와일드 카드 
 제너릭으로 구현된 메소드의 경우 선언된 타입으로만 매개변수를 입력해야 한다. 
 이를 상속받는 클래스나 부모 클래스로 사용하고 싶어도 불가능하고 어떤 타입이 와도 상관없는 경우에도 대응하기 좋지 않다. 
 이를 해결하기 위해 와일드 카드를 사용한다. 
> 제너릭이 불공변이기 때문에 사용한다는 관점도 있다. 

#### Unbounded WildCard 
`List<?>`와 같은 형태로 물음표만 가지고 정의된다. 즉, 별도의 상하관계 없이 사용하게 된다. 
- 내부적으로 Object로 정의되어서 사용하고 있는 모든 타입의 인자를 받을 수 있다. 
- 타입 파라미터에 의존하지 않는 메서드만을 사용하거나 Object 메서드에서 제공하는 기능으로 충분한 경우 사용하게 된다.

#### Upper Bounded WildCard 
`List<? extends Foo>` 의 형태로 사용한다. 
특정 클래스의 하위 클래스만을 인자로 받는다는 의미이다. 이를 통해 상한 경계라고 부른다. 
특정 클래스의 하위 클래스만을 인자로 받기 때문에 꺼내는 것은 가능하지만 저장하는 것은 불가능하다.

#### Lower Bounded WildCard 
`List<? super Foo>`의 형태로 사용한다. 
특정 클래스의 상위 클래스만을 인자로 받는다는 의미이다. 이를 하한 경계라고 부른다. 
특정 클래스의 상위 클래스만을 인자로 받기 때문에 저장하는 것은 가능하지만 꺼내는 것은 불가능하다. 

#### 어떤 와일드 카드를 언제 사용해야 할까? 
PECS공식이라는 것이 있다. 
Producer-Extends, Consumer-Super의 약자로, 생산자는 extends, 소비자는 super을 쓰라는 것이다. 

## Lambda 
메서드를 하나의 식으로 표현한 것으로 함수의 이름이 없기 때문에 익명 함수라고도 한다. 
함수적 프로그래밍을 쉽게 지원하기 위해 자바 8부터 지원하며 이런 코드들은 런타임시에 인터페이스의 익명 구현 객체로 생성된다. 대입될 인터페이스의 종류에 따라 작성 방법이 달라 지기 때문에 람다식이 대입될 인터페이스를 람다식의 타겟 타입이라고 부른다. 

### 함수적 인터페이스 
인터페이스 내부 추상 메서드가 1개인 경우에만 람다식을 이용해 구현 객체를 생성할 수 있다. 
이러한 인터페이스를 함수적 인터페이스라고 하며 구체적으로 명시하기 위해 `@FunctionalInterface` 어노테이션을 사용한다. 만약, 추상 메서드가 두 개 이상 선언될 경우 컴파일 에러를 발생시키는 역할을 한다. 

### 람다식에서의 지역 변수 사용 
람다식에서 바깥 클래스의 필드는 제한없이 사용할 수 있으나, 메서드의 매개변수 또는 지역변수를 사용하려면 final 특성을 가지고 있어야 한다. 즉, 메서드의 매개 변수 또는 지역 변수를 람다식에서 읽는 것은 허용되지만, 람다식 내부 또는 외부에서 변경할 수 없다는 것이다. 

#### 람다 캡쳐링 
람다식의 매개 변수가 아닌 외부에서 정의된 변수를 자유 변수라고 부르며 람다 바디에서 자유 변수를 참조하는 행위를 람다 캡쳐링이라고 한다. 
이때 자유 변수가 인스턴스 변수거나 정적 변수일 경우 캡처링을 원할하게 수행할 수 있지만 지역 변수가 final이거나 effectively final이 아닐 경우 문제를 야기할 수 있다. 

람다는 지역 변수가 존재하는 스택 영역에 직접 접근하는 것이 아닌 지역 변수를 자신 즉, 람다식이 동작하는 스레드의 스택에 복사하여 사용한다. 이러한 이유 때문에 지역 변수가 존재하는 스레드가 사라져도 람다는 복사된 값을 참조하면서 에러가 발생하지 않는다. 
하지만 만약 멀티 스레드 환경에서 여러 개의 스레드가 동일한 람다식을 사용한다면 어떻게 될가? 여러 개의 스레드가 람다식을 사용하면서 람다 캡쳐링을 진행하게 되는 데, 외부 변수가 변한다면 값이 계속해서 변하기 때문에 동기화 문제가 발생하게 된다. 이러한 이유로 자유 변수로 지역 변수를 택할 경우, 그 변수는 final 속성을 지녀야 한다. 

만약 인스턴스 변수나 정적 변수를 자유 변수로 선택할 때는 어떻게 될까? 두 변수 모두 스택 영역이 아닌 힙 영역에 위치하게 되고, 람다식을 사용하는 스레드 측에서는 항상 참조할 수 있게 된다. 힙 영역은 모든 스레드가 공유하고 있는 메모리 영역이기 때문이다. 따라서 자유 변수로 인스턴스 변수나 정적 변수를 택할 경우, 그 변수는 final 속성을 가질 필요가 없다. 


### 메서드 참조 
> 메서드를 참조해서 매개 변수의 정보 및 리턴 타입을 알아내어, 람다식에서 불필요한 매개 변수를 제거하는 것 

#### 1. 정적 메서드 참조 
클래스 이름 뒤에 더블 콜론 연산자인 `::`기호를 붙이고 정적 메서드 이름을 기술한다. 
`클래스::메서드` 와 같은 형식이다.

### 2. 인스턴스 메서드 참조 
객체를 생성한 다음 참조 변수 뒤에 ::기호를 붙이고 인스턴스 메서드 이름을 기술한다. 
`참조변수::메서드`와 같은 형식이다.

#### 3. 생성자 참조 
단순히 객체를 생성하고 리턴하도록 구성된 람다식은 생성자 참조로 변환할 수 있다.
`(a,b) -> new Studnet(a,b)`를 `Studnet::new`로 바꿀 수 있다. 


## Stream 
자바 8부터 추가된 컬렉션의 저장 요소를 하나씩 참조해서 람다식으로 처리할 수 있는 반복자이다. 

### 특징 
#### 1. 람다식으로 요소 처리 코드를 제공한다. 
스트림은 람다식 또는 메서드 참조를 이용하기 때문에 코드가 간결해지는 장점이 있다.

#### 2. 원본 데이터를 변경하지 않는다. 
Stream API는 원본의 데이터를 조회하여 원본의 데이터가 아닌 별도의 요소들로 Stream을 생성한다. 그렇기 때문에 원본의 데이터로부터 읽기만 할 뿐이며, 정렬이나 필터링 등의 작업은 별도의 Stream 요소들에게 처리가 된다. 

#### 3. 내부 반복자를 사용하므로 병렬 처리가 쉽다. 
외부 반복자란 개발자가 코드로 직접 컬렉션의 요소를 반복해서 가져오는 코드 패턴을 말한다. for문, Iterator를 사용하는 while문은 모두 외부 반복자를 이용하는 것이다. 

내부 반복자란 컬렉션 내부에서 요소들을 반복시키고, 개발자는 요소당 처리해야 할 코드만 제공하는 코드 패턴을 말한다. 즉, 컬렉션 내부에서 어떻게 요소를 반복시킬 것인가는 컬렉션에게 맡겨두고, 개발자는 요소 처리 코드에만 집중하는 것이다. 
내부 반복자는 요소들의 반복 순서를 변경하거나, 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜 병렬작업을 할 수 있게 도와주기 때문에 하나씩 처리하는 순차적 외부 반복자보다는 효율적으로 요소를 반복시킬 수 있다.
> 병렬 처리 
> 한 가지 작업을 서브 작업으로 나누고, 서브 작업들을 분리된 스레드에서 병렬적으로 처리하는 것을 말한다. 


#### 4. 중간 처리와 최종 처리를 할 수 있다. 
컬렉션의 요소에 대해 중간 처리와 최종 처리를 수행할 수 있다. 
- 중간 처리 
	- 매핑, 필터링, 정렬 수행 
- 최종 처리 
	- 반복, 카운팅, 평균, 총합 등의 집계 처리를 수행

### Stream의 파이프라인 
![](https://i.imgur.com/T0pcBL1.png)
스트림은 데이터의 필터링, 매핑, 정렬, 그룹핑 등의 중간 처리와 합계, 카운팅, 최대값 등의 최종 처리를 파이프라인으로 해결한다. 
파이프라인은 여러 개의 스트림이 연결되어 있는 구조를 말하며, 파이프라인에서 최종 처리를 제외하고는 모두 중간 처리 스트림이다. 
중간 스트림이 생성될 때 요소들이 바로 중간 처리되는 것이 아니라 최종 처리가 시작되기 전까지 중간 처리는 지연되게 된다. 즉, 최종 처리가 시작되면 비로소 컬렉션의 요소가 하나씩 중간 스트림에서 처리되고 최종 처리까지 오게 되는 것이다.

### 주의점 
#### Stream 재사용 
스트림은 오직 한번만 사용할 수 있기 때문에 스트림을 컬렉션처럼 사용하면 IllegalStateExpcetion이 발생한다. 

#### for-loop보다 느리다. 
단순 for-loop의 경우 오버헤드가 없는 단순한 인덱스 기반 메모리 접근이기 때문에 Stream을 사용했을 때보다 더 빠르다. 또한, JIT 컴파일러가 오랫동안 유지해온 for-loop에 대한 내부 최적화가 잘 되어 있는 반면 Stream은 2015년 이후에 도입되었으므로 최적화를 제대로 하지 못했다.

#### 변수 접근 
스트림을 이용하면서 람다 또는 메서드 참조를 사용하는 경우에는 지역 변수에 접근할 수 없다. 

#### Stream 동작 순서 
Stream의 동작 순서에대해 알지 못하면 성능 이슈가 발생할 수 있다. 그렇기에 Stream이 어떻게 동작할 것인지 정확히 이해하고 사용하는 것이 중요하다.


## Reflection 
> 접근 제어자와 상관 없이 클래스 객체를 동적으로 생성하는(런타임 시점) Java API
> 즉, 구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API이다.

힙 영역에 로드된 Class 타입의 객체를 통해, 원하는 클래스의 인스턴스를 생성할 수 있도록 지원하고, 인스턴스의 필드와 메서드를 접근 제어자와 상관 없이 사용할 수 있도록 지원하는 API이다.
여기서 로드된 클래스라고 함은, JVM의 클래스 로더에서 클래스 파일에 대한 로딩을 완료한 후, 해당 클래스의 정보를 담은 Class 타입의 객체를 생성하여 메모리의 힙 영역에 저장해둔 것을 의미한다.
참고로, Java는 정적 언어이기 때문에 컴파일 시점에 객체 타입을 결정한다. 


### 사용법 
힙 영역에 로드된 클래스 타입의 객체를 가져오기 위해 3가지 방법이 있다. 
- 클래스.class
- 인스턴스.getClass() 
- Class.forName("클래스명")
어떤 방식을 사용하든 해시 값이 같으므로 상황에 따라 적절하게 사용하면 된다. 
가져온 Class 타입을 통해 해당 클래스의 인스턴스를 생성할 수 도 있고, 인스턴스의 ㅍ리드와 메서드를 접근 제어자와 상관 없이 사용할 수 있다.



### 장단점 
- 장점 
	- 런타임 시점에 클래스의 인스턴스를 생성하고, 접근 제어자와 관계 없이 필드와 메서드에 접근하여 필요한 작업을 수행할 수 있는 유연성을 가지고 있다. 
- 단점 
	- 캡슐화를 저해한다. 
	- 런타임 시점에서 인스턴스를 생성하므로 컴파일 시점에서 해당 타입을 체크할 수 없다. 
	- 런타임 시점에서 인스턴스를 새엉하므로 구체적인 동작 흐름을 파악하기 어렵다. 
	- 단순히 필드 및 메서드를 접근할 때보다 리플렉션을 사용하여 접근할 때 성능이 느리다. (모든 상황에서 그렇다는 것은 아니다.)

### 사용하는 이유 
프레임워크와 같이 큰 규모의 개발 단계에서는 수많은 객체와 의존 관계를 파악하기 어렵다. 이때 리플렉션을 사용하면 동적으로 클래스르 만들어서 의존 관계를 맺어줄 수 있따. 
Spring의 Bean Factory를 보면, @Controller, @Service, @Repository 등의 어노테이션만 붙이면 Bean Factory에서 알아서 해당 어노테이션이 붙은 클래스를 생서앟고 관리해준다. 이것이 가능한 이유는 리플렉션으로 런타임에 해당 어노테이션이 붙은 클래스를 탐새갛고 발견한다면, 리플렉션을 통해 해당 클래스의 인스턴스를 생성하고 필요한 필드를 주입하여 Bean Factory에 저장하는 식으로 사용이 된다. 
하지만 캡슐화 저해 등 여러 단점이 많기 때문에 꼭 필요한 상황에서만 사용해야 한다.


### 특징 
ObjectMapper나 Spring Data JPA에서 Entity는 기본 생성자가 필요하다. (사실 하이버네이트 같은 구현체들은 바이트 코드를 조작하는 라이브러리 등을 통해 이런 문제를 회피하지만 완벽한 해결책이 아니다.)
Reflection이 가져올 수 없는 정보 중 하나가 바로 생성자의 인자 정보들이다. 그렇기에 기본 생성자 없이 파라미터가 있는 생성자만 존재한다면 Reflection이 객체를 생성할 수 없게 되는 것이다. 
그렇다면 생성자의 인자 정보를 가져오지 못한다면 인자가 있는 생성자로 객체 생성을 어떻게 하는 것일까? 
그 이유는 기본 생성자로 객체를 생성하기만 하면 필드 값 등은 리플렉션으로 넣어줄 수 있기 때문이다. 그렇기 때문에 Spring Data JPA에서 Entity에 기본 생성자가 필요한 이유도 동적으로 객체 생성 시 리플렉션을 사용하기 때문이다.


## Dynamic Proxy
프록시는 타겟 코드의 수정없이 접근제어 혹은 부가기능을 추가하기 위해 주로 사용된다. 
하지만, 프록시를 사용하기 위해서는 대상 클래스 수만큼의 프록시 클래스(인터페이스 구현체 혹은 상속 클래스) 를 하나하나 만들어줘야 하고 그 안에 들어가는 반복 코드때문에 코드중복이라는 단점이 있다. 
이러한 단점들을 보완하여 컴파일 시점이 아닌, 런타임 시점에 프록시 클래스를 만들어주는 방식이 동적 프록시이다.

### 활용 
```java 
@CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
```
Java에서 제공해주는 Reflection API의 newProxyInstance() 메서드를 통해 프록시 객체를 생성할 수 있다. 이를 통해 대상 클래스 수만큼 프록시 클래스를 만들어야 하는 단점을 해결해준다. 3가지 인자 중 InvocationHandler를 통해 중복 코드의 단점을 해결해준다. 

```java 
public interface InvocationHandler { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; }
```
InvocationHandler는 invoke() 메서드만 가지고 있는 인터페이스이다. 
invoke 메서드는 런타임 시점에 생긴 동적 프록시의 메서드가 호출되었을 때 실행되는 메서이고, 어떤 메서드가 실행되었는 지 메서드 정보와 메서드에 전달된 인자까지 invoke() 메서드의 인자로 들어오게 된다.
즉, invoke 메서드에 프록시만 사용할 당시, 프록시 클래스마다 들어간 반복된 코드를 한번만 작성함으로써 중복 코ㄷ의 단점을 해결해주게 된다.
