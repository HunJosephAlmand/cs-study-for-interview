## 제어자 
> 클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미를 부여한다. 
> static, public 등와 같은 키워드 

### 접근 제어자 
![](https://i.imgur.com/l67qW5y.png)
해당 클래스 또는 멤버를 정해진 범위에서만 접근할 수 있도록 통제하는 역할을 한다. (캡슐화, 정보은닉)
- 클래스는 public과 default만 사용할 수 있다. 
- private인 경우 같은 클래스의 객체끼리는 서로 접근이 가능하다.
- proteced의 경우 상속 관계 외에도 같은 패키지라면 접근이 가능하다.


### static 
정적 변수와 정적 메서드를 만들 수 있다. 
이렇게 만들어진 정적 변수나 정적 메서드는 프로그램이 종료되기 전까지 사용할 수 있고, GC에 의해 수집되지 않는다. (정적 객체는 GC에 의해 수집될 수 있다.)
프로그램이 시작되는 시점에 클래스 로더가 클래스를 해석하여 메소드 영역 혹은 힙 영역에 클래스 메타 데이터 및 정적 변수를 적제한다. 

#### static이 저장되는 위치 
- Permanent 
	- Java8 이전까지 존재한 메소드 영역 
	- 클래스 내부의 메타 데이터를 저장하는 영역
	- Heap 영역에 속하며 클래스, 메소드 메타 데이터, 정적 객체, 상수 풀 등을 관리했다. 
	- Java8 이후부터는 Metaspace 영역으로 대처되었다. 
	- 특이하게 Heap 영역 안에 존재했던 메소드 영역이다.
- Metaspace 
	- Java8 부터 생긴 영역으로 Permanent 영역이 관리하던 일부 정보를 저장한다. 
	- 메소드 영역이 아닌 네이티브 메모리 영역으로서 JVM이 아니라 OS에서 관리한다. 
	- 메소드 영역이 네이티브 메모리 영역에 포함된다.

Java 8이전의 힙에는 Permanent 영역이 존재한다. Permanent 영역은 메소드 영역에 해당하므로 Java8 이전 static 변수는 메소드 영역에 저장되는 것이 맞다. 
하지만 Java 8이후의 힙에서는 Permanent 영역이 사라지며 대신 힙 외부에 Metaspace라고 하는 네이티브 메모리가 Permanent가 저장하던 정보를 들고 있도록 변경되었다. (모든 정보를 Metaspace에서 관리하는 것은 아니다.)
Permanent 영역에서 관리하던 클래스 메타 데이터는 Metaspace로 옮겨지고 interned String과 클래스 정적 변수는 힙 영역에 옮겨졌다. 즉, Java 8 이후부터는 static을 힙 영역에서 관리하게 된다. 

#### Permanent 영역이 사라진 이유 
각종 클래스 메타 데이터를 힙 영역에서 관리하다 보니, 힙 영역에 들어간 데이터의 사이즈 를 계산하기 어려워서 OOM이 자주 발생하곤 했다. 그렇기 때문에 클래스 메타 데이터는 네이티브 메모리에서, 정적 변수만 힙 영역에서 분리하여 관리하도록 한 것이다.


#### 언제 사용해야 할까? 
static은 메모리 문제, 동시성 이슈, 런타임 다형성 불가, 객체의 상태 이용, 테스트 어려움 등 여러 문제점을 가지고 있다. 
그렇다면 언제 사용해야 할까? 
- 상수 정의 
	- 상수를 일반 변수로 정의하는 것보단 한 번 정적 변수로 정의하면 메모리를 아낄 수 있다.
- 유틸리티 클래스 정의 
	- 상태 이용을 하지 않고, 여러 객체들의 필요에 의해 데이터를 처리하는 공통 로직이 필요할 때 사용


### final 
클래스, 변수, 메서드 단에 사용할 수 있다. 

#### 클래스 
해당 클래스는 상속을 허용하지 않는다. (하위 클래스를 만들 수 없다.)

#### 변수 
변경 불가능한 상수가 된다. 
- 정적 상수 (static final) : 선언이나 static 블록에서 초기화 가능 
- 객체 상수 : 선언이나 객체 생성자 또는 인스턴스 블록에서 초기화 가능 
- 지역 상수 : 선언이나 최초 한번만 초기화 가능

#### 메서드 
재정의 즉, 오버라이딩을 금지한다. 


### abstract 
- 클래스 앞에 붙으면 추상 클래스가 되어 객체 생성이 불가하고, 접근을 위해선 상속 받아야 한다. 
- 메서드 앞에 붙는 경우는 오직 추상 클래스 내에서의 메서드밖에 없으며 해당 메서드는 선언부만 존재하고 구현부는 상속한 클래스 내 메서드에 의해 구현되어야 한다. 
- 변수 앞에는 지정할 수 없다.


## 클래스, 객체, 인스턴스 차이 
### 클래스 
객체를 정의해놓은 것으로 객체를 생성하는 데 사용한다. 
객체를 정의하기 위한 속성과 기능으로 구성된다. 

### 객체 
소프트웨어 세계에 구현할 대상 
물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른것과 식별 가능한 것
클래스의 인스턴스라고 부른다. 

### 인스턴스 
어떤 클래스로부터 만들어진 객체를 그 클레스의 **인스턴스**라고 한다. 
즉, 인스턴스는 객체를 생성하여 메모리가 할당되어 있는 상태라고 할 수 있다.

## Primitive type vs Reference type
### Primitive type 
![](https://i.imgur.com/VAg3Oci.png)

종류가 총 8가지 타입이 있으며 크게 논리형, 문자형, 정수형, 실수형으로 구분된다. 
-   JVM의 피연산자 스택(operand stack)이 피연산자를 4byte단위로 저장하기 때문에 크기가 4 byte보다 작은 자료형(byte, short)을 계산할 때는 4 byte로 변환하여 연산이 수행되기 때문에 int형을 쓰는 것이 효율적이다.

### Reference type 
![](https://i.imgur.com/xCGMqJa.png)
객체의 주소를 저장한다. 기본적으로 Java.lang.Object를 상속받을 경우 참조형이 된다. 즉, 기본형을 제외하고는 모두 참조형이다. 
![](https://i.imgur.com/poQ27Q6.png)
참조형의 실제 인스턴스는 힙 영역에 생성되고, 그 영역의 주소를 스택 영역에서 저장하고 있다.


## Wrapper Class
![](https://i.imgur.com/oSkpz7I.png)
Primitive type으로 표현할 수 있는 데이터를 객체로 만들어야하는 경우에 사용하기 클래스이다.
- `박싱` : Primitive type -> Wrapper Class (직접)
- `언박싱` : Wrapper Class -> Primitive type (직접)
- `오토박싱` : Primitive type -> Wrapper Class (자동변환 , 컴파일러)
- `오토언박싱` : Wrapper Class -> Primitive type (자동변환) 
	-   메서드에서 `primitive` 타입으로 매개변수를 받을 때, 매개변수로 전달되는 경우
	-   해당 `primitive` 타입의 변수에 할당되는 경우
> null을 지정하기 위해서나 제너릭에서 활용하기 위해서 사용하는 것 같다.


## Overloading vs Overriding

### 메소드 시그니처 
메소드의 선언부에 명시되어 있는 매개변수의 리스트를 가르킨다. 
다음과 같은 조건을 만족해야 같은 시그니처를 가진다고 할 수 있다. 
- 메소드 이름 
- 매개변수 수 
- 매개변수 타입의 순서 
리턴타입은 고려하지 않는다.



### Overloading 
같은 이름의 메소드를 중복하여 정의하는 것을 의미한다. 즉, 서로 다른 시그니처를 갖는 여러 메소드를 같은 이름으로 정의하는 것이다.
대표적인 예로는 println() 메소드와 생성자 오버로딩을 들 수 있다. 
생성자 오버로딩의 경우 동일한 이름을 가진 메소드들의 매개변수의 타입 또는 개수 모두가 달라져야 한다. 

#### 장점 
- 메소드의 이름을 몇가지만 기억하면 된다. 
- 기능 예측이 쉬워진다. 
- 메소드의 이름을 절약할 수 있다. 
- 매개변수 값을 다양하게 받아서 다양한 처리가 가능하다. 
- 소스코드의 가독성이 좋아진다. 

#### 단점 
 -   비슷한 기능이 아닌 메소드들을 동일한 이름으로 사용하여 공동으로 개발할 경우, 다른 개발자들에게 오히려 혼동을 줄 수 있다.


### Overriding
상위 클래스의 메소드를 하위 클래스에서 재정의하는 것이다. 
즉, 상속 관계에 있는 클래스 간에 같은 이름의 메소드를 정의하는 기술이다.

- 부모 클래스의 메소드와 동일한 시그니처를 가져야 한다. 
- 접근 제어자는 부모클래스의 메소드보다 좁은 범위로 변경할 수 없다. 
	- 변경가능하다면 리스코프 치환 원칙에 위배된다.
- 부모 클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.

#### 필요성 
자식 클래스에서 상황에 맞게 변경해야하는 경우 필요가 생긴다. 
만약 오버라이딩을 하지 않고 다른 이름으로 정의할 경우 부모 클래스의 메소드를 사용할 수 있기 때문에 문제가 발생할 수 있다. 알맞지 않은 기능은 사용하지 못하도록 해주기 위해 오버라이딩을 사용해야 한다.
다형성을 위해 사용한다.


## 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)

### 메소드 디스패치
메소드 디스패치는 어떤 메소드를 호출할지 결정하여 실행시키는 과정을 말한다. 이 과정은 static(정적)과 dynamic(동적)이 있다.

### 정적 메소드 디스패치(Static Method Dispatch)
컴파일 시점에, 컴파일러가 특정 메소드를 호출할 것이라고 명확하게 알고있는 경우이다.

```java
public class Parent {
    void run() {
        System.out.println("Parent.run()");
    }
}

public class Child extends Parent {
    @Override
    void run() {
        System.out.println("Child.run()");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent p = new Parent();
        Child c = new Child();

        p.run();  // Parent.run()
        c.run();  // Child.run()
    }
}
```

위의 코드는 모두 컴파일 시점에 어떤 메소드를 실행해야할 지가 결정이 끝나고 그대로 실행된다.

### 동적 메소드 디스패치(Dynamic Method Dispatch)

정적 디스패치와 반대로 컴파일러가 어떤 메소드를 호출하는지 모르는 경우이다. 동적 디스패치는 호출할 메서드를 런타임 시점에서 결정한다.

```java
abstract class Parent {
    abstract void run();
}


public class Child1 extends Parent {
    @Override
    void run() {
        System.out.println("Child1.run()");
    }
}

public class Child2 extends Parent {
    @Override
    void run() {
        System.out.println("Child2.run()");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent p1 = new Child1();
        p1.run();  // Child1.run()

        p1 = new Child2();
        p1.run();  // Child2.run()
    }
}
```

위 코드에서 컴파일시에는 p1과 p2의 run이 어떤 인스턴스의 메소드인지 모른다. 앞써 우리는 **"컴파일시에는 실행 시 생성될 인스턴스의 타입에 대해서는 알지 못한다."**라고 배웠다. 즉, p1과 p2 모두 컴파일시에는 그저 Parent의 run()을 호출하면 되겠구나 하고 있는 것이다. 하지만 런타임으로 들어가게 되면 인스턴스의 타입을 통해 어떤 메소드를 실행해야 하는 지가 결정된다.




## Call by Reference vs Call by Value
### Call by value 
- 메소드를 호출할 때 넘겨주고 싶은 변수를 지정하면, 메소드의 매개변수가 지정한 변수 값의 **복사본**으로 초기화되는 것이다.
- 즉, 함수 내에서의 변경은 메소드를 호출할 때 지정한 변수(원본)에 아무 영향을 미치지 않는다.


### Call by Reference 
- 메서드를 호출할 때 넘겨주고 싶은 변수를 지정하면, 메소드의 매개변수가 지정한 변수의 **래퍼런스**로 초기화하는 것이다.
- 즉, 함수 내에서의 변경은 메소드를 호출할 때 지정한 변수(원본)에 영향을 미친다.

### 그렇다면 자바는? 
결론적으로 자바는 Call by Value이다. 
```Java
public class Number {
    int value;

    public Number(int value) {
        this.value = value;
    }
}

public class NumberMain {

    public static void main(String[] args) {
        Number one = new Number(1);
        Number two = new Number(2);

        run(one, two);

        System.out.println(one.value);
        System.out.println(two.value);
    }

    public static void run(Number argOne, Number argTwo) {
        argOne.value = 111;
        argTwo = argOne;
    }
}

================================
111
2
```
![](https://i.imgur.com/Lxl8QOZ.png)
해당 예제에서 one의 value가 111로 변경이 되었다. 이것만 보고 one의 value를 변경하니 원본 one의 값도 변경되었으니 이것을 call by reference라고 헷갈리는 것이다. 하지만 one에서 argOne으로 매개변수를 넘기는 과정에서 직접적인 참조를 넘긴 것이 아닌, **주소 값을 복사해서 넘기기 때문에 이는 call by value**가 된다. 복사된 주소 값으로 참조가 가능하니 주소 값이 가리키는 객체의 내용이 변경되는 것이다.
그렇기 때문에 run 메소드에서 argTwo에 argOne의 값을 저장한다고 해도 이는 run 메소드 내에 존재하는 argTwo가 argOne이 가진 주소값을 복사하여 저장하는 것일 뿐 원본 two와는 독립된 변수이기 때문에 two의 value는 변경되지 않는 것이다.

즉, 자바에서 매개변수를 넘기는 과정에 직접적인 참조를 넘긴 게 아닌, 주소 값을 복사해서 넘기기 때문에 이는 call by value이다.




## interface vs abstract class
### abstract class 
> 추상메서드를 포함하고 있는 클래스 (추상메서드가 없어도 `abstract`를 붙여 추상클래스로 지정할 수도 있다.)

추상 클래스는 객체의 명세의 역할을 하며, 실체 클래스의 공통적인 상태를 모아 규격을 잡아 놓은 추상적인 클래스다.
- `abstract`키워드를 사용하며 추상클래스로 인스턴스는 생성할 수 없고 상속을 통해서 자손클래스에 의해서만 완성될 수 있다.
- 추상메서드로 선언된 것은 각 클래스에 알맞게 반드시 구현해야 한다는 강제성을 부여하는 것이다.
- 상속하는 집한 간에 연관 관계가 있다. (is - a 관계 )
- 다중 상속이 불가능 하다.

### Interface 
> 일종의 추상 클래스 

인터페이스는 구현된 것은 아무 것도 없고, 밑그림만 그려져 있는 객체의 명세 혹은 설계도라고 표현할 수 있다.
추상 클래스처럼 완성되지 않은 불안전한 것이기 때문에 그 자체만으로 사용되기 보다는 다른 클래스를 작성하는 데 도움을 줄 목적으로 작성된다.

- 모든 멤버 변수는 `public static final`이어야 하며, 생략할 수 있다.
- 모든 메서드는 `public abstract` 이어야 하며, 생략할 수 있다. (private, static, default 메서드 제외)
- Java8부터는 static, default 메서드를 사용할 수 있다.
	- 자바 9부터는 private 메서드를 사용할 수 있다.
- has - a 관계이다. 
- 다중 상속이 가능하다. 

#### Interface 메서드 
default 메서드 
- 자바8에서 추가되었다. 
- 추상 메서드의 기본적인 구현을 제공하는 메서드
- 형태는 클래스의 인스턴스 메서드와 동일하며, default 키워드가 리턴 타입 앞에 붙는다. 
- public 특성을 가지며 생략이 가능하다. 
- 추가적으로 구현해야 하거나 필수적으로 존재햐야 할 메소드가 있을 시 사용하여 하위 호환성은 유지되고 인터페이스의 보완을 지킬 수 있다. (구현 클래스의 변경이 필요없다.)
- 재정의가 가능하다.

static 메서드 
- 자바8에서 추가되었다. 
- 객체가 없어도 인터페이스만으로 호출이 가능하며, 상속이 불가능하다.

private 메서드 
- 자바 9에서 추가되었다.
- 코드의 중복을 피하고 인터페이스에 대한 캡슐화를 유지시켜 준다.

### 그래서 차이점은? 
인터페이스와 추상 클래스의 공통점은 추상 메서드를 사용할 수 있다는 점이다. 
그렇다면 어떤 상황에서 무엇을 사용해야 할까? 

#### 다중상속 여부 
- 인터페이스를 구현하는 클래스는 다른 여러개 인터페이스를 함께 구현할 수 있다. 
- 추상 클래스는 다중상속을 지원하지 않기 때문에 여러 추상 클래스를 상속할 수 없다. 

#### 상태 유무 
- 추상 클래스는 상태를 가질 수 있다. 
- 인터페이스는 상태를 가질 수  없다. 

#### 사용 의도 
- 추상 클래스는 공통된 개념에 초점을 맞춘다.
	- is - a 관계이며 부모 클래스가 가진 기능들을 구현해야 할 때 사용한다. 
- 인터페이스는 공통된 기능에 초점을 맞춘다.
	- has a 관계이며 다른 부모 클래스를 상속하더라도 같은 기능이 필요할 경우 사용한다.


## Checked Exception vs UnChecked Exception

### 에러 (Error)
시스템에 무엇인가 비정상적인 상황이 발생한 경우 
애플리케이션 코드로 처리 불가능 
ex) OutOfMemoryError, StackOverflowError 등 

### 예외 (Exception) 
입력 값에 대한 처리가 불가능하거나, 프로그램 실행 중에 참조된 값이 잘못된 경우 등 정상적인 프로그램의 흐름을 어긋나는 것
개발자가 직접 처리할 수 있기 때문에 예외 상황을 미리 예측하여 핸들링할 수 있다.


![](https://i.imgur.com/G10gAjC.png)

### Unchecked Exception 
명시적인 예외 처리를 강제하지 않는다. 
RuntimeExcpetion을 상속한 예외이다.

### Checked Exception 
명시적인 예외 처리를 강제한다. (예외 복구, 예외 처리 회피, 예외 전환)
반드시 try-catch로 예외를 잡거나 throw로 호출한 메소드에게 예외를 던져야 한다. 
RuntimeException을 상속하지 않은 예외이다.

- 예외 복구 
	- 예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 방법
- 예외 처리 회피 
	- 예외 처리를 직접 담당하지 않고 호출한 쪽으로 던져 회피하는 방법 (throws)
- 예외 전환 
	- 적절한 예외로 전환해서 넘기는 방법

### 차이점 
![](https://i.imgur.com/QoT45jY.png)
여기서 트랜잭션 처리는 스프링의 `@Transactional` 처리의 기본 설정을 뜻한다. 자바의 기본 설정은 아니다!!!
Checked Exception은 복구가 가능하다는 메커니즘이기 때문에 스프링에서 그렇게 설정하지 않았을 까? 생각해본다.



