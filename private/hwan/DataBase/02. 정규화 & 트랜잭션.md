## 이상 현상 (Anomaly)
> 일부 속성들의 종속이나 데이터의 중복으로 인해 데이터 조작시 불일치가 발생하는 것

- 삽입 이상 
	- 불필요한 데이터를 추가해야지 삽입할 수 있는 상황 
	- 수강테이블에 수강하지 않는 학생은 미수강과 같은 수강 데이터를 추가해야함. ( 기본키 null 값 회피를 위해 )
- 갱신 이상 
	-  중복된 튜플 중 일부의 속성만 갱신 시킴 으로써 데이터 불일치가 발생하는 문제
	- 학생의 전공을 컴퓨터에서 음악으로 바뀌는 경우 모든 전공 레코드가 음악으로 바뀌어야 하지만 실수로 변경하지 못하는 경우
- 삭제 이상 
	- 튜플을 삭제함으로써 유지되어야 하는 정보까지도 연쇄적으로 삭제되는 문제 
	- 학생이 수강을 철회하는 경우 수강 정보와 함께 학생 정보도 제거되는 경우


## 정규화
> 릴레이션간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정

정규화 과정은 결국 정규형 원칙을 기반으로 정규형을 만들어가는 과정이며, 가장 큰 목표는 테이블 간 중복된 데이터를 허용하지 않는 것이다. 
기본 정규형인 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형이 있으며 고급 정규형인 제4정규형, 제5정규형이 있다. 

### 정규화 원칙 
- 더 좋은 구조로 만든다 
- 데이터의 중복을 없애면서 불필요한 데이터는 최소화한다 
- 독립적인 관계는 별개의 릴레이션으로 표현한다 
- 각각의 릴레이션은 독립적인 표현이 가능해야 한다 

### 제1정규형 
릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자값만으로 구성되어야 한다. 
릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안 된다. 만약 있다면 제거해야 한다.
`민환, {취포,화이팅}` --> `민환, 취포 / 민환, 화이팅`

### 제2정규형 
릴레이션은 제1정규형이며 부분 함수의 종속성을 제거한 형태 
부분 함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말한다. (기본키의 부분집합 키가 결정자가 되어선 안된다는 것)
> 완전함수 종속 : 어떤 속성이 기본키에 대해 완전히 종속적인 경우 
```
{유저번호, 유저ID, 수강명, 성취도}
PK - 유저ID, 수강명 
성취도 - 기본키에 완전 종속 
유저번호 - 유저ID에 의해 결정? (부분 함수 종속)

---> 

{유저ID, 수강명, 성취도} / {유저번호, 유저ID}
```

### 제3정규형 
제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태 
기본키가 아닌 속성들은 기본키에 의존한다. 

> 이행적 함수 종속 
A -> B, B -> C면 A -> C가 성립하는 데, 이 때 집합 C가 집합 A에 이행적으로 함수 종속도이었다고 한다. 

```
{유저ID, 등급, 할인율}

등급은 유저ID에 의해 결정 
할인율은 등급에 의해 결정

---> 

{유저ID, 등급} , {등급, 할인율}
```

### 보이스/코드 정규형 
제3정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태 
> 결정자 : 함수 종속 관계에서 특정 종속자를 결정짓는 요소 
> X -> Y일 때 X는 결정자, Y는 종속자이다.
> 후보키 : 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족 해야 하는 키
```
{학번, 수강명, 강사}

{학번,수강명} -> 강사 
강사 -> 수강명

--->

{학번, 강사} / {수강명, 강사}
```

### 제 4정규형 
보이스/코드 정규형이고, 다치 종속성을 제거하도록 분해한 상태 
> 다치종속 : 릴레이션 내 두 어트리뷰트 집합 사이 성립하는 제약조건 중의 하나이며, 두개의 독립된 어트리뷰트가 1:N관계로 대응하는 관계 
> 즉, 릴레이션 R의 속성 X,Y,Z가 있을 때 (X, Y)에 대응하는 Z의 집합이 X값에만 종속되고, Y값에 무관하면 Z는 X에 다치종속이라고 한다.
```
{학생번호, 특별활동, 전공}

학생번호 ->> 특별활동, 학생번호 ->> 전공 

--->

{학생번호, 특별활동} / {학생번호, 전공} 
```

### 제 5정규형 
제 4정규형이고, 조인 종속성을 없앤 것이다. 
> **조인 종속(JD ; Join Dependency)** : 하나의 릴레이션을 여러개의 릴레이션으로 분해하였다가, 다시 조인했을 때 데이터 손실이 없고 원래의 테이블과 동일하게 복원되는 제약조건
```
{사원, 기술, 언어}

---> 

{사원, 기술} / {사원, 언어} / {기술, 언어}
```

### 장점 
- 이상 문제 해결 
- 테이블 간 중복 데이터를 허용하지 않고 DB 용량 감소 
- 데이터 저장을 논리적으로 가능 

### 단점 
- 릴레이션 간의 JOIN 연산 증가에 의해 질의에 대한 응답 시간 저하 

## 역정규화
> 논리적 정규화를 통해 만든 릴레이션을, 성능이나 편의성을 위해 되돌아가는 작업
-   JOIN 줄이기
-   계산 작업 줄이기 (group by 부하 등 )
-   테이블 분리
    -   컬럼 기준 (하나의 컬럼이 많은 용량을 차지 할 때)
    -   행 기준 (많은 행이 있을 때 분리하여 각기 다른 테이블로 접근해서 부하를 줄임)
-   외래키 줄이기


## 트랜잭션 
### 트랜잭션이란? 
> 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위 

데이터베이스의 무결성을 유지하며 DB의 상태를 변화시키는 기능을 수행한다. 
트랜잭션은 하나 이상의 쿼리를 포함해야 하고, ACID라고 칭해지는 원자성, 일관성, 고립성, 지속성의 4가지 규칙을 만족해야 한다. 
ex) 은행 시스템에서 A가 100만원을 출금해서 B에게 입금하는 상황이라고 가정해보겠습니다. 
만약 A의 잔고에서 100만원을 출금했는 데, 이때 오류가 발생하여 B의 계좌에는 100만원이 입금 되지 않았습니다. 이런 상황은 전산시스템의 치명적인 오류이며 이렇게 데이터의 부정합이 일어난 경우 다시 원상복귀를 해야합니다. 즉, 모든 입출금은 하나의 묶음 형태로 작동해야 하며 위의 두 행위는분리 될 수 없는 하나의 거래로 처리 돼야 하는 단일 업무입니다. ( 트랜잭션 )


### 트랜잭션 상태 
- 활동 (Active) : 트랜잭션이 실행중인 상태 
- 부분 완료 (Parially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, `Commit` 연산이 실행되기 직전의 상태 
- 완료 (Commit) : 트랜잭션이 성공적으로 종료되어 `commit` 연산을 실행한 후의 상태 
- 실패 (Failed) : 트랜잭션 실행에 오류가 발생해 중단된 상태
- 철회 (Aborted) : 트랜잭션이 비정상적으로 종료되어 `rollback` 연산을 수행한 상태


### 트랜잭션의 연산 
#### COMMIT 
- 트랜잭션 작업(여러 쿼리)을 완료했다고 확정하는 명령어
- 트랜잭션 작업 내용이 실제 DB에 저장하고, 변경되며 영구적으로 저장되는 것을 말한다.

#### ROLLBACK 
- 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)
- 작업 중 문제가 생겼을 때, 트랜잭션 처리 과정에서 발생한 변경사항을 취소하고, 이전 COMMIT 상태로 되돌린다. 
> 이러한 커밋과 롤백 덕에 데이터의 무결성이 보장된다. 또한, 데이터 변경 전에 변경 사항을 쉽게 확인할 수 있고 해당 작업을 그룹화할 수 있다.


### 무결성 
데이터베이스에 저장된 데이터의 일관성과 정확성, 유효성을 지키는 것 
무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는 지에 대한 신뢰가 생긴다. 
- 종류 
	- **개체 무결성** : 기본키로 선택된 필드는 빈 값을 허용하지 않는다. 
	- **참조 무결성** : 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다. 
	- **고유 무결성** : 특정 속성에 대한 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가진다.
	- **NULL 무결성** : 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약조건이다.


### 트랜잭션의 특성 - ACID 
트랜잭션이 성공적으로 처리되어 데이터베이스의 무결성과 일관성을 보장하려면 4가지 특성을 만족해야 한다.

#### 원자성 (Atomicity)
- 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 말아야 한다는 all or nothing 방식을 의미한다. 
- 원자성을 보장하려면 장애가 발생했을 때 데이터베이스의 원래 상태로 복구하는 회복 기능이 필요하다.
- 트랜잭션을 여러 로직으로 묶을 때 외부 API를 호출하는 것은 주의해서 사용해야 한다. 
	- 만약 있게 된다면 롤백이 일어났을 때 어떻게 해야 할 것인지에 대한 해결 방법이 있어야 하며 트랜잭션 전파를 신경 써서 관리해야 한다.

#### 일관성 (Consistency)
- 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태를 유지하는 것을 의미 
- 즉, 트랜잭션이 데이터의 제약 조건, 규칙에 맞게 데이터의 값이 변경되어야 함을 뜻한다.


#### 격리성 (Isolation)
- 트랜잭션 수행 시 서로 끼어들지 못하는 것을 의미 
- 즉, 각 트랜잭션은 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하여 독립적으로 작업을 수행해야 한다.
- 따라서 동시에 수행되는 트랜잭션이 동일한 데이터를 가지고 충돌하지 않도록 제어해줘야 하며 이를 동시성 제어라고 한다.
	- 갱신손실문제가 발생하며 이를 해결하기 위한 방법 중 하나로 Lock이 있다.
	

#### 지속성 (Durability)
- 트랜잭션이 성공적으로 수행된 후 데이터베이스에 영원히 반영되어야 함을 의미 
- 트랜잭션이 완료되어 저장된 데이터베이스는 저장 후에 생기는 정전,장애,오류 등에 영향을 받지 않아야 한다. 
- 이를 위해선 원래 상태로 복구하는 회복 기능이 있어야 함을 뜻하며, 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공한다. 
	- 체크섬 : 중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법 
	- 저널링 : 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(Commit) 하기 전에 로깅하는 것 (트랜잭션 등 변경 사항에 대한 로그를 남긴다.)


### 트랜잭션 전파 
트랜잭션이 수행할 대 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 한다. 
이러한 작업은 매번 넘겨주기도 까다롭기 때문에 이를 넘겨서 수행하는 것이 아닌 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 한다. 
Spring에서는 `@Transactional`어노테이션을 통해 여러 쿼리 관련 코드들을 하나의 트랜잭션을 처리한다. 


### Lock 
데이터베이스는 같은 데이터에 대해서 동시에 접근하는 경우가 생길 수 밖에 없는데, 이런 경우 데이터의 일관성과 무결성을 유지해야할 필요가 있다. 
이는 DBMS가 사용하는 공통적인 해결방법인 잠금(Lock)이 있다.
하지만 데드락이 발생할 수 있어 주의해서 사용해야 한다.
> 트랜잭션과 잠금은 비슷해 보이지만 사용 목적이 다르다. 
> 트랜잭션은 작업의 완전성을 보장하여 데이터베이스의 무결성을 보장하는 것이고, 잠금은 공유 자원에 대한 접근 순서를 결정하는 것이다. 
> 즉, 트랜잭션의 작업이 수행할 때 한 데이터에 대해서 여러 커넥션의 접근을 막기 위해 잠금을 사용한다.


#### 잠금의 종류 
- **공유 잠금 (Shared Lock, S-LOCK)**
	- 데이터를 읽을 때 사용되는 잠금이다. (읽기 잠금이라고도 부른다.)
	- 공유 잠금끼리 동시에 접근이 가능하지만, 공유 잠금이 설정된 데이터에 베타 잠금은 사용할 수 없다. 
	- 공유 잠금을 설정한 경우 다른 세션이 **동일한 데이터를 읽을 수는 있지만 변경할 수 없다**는 의미
- **베타 잠금 (Exclusive Lock, X-LOCK)**
	- 데이터를 변경할 때 사용하며, 트랜잭션이 완료될 때까지 유지된다. (쓰기 잠금이라고도 부른다.)
	- 잠금이 해제될 때까지 다른 트랜잭션(공유, 베타 잠금 모두 포함)은 해당 데이터에 접근할 수 없다. 
	- 베타 잠금을 설정한 경우 다른 세션이 **동일한 데이터에 읽기와 쓰기 작업을 할 수 없다**는 의미


#### 블로킹 
블로킹은 잠금들의 경합이 발생하여 특정 세션이 작업을 진행하지 못하고 멈춰 선 상태를 의미한다. 
블로킹은 공유 잠금 - 베타 잠금, 베타 잠금 - 베타잠금 끼리 발생할 수 있으며 이를 해결하기 위해선 이전의 트랜잭션이 완료되어야 한다. 
블로킹이 발생하면 먼저 잠금을 설정한 트랜잭션을 기다려야하기 때문에, 이런 현상이 반복되면 성능에 좋지 않는 영향을 미치기 때문에 최소화할 필요가 있다.
블로킹을 최소화 하기 위해 다음과 같은 방법이 있다. 
- SQL문이 가장 빠르게 실행되도록 리팩토링하는 것이 기본적이고 효과적인 방법이다. 
- 트랜잭션을 가능한 짧게 정의한다. 
- 동일한 데이터를 변경하는 트랜잭션이 동시에 수행되지 않도록 한다.



## 트랜잭션 격리 수준 
여러 트랜잭션이 동시에 작업을 수행할 때 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동한다. 
순차적으로 하면 쉽게 되겠지만 그렇게 하면 성능이 나빠지기 때문에 여러 개의 격리 수준으로 나뉘어 격리성을 보장한다.
- READ UNCOMMITTED 
- READ COMMITTED 
- REPEATABLE READ 
- SERIALIZABLE 
아래로 갈 수 록 격리성은 강해지지만 동시성은 약해진다.

#### READ UNCOMMITTED 
가장 낮은 격리 수준으로, 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있다. 
하지만 가장 빠르기 때문에 데이터의 일관성이 조금 떨어지더라도 성능을 극대화할 때 의도적으로 사용한다. 
팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 발생할 수 있다.

#### READ COMMITTED 
가장 많이 사용되는 격리 수준이며 READ UNCOMMITTED와 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 즉, 커밋 완료된 데이터에 대해서만 조회를 허용한다. 
하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할  수 있어 처음 트랜잭션이 같은 로우를 다시 읽을 때 다른 내용이 발견될 수 있다.
팬텀 리드, 반복 가능하지 않은 조회가 발생할 수 있다.

### REPEATABLE READ 
하나의 트랜잭션이 조회한 로우를 다른 트랜잭션이 수정할 수 없도록 막아준다. 
하지만 새로운 로우를 추가하는 것은 막지 않는다. 즉, SELECT로 조건에 맞는 로우를 전부 가져오는 경우 트랜잭션이 끝나기 전에 추가된 로우가 발견될 수 있다. 
팬텀 리드가 발생할 수 있다.

#### SERIALZABLE 
가장 강력한 격리 수준으로, 트랜잭션을 순차적으로 진행시킨다. 
여러 트랜잭션이 동시에 같은 로우에 접근할 수 없다. 그렇기 때문에 교착 상태가 일어날 확률도 많고 가장 성능이 떨어진다. 
InnoDB에서는 해당 격리 수준일 때 읽기 작업에도 공유 잠금을 설정하게 된다. 

## 격리 수준에 따라 발생하는 현상 
### 팬텀 리드 (phantom read)
한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우 
```
사용자 A - 회원 테이블에 age가 12 이상인 회원들을 조회하는 쿼리 실행 - 결과가 세 개라고 가정 
사용자 B - age가 15인 회원 삽입 후 커밋
사용자 A - 동일 쿼리시 결과가 네 개 
```


### 반복 가능하지 않은 조회 (non-repeatable read)
한 트랜잭션 내의 같은 행에 두번 이상 조회가 발생했을 때, 그 값이 다른 경우
```
사용자 A - min 회원의 age가 15 
사용자 B - min 회원의 age를 25로 변경 후 커밋 
사용자 A - min 회원 조회시 age가 25
```
팬텀리드와 유사하지만 반복 가능하지 않은 조회는 로우 값이 달라질 수 도 있는 반면, 팬텀 리드는 다른 행이 선택될 수 도 있다는 것을 의미한다.


### 더티 리드(dirty read)
한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 `아직 커밋되지 않은 행`의 데이터를 읽을 수 있을 때 발생
```
사용자 A - min 회원의 age가 15 
사용자 B - min 회원의 age를 25로 변경하였지만 커밋하지 않음
사용자 A - min 회원 조회시 age가 25
```


## MVCC (Multi Version Concurrency Content)
Muliti Version이란 하나의 레코드에 대해 여러 버전이 관리된다는 의미이다. 
일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공한다는 점이다. 
MySQL은 언두 로그를 이용해 이 기능을 구현한다.

언두 영역은 UPDATE문장이나 DELETE와 같은 문장이 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳이다. INSERT문장의 경우, 해당 데이터의 row id를 저장하고 이를 이용하여 물리적 메모리에 바로 접근할 수 있도록 보장한다. 
언두 로그가 있을 시 커밋이 실행되면 더 이상의 변경작업이 없이 지금 상태를 영구적인 데이터로 만들어버리고 언두 로그 영역의 내용을 더 이상 필요로 하는 트랜잭션이 없는 경우, 연두 로그에서 해당 내용을 삭제한다. (격리 수준에 따라 삭제하는 시점이 다르다.)
만약 롤백을 실행할 시 언두 로그 영역에 있는 데이터를 복구하며 언두 로그에서 해당 내용을 삭제하게 된다.
- 트랜잭션의 롤백 대비용 
- 트랜잭션의 격리 수준을 유지하면서 높은 동시성 제공

MySQL의 격리 수준이 READ UNCOMMITED라면 버퍼 풀이나 데이터 파일로부터 데이터를 읽어서 반환한다. 
READ COMMITED 이상이라면 버퍼 풀이나 데이터 파일에 있는 데이터를 읽는 대신에 변경 이전의 내용을 보관하고 있는 연두 로그 영역의 데이터를 반환한다.
기본적으로 UPDATE 구문은 연산 결과의 결과를 바로 레코드에 반영하고, 이전 데이터에 대해서는 멀티버전을 관리한다. 
> READ UNCOMMITTED : 멀티버전 관리를 하지 않으므로 다른 트랜잭션에서 로우의 내용을 바로 바라보게 됨 
> READ COMMITTED : 커밋 전까지 다른 트랜잭션에 멀티 버전을 보여준다. 
> REPETABLE READ : 커밋을 해도 먼저 시작한 다른 트랜잭션(실행 중인 트랜잭션 번호보다 작은 트랜잭션 번호)에게는 멀티 버전을 보여줄 것이다.

### 격리 수준 문제 해결 
### 더티 리드 해결 
READ COMMITTED 격리 수준에서는 더티 리드가 발생하지 않는다.
한 트랜잭션이 UPDATE구문을 실행하고 커밋을 하지 않았을 시 테이블에는 즉시 기록되고, 이전 값은 언두 영역에 백업이 된다. 
이 상황에서 다른 트랜잭션이 UPDATE구문을 실행한 로우를 조회하게 되면 로우 내용을 바로 바라보는 것이 아닌 언두 영역을 바라보기 때문에 이전 값을 조회하게 된다. 

### 반복 가능하지 않은 조회 해결 
REPEATABLE READ 격리 수준에서는 반복 가능하지 않은 조회가 발생하지 않는다.
언두 영역에 백업된 이전 데이터를 통해 트랜잭션 내에서는 동일한 결과만 보여주도록 보장하여 해결한다. 
언두 영역에 백업된 모든 데이터에는 변경을 발생한 트랜잭션의 번호가 포함되어 있는데, REPEATABLE READ 격리 수준에서는 실행 중인 트랜잭션보다 작은 트랜잭션(먼저 실행한 트랜잭션)에서 변경한(커밋된) 데이터만 보게 하여 해결 한다. 
( 사실 READ COMMITTED 격리 수준 또한 언두 영역에 백업된 이전 데이터를 보여주긴 하지만, 두 격리 수준에는 언두 영역을 활용하는 방식이 다르다. REPEATABLE READ는 버전 차이를 이용한다.)

### InnoDB 스토리지 엔진에서 PHANTOM READ 해결
레코드 락과 갭 락을 합친 넥스트 키 락을 사용하여 해결한다. 