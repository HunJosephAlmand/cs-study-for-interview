[TOC]

# 데이터베이스

## 이상 현상과 정규화

#### 이상 현상

* 정규화를 제대로 하지 못했을 때 발생하는 의도치 않은 부작용들

* 정규화를 통해 해결할 수 있다.
* 종류
  * 삭제
    * 삭제를 할 때 삭제할 대상이 아닌 데이터들도 삭제해야 하는 경우가 발생한다.
  * 수정
    * 특정 데이터의 수정이 데이터베이스의 논리적 일관성을 깨뜨릴 때
    * 특정 행의 데이터를 수정했을 때, 사실상 같은 의미를 가졌던 다른 행의 데이터들이 수정되지 않아서 일관성이 깨짐
  * 삽입
    * 행을 추가할 때 삽입을 원하지 않았던 데이터 열에 데이터를 삽입을 하지 않으면 데이터를 추가할 수 없는 상황
    * null 값을 넣어서 해결할 수 있으나, 해당 열에 대한 제약 조건에 not null이 있을 경우는 불가능

#### 정규화

- 데이터를 올바른 형태로 변경하고 분할
- 목적
  - `하나의 데이터는 한 곳에 있어야 한다.`
  - 새로운 타입의 데이터를 추가할 때 기존 데이터 구조의 변경을 최소화하기 위해.
  - 데이터베이스의 구조를 확장할 때 데이터베이스와 상호작용하는 애플리케이션에 미치는 파급 효과를 줄이기 위해
- 제1 정규화
  - 중복되는 행이 없어야 한다!
  - 테이블 분할 + 기본키 지정
  - 행들은 테이블을 값으로 가지면 안 된다.
    - (cells cannot have tables as values)
- 제2 정규화
  - 함수 종속성 제거
  - 키가 아닌 속성들은 '모든' 후보 키들에 종속 되어야 한다.
    - 후보 키들 중 일부에만 종속되면 안 된다.
- 제3 정규화
  -  key가 아닌 속성(non-prime)들은 오직 key 속성에만 의존해야 한다.
    - key가 아닌 속성에 의존하면 안 된다.

## 트랜잭션

### 개념

* DBMS에서 DB에 수행되는 독립적인 작업의 단위
* 일반적으로 데이터베이스에서 나타나는 모든 변화들을 의미.
* 작업이 실패 했을 경우, 데이터베이스를 실패 이전 상태로 복구 시키고, 데이터베이스의 **일관성을 유지**하기 위해 사용.
* 격리를 통한 데이터베이스 접근의 동시성 제어

### ACID

* atomic
  * 트랜잭션 안의 작업이 모두 완료된 상태 또는 완전히 실패한 상태
* consistent
  * DB의 제약 조건을 항상 만족해야 한다.
* isolated
  * 다른 트랜잭션에 영향을 주면 안 된다
* durable
  * 트랜잭션이 완료되면 해당 작업 사항이 영구적으로 DB에 반영되어야 한다.

### LOCK

* 데이터베이스의 일관성을 지키기 위해 데이터에 대한 동시 접근을 막기 위한 기술
* 한 레코드가 트랜잭션에서 수정 대상이 되었을 때, 락이 걸린다. 다른 트랜잭션이 같은 레코드를 수정을 시도할 수 없다.
* 락이 걸린 레코드에 대한  작업이 성공적으로 수행되거나 완전히 실패했을 때, 락이 풀린다.
* 락의 크기
  * 데이터베이스
    * DB 전체 업데이트에 사용
  * 데이터베이스 파일
    * 파일 전체를 백업할 때 사용
  * 테이블
    * DDL 구문을 사용할 때 사용
  * 페이지
    * 파일을 구성하는 페이지와 블록 기준
  * 컬럼
    * 리소스를 많이 잡아 먹어서 사용 X
  * 행
    * 가장 높은 세분화 정도.
    * 가장 자주 사용
* 종류
  * 배타 잠금(Exclusive locks)
    * 해당 레코드에 대한 락을 한 개체만 소유한다.(다른 개체들 접근 불가능)
    * 일반적으로 레코드에 대한 수정이 가해질 때 사용. 
    * 다른 잠금과 호환되지 않는다.
  * 공유 잠금(Shared locks)
    * 락이 걸려 있어도, 다른 엔티티들이 읽을 수 있음
    * 조회 할 때 락을 걸고, SELECT가 완료되면 락을 해제한다.
    * 다만 공유 락이 모든 개체들에 의해 완전히 해제될 때까지, 배타 락을 걸 수 없다.
      * 공유 락이 걸린 개체는 배타 락으로 이용한 수정이 불가능하다.
  * 갱신 잠금 (update lock)
    * 공유 잠금과는 호환되지만 다른 갱신 잠금이나 배타 잠금과는 호환되지 않는다.
    * 공유 잠금이 걸린 데이터를 수정하고 싶을 떄 사용
    * 배타 잠금이 공유 잠금과 호환되지 않는 문제점을 해결하기 위해 사용
      * 공유 잠금이 풀릴 때까지 배타 잠금은 기다려야 함(Lock wait)

### 격리 수준

* 하나의 데이터베이스 연산에 의한 변경 내용을 다른 연산에서 어느 시점에 반영시킬 것인지를 결정

#### 종류

* Serializable
  * 가장 높은 격리 수준
  * 대상 데이터에 대한 읽기/ 쓰기 연산을 수행하기 위한 lock을 요구
  * lock은 트랜잭션이 끝나면 반환된다.
  * select 질의에서 where 문을 적용할 때 range-lock을 적용한다.
    * 다른 트랜잭션은 lock이 걸린 range에 해당하는 데이터를 추가할 수 없음
    * range-lock을 보유한 트랜잭션이 동일한 select문을 날렸을 때 다른 트랜잭션에 의해 추가된 데이터까지 가져오는 상황인 phantom-read를 막기 위함
* Repeatable Reads
  * 대상 데이터에 대한 읽기  / 쓰기 락 획득
  * range-lock은 적용 X 
    * phantom reads 적용 가능성
    * 다른 트랜잭션이 해당 테이블에 데이터를 추가하면, 같은 select 조회에서 새로운 데이터가 반환될 수 있다.
  * 해당 트랜잭션에서 읽은 데이터는 트랜잭션이 끝날 때 까지 lock이 걸려 있다.
* Read commited
  * 쓰기 락만 transaction이 끝날 때 까지만 적용
  * 읽기 락은 select 명령의 시작과 끝에서만 유지.
  * 읽기 명령 대상 데이터는 해당 명령이 수행되는 시점에는 committ 되어 있음을 보장.
  * commit 되지 않은 변경들이 적용된 데이터를 읽는 것을 방지
  * **non-repeatable read** 발생 가능성
    * 동일 트랜잭션에서 같은 데이터를 읽는 select 문을  중간에 수정 없이 여러 번 호출했을 경우 다른 결과가 나타나는 현상
  * 데이터베이스 내부에 undo 영역이 있음. 바뀌기 전의 레코드 값을 undo 영역에서 저장하고 다른 트랜잭션이 해당 레코드 값을 질의할 때 DB는 undo 영역에 있는  값을 가져온다.(MVCC)

* Read uncommitted
  * 커밋되지 않은 변경들이 적용된 데이터들을 읽을 수 있다.



## 트랜잭션의 상태

* 부분 완료
  * 마지막 연산까지 다 했지만 커밋이 안된 상태	
* 완료
  * 마지막 연산 + 커밋이 된 상태
* 철회
  * 실패를 하고 롤백이 된 상태

* 실패
  * 실패를 한 상태
  * 롤백이 된 상태는 아님.

* 활성화
  * 트랜잭션 수행중

#### 기본 격리 수준 예시

* spring data jpa
  * 기본적으로 db의 격리 수준을 따라간다.

* mysql
  * InnoDB : Repeatable Read
  * 그 외 엔진 : read committed
* 그 외 DB
  * read committed;

## 질문

데이터베이스의 이상 현상 3가지를 설명해주세요

제2 정규화와 제3 정규화의 차이점을 말씀해주세요

ACID의  어떤 개념인지 간단하게 설명해주세요.

잠금의 종류 중 공유 잠금과 배타 잠금의 차이점을 알려주세요.

격리 수준 중 Repeatable Read를 설명해주시고, 해당 격리 수준에서 발생할 수 있는 문제를 이야기해주세요.



## 교착 상태(Deadlock)

* 트랜잭션들이 실행을 하지 못하고 자원을 무한히 기다리는 상태

### 해결법

* 예방 기법

  * deadlock이 발생하는 상황을 미리 감지한다.

  * 탐지 기법 : Wait-for Graph
    * 트랜잭션을 진행하기 전에, 그래프를 만들어서 자원에 대한 cycle이 존재하는지 확인한다.
    * Union-Find 알고리즘
    * my sql이 사용
      * 트랜잭션 죽이는 기준
        * undo 영역 history 크기가 작은 것을 최우선으로 죽인다.
    * 실무에서는 이 기능을 끈다.
      * 그래프 탐색 자체의 비용이 크다.
      * 테이블 lock이 많을 수록 성능 저하가 심하다.
  * 애플리케이션 수준에서 회피
    * 각 트랜잭션이 필요한 데이터를 얻는 순서를 일치시킨다.
      * 두 트랜잭션이 A->B->C 순서대로 데이터를 가져오면, 교착 상태가 일어나지 않음
  * row-level lock + Read committed
    * 반드시 deadlock을 막지는 못함
* 회피 기법

  * 자원을 할당할 때 timestamp를 사용
  * Wait-Die
    * 비선점형
    * 오래된 트랜잭션이 wait하고 새로운 트랜잭션을 kill한다.
    * 먼저 들어온 트랜잭션이 나중에 들어온 트랜잭션이 lock한 데이터를 요청할 경우, lock이 해제될 때 까지 기다린다(wait)
    * 나중에 들어온 트랜잭션이 먼저 들어온 트랜잭션에게 lock된 데이터를 요청할 경우 나중에 들어온 트랜잭션은 kill된다.
    * kill된 트랜잭션은 나중에 다시 실행되는데 이 때 timestamp는 이전의 것을 유지한다.
  * Wound-wait
    * 선점형
    * 먼저 들어온 트랜잭션이 나중에 들어온 트랜잭션의 데이터를 요청할 경우, 나중에 들어온 트랜잭션을 kill하고 자원을 점유한다. 
      * kill된 트랜잭션은 timestamp 기록을 유지한 채 나중에 다시 실행된다.
    * 나중에 들어온 트랜잭션이 먼저 들어온 트랜잭션의 데이터를 요청할 경우, 먼저 들어온 트랜잭션이 lock을 해제할 때 까지 기다린다.



## 인덱스

### 개념

* 데이터베이스에 있는 레코드들을 빠르게 탐색하기 위한 자료 구조
* 보통 B-Tree 자료구조를 사용한다.
  * Multi-Level Index
* 데이터 분포가 고르지 못할 경우 인덱스를 쓰는 것이 훨씬 느리다.
  * 그냥 풀 스캔을 적용할 것.


### 특징

* 인덱스가 없는 column을 where 조건에 있을 경우 인덱스를 사용하지 않고 full table scan을 사용한다.

* 인덱스 데이터 삽입할 때 성능 저하가 반드시 일어날까?

  * 페이지 분할이 일어나지 않으면 괜찮다.
    * 트리 구조를 변형시키는 행위

  

  

### Non-clustered Index

* 테이블의 데이터는 인덱스를 기준으로 정렬되어 있지 않다.
* 인덱스에 의해 논리적인 순서가 정해 진다.(물리 순서 X)
  * 인덱스가 적용된 컬럼/표현식에 상관 없이 테이블이 저장되어 있음
  * 인덱스가 적용된 데이터만 따로 인덱스 자료구조에 정렬되어 있다.
  * 인덱스의 leaf node에 실제 데이터 주소 참조값을 갖고 있다.
* 보통 기본 키가 아닌 컬럼에 사용한다. (JOIN, WHERE, ORDER BY)
* 한 데이터베이스 테이블에 여러 non-clustered index가 있을 수 있다.

### Clustered Index

* 인덱스의 순서와 실제 파일 시스템에 저장된 데이터 행들의 순서가 일치
* DB 하나 당 하나만 존재
* 데이터를 순차적으로 접근했을 때나, 특정 범위로 접근했을 때 성능 향상(물리적 순서가 일치하니까 바로 다음 row에서 가져오면 됨)
* PK가 없을 때는 UNIQUE key를 통해 설정하기도 함.



### 인덱스 자료 구조

#### B-Tree

*  **최소의 높이를 유지**시키는  트리
*  N -way Search Tree
*  높이 :  O(log n)
*  연산 비용 : O(log n)
*  규칙
  * 각 key에는 실제 key 값과 일치하는 record pointer를 갖고 있음
  * root node는 최소 2 개의 자식 node를 갖는다.
  * 모든 leaf node의 높이는 일치한다.
  * bottom-up
*  수정과 삽입의 오버헤드가 크다
   *  삭제의 오버헤드는 작다.
      *  삭제는 실제로 데이터를 삭제하는 것이 아니라 마킹하는 것이기 때문(레코드 포인터만 삭제, key 값과 구조는 유지)


#### B+ tree

* leaf node에만 record pointer가 있다.
  * left node에는 모든 key가 존재한다.
* leaf node들은 서로 pointer로 연결되어 있음 
* 범위탐색용이

#### hashes

* 인덱스 자료구조로 hashtable을 사용

* 각 레코드에 인덱스 대상 column에 해시 함수를 적용한 해시 값을 바탕으로 레코드의 주소를 해시 테이블에 저장

* 순서와 관련된 탐색을 할 때 성능이 매우 나빠진다.

  * ORDER BY

  * '>', '<'
  
* key가 문자열일 경우 접두사 관련 문자열 와일드카드 검색을 할 수 없다. 'prefix%'

  * 원본 데이터 변경이 되므로 접두사 hash 값이랑 접두사에 특정 문자를 더한 hash 값을 더한 것이 논리적 관계가 전혀 없음.


## Sharding

* 데이터베이스 테이블을 수평 분할하여 여러 개의 작은 단위로 나눈 후 물리적으로 다른 위치에 분산하여 저장-관리하는 기술.
* 수평 파티셔닝과 비교
  * 분할된 테이블들이 같은 인스턴스에 존재하느냐에 차이
  * 데이터베이스 수준의 트랜잭션이 불가능하다. => 애플레케이션 계층에서 트랜잭션을 구현해야함
  * 데이터베이스 스키마 그대로 유지
* 애플리케이션의 규칙에 따라 샤딩
* 방식
  * 알고리즘 샤딩
    * 레인지 샤딩
    * 각 레코드에 대해 샤딩 함수를 통해 shard 값을 생성하여 키 값에 해당하는 노드에 저장
    * 각 인스턴스에 대한 페이로드 크기나 공간 활용도 고려 X
    * 쿼리시 파티션 키가 반드시 있어야 함
      * 없을 경우 모든 인스턴스들을 검색해야 함
  * 동적 샤딩
    * 외부 로케이터 서비스를 이용하여 입력 인스턴스 결정
  * 디렉터리 기반 샤딩
    * 샤드 키를 기반으로 키에 매칭되는 데이터를 추적하는 조회 테이블을 생성
    * 조회 테이블에서 원하는 행을 가져올 수 있음
    * Command 관련 작업 시 조회 테이블을 갱신해야 함으로 비용이 든다.

## Replication(Master Slave)

* Active - Standby 방식과 비교
  * standby 데이터베이스를 예외처럼 사용하는 것은

* 한 데이터베이스의 데이터를 복사해서 분산형 데이터베이스 체계를 구성
  * 읽기 쓰기 쿼리 요청을 분담해서 데이터베이스의 부하를 줄인다.
* master(primary) 데이터베이스
  * 데이터에 대한 변경 요청 제어
  * 변경 내용은 동기/비동기적으로 slave 데이터베이스에게 전파
* slave(replica) 데이터베이스
  * master의 데이터 복제 및 동기화
  * 데이터에 대한 select 요청 응답
* Mysql 데이터 변경 동기화 방식
  * 쓰기 쿼리 요청을 master db가 binary log에 기록
  * slave는 지금까지 반영된 이벤트 정보를 바탕으로 Master에게 새로운 이벤트 유무 요청
  * Master는 slave의 이벤트 정보를 offset 삼아서 새로운 이벤트 전송
  * slave는 해당 이벤트를 relay log에 기록하고 변경 내용을 반영한 뒤 커밋
  * 종류
    * async
      * 먼저 변경 내역을 master에 반영 후 commit
      * commit 이후 slave 데이터베이스에 변경 내용 반영
      * 동기화 문제(사용자가 조회한 db에 변경 내용이 반영되어있지 않을 수 있다.)
    * semi-sync
      * 변경 내역을 commit하기 전에 하나의 slave가 변경 내역을 log에 기록했는지 확인
      * 확인 이후 commit 진행





