## 프로세스 
### 프로세스란? 
> 프로그램은 어떤 작업을 수행하기 위한 파일로써 정적인 상태 
> 프로세스는 그 작업을 수행하는 동적인 상태

실행중인 프로그램을 뜻한다. 
즉, 실행파일 형태로 존재하던 프로그램이 **메모리**에 적재되어 **CPU**에 의해 실행되는 것을 프로세스라고 한다.
프로그램을 실행하기 위한 주소공간, 파일, 메모리 등을 운영체제로 부터 할당받는다.

### 프로세스의 메모리 구조 
![](https://i.imgur.com/iiBu4rf.png)
[출처](http://www.tcpschool.com/c/c_memory_structure)
Memory는 CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치이다. 
프로그램이 CPU에서 실행되려면 해당 내용이 memory에 적재된 상태여야만 한다. 
프로세스에 할당된 메모리 공간은 Code, Data, Stack, Heap 4개의 영역으로 이루어져있으며, 각 프로세스마다 **독립적**으로 할당받는다.
- **Code 영역** 
	- 실행한 프로그램의 코드가 저장되는 메모리 영역 
	- 기계어로 저장되어 있으며 정적인 특징 
- **Data 영역** 
	- 프로그램의 전역 변수와 static 변수가 저장되는 메모리 영역 
	- 해당 영역은 BSS 영역과 Data 영역으로 나뉘게 된다. 
		- BSS : 초기화 되지 않은 변수가 0으로 초기화되어 저장 
		- Data : 0이 아닌 다른 값으로 할당된 변수들이 저장
- **Heap 영역** 
	- **동적** 할당할 때 사용되며 런타임시 크기가 결정된다
	- 프로그래머가 직접 공간을 할당, 해제 하는 메모리 영역
- **Stack 영역** 
	- 함수의 복귀 주소와 지역변수, 매개변수, 반환값을 저장하는 영역 
	- 컴파일 시에 크기가 결정되며 동적인 특징을 갖는다.

### CPU, PC register 
프로그램의 코드를 토대로 CPU가 실제로 연산을 해야만 프로그램이 실행된다 
그럼 CPU는 어떤 코드를 읽어야 할 지 어떻게 알까? 사실 CPU 내부에 있는 PC register를 통해 알 수 있다. 
PC register에는 다음에 실행될 코드의 주소값이 저장되어 있다. 즉, memory에 적재되어 있는 process code영억의 명령어 중 다음 번 연산에 읽어야할 명령어의 주소값을 PC register가 순차적으로 가리키게 되고, 해당 명령어를 일거와서 CPU가 연산을 하게 되면 process가 실행되는 것이다.


### 프로세스 상태
![](https://i.imgur.com/pHHngjz.png)

프로세스는 크게 실행(Running), 준비(Ready), 봉쇄(Blocked, Wait, Blocked) 세 가지 상태로 구분된다. (사실 중지 상태도 포함되어야 함)
- **실행 (Running)**
	- 프로세스가 CPU를 보유하고 실행 중인 상태 
	- 실행상태에 있는 프로세스는 매 시점 하나 뿐이다.
- **준비 (Ready)**
	- 메모리에 프로그램이 올라가 있지만, CPU를 할당받지 못한 상태 
	- 사실 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기하고 있으며 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태이다.
- **봉쇄 (Blocked, Wait, Sleep) - 대기** 
	- CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태 
	- I/O나 프로세스 자신이 요청한 이벤트가 즉시 만족 되지 않아 이를 기다리는 상태
	- ex) 디스크에서 파일을 읽어와야 하는 경우
- **생성 ( New )**
	- 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조 (PCB)는 생성되었으나 아직 메모리 획득을 승인받지 못한 상태 
	- fork(), exec() 함수를 통해 생성 
		- fork() 
			- 부모 프로세스의 주소 공간을  그대로 복사하여, 새로운 자식 프로세스를 생성
			- 주소 공간만 복사할 뿐이지 부모 프로세스의 비동기 작업 등을 상속하지는 않는다. (독립적)
			- 새로 생성하는 것보다 프로세스의 생성속도가 빠르며 추가 작업 없이 자원을 상속할 수 있고 시스템 관리를 효율적으로 할 수있다.
		- exec() 
			- 새롭게 프로세스를 생성
- **완료( Terminated )**
	- 프로세스가 종료된 상태 
	- 운영체제가 해당 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태
- **중지 준비 상태 (ready suspended)**
	- 준비 상태에 있던 프로세스가 중기 스케줄러에 의해 디스크로 스왑 아웃되면서 중지 준비 상태가 된다.
- **중지 봉쇄 상태 (blocked suspended)**
	- 봉쇄 상태에 있던 프로세스가 중기 스케줄러에 의해 스왑 아웃되면서 중지 봉쇄 상태가 된다.

### 프로세스 상태 전이 과정 
1. 프로세스가 생성되면 new상태에서 ready상태가 된다. 
2. readty상태에서 CPU를 얻게 되면 running 상태가 된다. 
3. CPU를 얻은 상태에서 내려 놓는 경우 
	1. running -> terminated 
		- 본인의 역할을 다하면 종료된다.
	2. running -> wating 
		- I/O 같은 오래 걸리는 작업을 하면, CPU가 가지고 있어 봐야 명령을 수행할 수 없으므로 CPU를 반환하고 완료될때까지 기다리는 waiting 상태가 된다.
	3. running -> ready 
		- 할당된 CPU 사용 시간이 끝나면 ready 상태가 된다. (타이머 인터럽트)
		
실행 상태에서 CPU의 제어권을 가지고 프로세스가 실행되는 중에 타이머 인터럽트가 발생하게 되면 CPU의 제어권은 운영체제로 이양되게 된다. 
그러면 운영체제는 타이머 인터럽트 처리루틴으로 가서 수행 중이던 프로세스의 문맥(PCB)를 저장하고 준비 상태에 있는 프로세스 중에서 새롭게 CPI의 제어권을 부여할 프로세스를 선택한다. 
그렇게 되면 원래 수행 중이던 프로세스는 준비 상태로 변하고 새롭게 CPU"를 할당받은 프로세스가 실행 상태가 된다. (Context Switch)
이 과정은 봉쇄 상태로 변하는 경우에도 동일하다. 
이때 준비 상태에 있던 프로세스들 중에서 CPU를 할당 받을 프로세스를 선택하고 실제로 CPU의 제어권을 넘겨받는 과정을 **CPU 디스패치**라고 한다.

### 프로세스 Context
> process가 현재 어떤 상태로 수행되고 있는 지에 대한 정보
![](https://i.imgur.com/Msg5pK3.png)

하나의 CPU는 매 순간 하나의 process만 연산할 수 있다. 
하지만 CPU의 처리 속도가 워낙 빨라 짧은 시간동안 여러 process들이 CPU에서 번갈아 실행되기 때문에 사용자 입장에서는 여러 프로그램이 동시에 실행되는 것처럼 보인다. 
이처럼 CPU의 작업시간을 여러 process들이 조금씩 나누어 쓰는 시스템을 **시분할 시스템**이라고 한다.
이때 전에 실행되던 프로세스가 CPU를 다시 획득해 명령의 수행을 재개하는 시점이 되면, 이전 CPU 보유 시기에 어느 부분까지 명령을 수행했는 지 정확한 상태를 재현할 필요가 있다. 이때, 필요한 정보가 바로 **프로세스의 문맥**이다.
즉, 프로세스의 문맥은 그 프로세스의 주소 공간(코드, 데이터, 스택 상태)를 비롯해 레지스터에 저장된 값, 시스템 콜을 통해 커널에서 수행한 일의 상태, 그 프로세스에 관해 커널이 관리하고 있는 각종 정보 등을 포함하게 된다.
프로세스 문맥은 3가지로 나눌 수 있다. 

#### 하드웨어 문맥 
CPU의 수행 상태를 나타내는 것으로 프로그램 카운터 값과 각종 레지스터에 저장하고 있는 값들을 의미한다. 

#### 프로세스의 주소 공간 
code, data, stack에 들어 있는 내용이다. 

#### 프로세스 관련 커널 자료 구조 
- PCB (Process Controlr Bolck)
	- 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조 
- Kernel Stack 
	- 시스템 콜을 하면 PC가 커널의 code를 가리키며 수행되는데, 호출 정보를 커널 스택에 프로세스 별로 스택을 두어서 저장한다.

### 프로세스 제어 블록 (PCB, Process Control Block)
![](https://i.imgur.com/X6uSI8e.png)

운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조이다. 
PCB에는 프로세스의 중요한 정보가 포함되어 있기 때문에, 일반 사용자가 접근하지 못하도록 보호된 메모리 영역 안에 저장된다. 일부 운영 체제에서 PCB는 커널 스택에 위치한다. 
이 메모리 영역은 보호를 받으면서도 비교적 접근하기가 편리하기 때문이다. 
- OS가 관리 상 사용하는 정보 
	- 프로세스 상태, 프로세스 ID, CPU 스케줄링 정보, 프로세스 우선순위 등 
- CPU 수행 관련 하드웨어 값 
	- 프로그램 카운터, 레지스터 
- 메모리 관련 
	- code, data, stack의 위치 정보 
- 파일 관련 
	- 프로세스가 오픈한 파일 정보
- Memory litmits 
	- base register, limit register, page table 또는 segement table 등
이들은 Linked List 방식으로 PCB들을 관리하게 된다. Process가 생성되면 해당 Process의 PCB가 만들어지게 되고 그 PCB는 PCB List Head에 붙게 된다. (프로세스의 상태도 이와 같은 방식으로 관리된다.)

### 프로세스 문맥 교환 (Context Switch)
한 프로세스에서 다른 프로세스로 CPU 제어권을 넘겨주는 것 
이때, 이전의 프로세스의 상태를 PCB에 저장하여 보관하고 새로운 프로세스의 PCB를 읽어서 보관된 상태를 복구하는 작업이 이루어진다.

#### 과정 
![](https://i.imgur.com/9T6iC9h.png)
프로세스가 CPU를 할당 받고 실행되던 중 타이머 인터럽트가 발생하면 CPU의 제어권은 운영체제에게 넘어가게 된다. 그러면 운영체제는 타이머 인터럽트 처리루틴으로 가서 직전까지 수행중이던 프로세스의 문맥(PCB)를 저장하고 새롭게 실행 시킬 프로세스에게 CPU의 제어권을 넘긴다. 이 과정에서 원래 수행 중이던 프로세스는 준비 상태로 바뀌고 새롭게 CPU를 할당 받은 프로세스는 실행 상태가 된다. 
문맥 교환 중 원래 CPU를 보유하고 있던 프로세스는 프로그램 카운터값 등 프로세스의 문맥을 자신의 PCB에 저장하고 새롭게 CPU를 할당받을 프로세스는 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원하는 과정을 거친다. 

#### 언제 일어나냐? 
 - 타이머 인터럽트 
 - 실행중이던 프로세스가 입출력 요청이나 다른 조건을 충족하지 못해 CPU를 회수당하고 봉쇄 상태가 되는 경우

#### 시스템 콜이나 인터럽트가 발생하면 무조건 문맥 교환이 일어나는가?
프로세스가 실행 상태일 때 시스템 콜이나 인터럽트가 발생하여 CPU의 제어권이 운영체제로 넘어와 원래 실행 중이던 프로세스의 업무가 잠시 멈추고 운영체제 커널의 코드가 실행된다. 
이 경우에도 CPU의 실행 위치 등 프로세스의 문맥 중 일부를 PCB에 저장하기 하지만 하나의 프로세스의 실행 모드가 사용자 모드에서 커널 모드로 바뀌는 것일뿐 CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 것은 아니므로 문맥 교환이 아니다. 

만약 타이머 인터럽트가 발생하거나 프로세스가 입출력 요청 시스템 콜을 하여 봉쇄 상태에 들어간 경우는 다른 사용자 프로세스에게 CPU 제어권을 전달하므로 문맥 교환이 발생한다.

## 스레드 
### 스레드란?
한 process 내에서 실행되는 동작의 단위 
thread는 process 내에서 독립적인 기능을 수행하며 각 thread가 독립적으로 함수를 호출한다.

### Stack memory & PC register 
thread가 함수를 호출하기 위해서는 인자 전달, 복귀 주소 저장, 함수 내 지역변수 저장 등을 위한 독립적인 stack memory 공간을 필요로 한다. 
결과적으로 thread는 process로부터 Stack Memroy 영역은 독립적으로 할당받고 code, data, heap 영역은 공유하는 형태를 갖게 된다. (사실 독립적인 메모리는 아니고, 스택 포인터로 표시한다.)
또한, multi thread에서는 각 thread마다 PC register를 가지고 있어야 한다. 그 이유는 한 process 내에서도 thread끼리 context switch가 일어나게 되는 데 PC register에 code address가 저장되어 있어야 이어서 실행할 수 있기 때문이다.

#### process와 thread 
process는 운영체제로부터 자원을 할당받는 자원의 단위이고 thread는 process가 할당받은 자원을 이용하는 실행의 단위이다. 
즉, process는 program이 memory에 적재되어 CPU를 할당받아 실행되는 것이며 thread는 한 process 내에서 실행되는 동작의 단위를 말한다.
process는 memory 공간에 code,data,stack,heap 영역이 있는데, thread는 process 내에서 stack영역을 제외한 code,data,heap영역을 공유하며 속도가 빠르다.


### 멀티 스레드 
하나의 process가 동시에 여러개의 일을 수행할 수 있도록 해주는 것 
즉, 하나의 process에서(실행된 하나의 프로그램) 여러 작업을 병렬로 처리하기 위해 멀티 스레드를 사용한다.
멀티 스레드에서는 한 process 내에 여러 개의 thread가 있고, 각 thread들은 Stack 메모리를 제외한 나머지 영역(code,data,heap)영역을 공유하게 된다.

- 장점 
	- 응답성 
		- 하나의 스레드가 wating 상태인 동안에도 동일한 Task 내의 다른 스레드가 실행되어 빠른 처리가 가능하다.
	- 자원 공유 
		- 하나의 프로세스 안에 CPU 수행 단위인 스레드를 두게 되면 code,data,heap 자원을 공유하여 효율적으로 자원 활용이 가능하다
	- 경제성 
		- 프로세스의 자원을 공유하기 때문에 새로운 메모리 주소공간을 할당받을 필요가 없어 생성에 자원이 적게 들어간다. 
		- 프로세스의 Context Switch와 달리 캐시 메모리를 초기화할 필요가 없고 code, data, heap 영역을 공유하므로 stack 영역만 처리하면 되기 때문이다.
- 단점 
	- 공유자원을 사용하기 때문에 동기화 문제가 발생할 수 있다. 
		- lock을 함으로써 공유자원에 대한 동기화를 해결할 수 있긴 하지만 이것 또한 병목현상을 일으킬 수 있다.

### 멀티스레드 모델 
- 사용자 레벨 스레드 
	- 운영체제가 멀티스레드를 지원하지 않을 때 사용하는 방법 
	- 사용자 레벨에서 스레드를 구현하기 때문에 라이브러리를 사용하여 구현하며 라이브러리는 커널이 제공하는 스케줄링이나 동기화 같은 기능을 대신 구현한다. 
	- 커널 입장에서는 이 스레드는 하나의 프로세스처럼 보이게 된다.
- 커널 레벨 스레드 
	- 커널이 멀티 스레드를 지원하는 방식이다.
	- 1 to 1 모델이라고 부른다
- 멀티 레벨 스레드 
	- 사용자 레벨 스레드와 커널 레벨 스레드를 혼합한 방식 
		- M to N 모델 


### 멀티 프로세스 
2개 이상의 prcoess가 동시에 실행되는 것 
- 동시성 
	- CPU core가 1개일 때, 여러 process를 짧은 시간동안 번갈아 가면서 연산을 하게 되는 시분할 시스템으로 실행되는 것 
- 병렬성 
	- CPU core가 여러개일 때, 각각의 core가 각각의 process를 연산함으로써 process가 동시에 실행되는 것
이때 process들은 CPU와 메모리를 공유하게 되지만 memory의 경우 여러 process들이 각자의 memory 영역을 차지하여 동시에 적재됩니다. (base register, limit register를 통해 각 process를 처리할 때에는 정해진 메모리 구간 외에는 접근할 수 없도록 운영체제가 관리한다.)
여기서 CPU는 PC register가 가리키고 있는 명령어를 읽어들여 연산을 진행합니다.


### 멀티 프로세스 VS 멀티 스레드
- 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠르다. 
- 멀티 스레드는 process를 생성하고 자원을 할당하는 등의 system call을 생략할 수 있기 때문에 자원을 효율적으로 관리할 수 있다.
- 프로세스 간의 통신 (IPC)보다 멀티 스레드간의 통신 비용이 적기 때문에 통신으로 인한 오버헤드가 적다.
- 멀티 프로스세는 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다. 
- 멀티 스레드는 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험이 있다. 
- 멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높다.