# Spring 기본

## 스프링 프로젝트

스프링은 단일 기술이 아니라 다수 기술의 모음

- 핵심: 스프링 프레임워크, 스프링 부트
- 선택:
  - 스프링 데이터: DB사용을 도움, ex) 스프링데이터 Jpa
  - 스프링 세션
  - 스프링 시큐리티
  - 스프링 Rest Docs(API문서화, 테스트)
  - 스프링 배치
  - 스프링 클라우드
  - etc . . . (공식 사이트의 project 참조)



**스프링 프레임워크**

- 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜젝션, JDBC, ORM 지원, XML 지원
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비
- 스프링 부트를 통해서 스프링 / 스프링 프레임워크의 기술들을 편리하게 사용 가능.

**스프링 부트**

- 단독 실행 가능한 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장, 별도의 웹 서버 설치 불필요.
- 손쉬운 빌드 구성을 위한 starter 종속성 제공(라이브러리 종속성 관리 build.gradle 참조)
- 스프링과 3rd party(외부) 라이브러리 자동 구성(버전당 써드파티 라이브러리 호환성 관리)
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공(모니터링 환경)
- 관례에 의한 간결한 설정(디폴트 설정 + 메뉴얼이 잘 되어있음)

**스프링이라는 단어**

- 스프링 DI 컨테이너 기술
- 스프링 프레임워크
- **스프링 생태계 전체**

**스프링의 제작 이유 - 핵심 개념**

- **자바** 기반 프레임워크: **객체 지향**
- 스프링은 **좋은 객체 지향** 애플리케이션 개발을 돕는 프레임워크
- 그것을 돕는 **DI 컨테이너**



## MVC1 vs MVC2

- MVC
  - Model
    - 사용자가 이용하려는 모든 데이터를 가지고 있음
    - View / Controller에 대한 정보를 알고 있지 않음
  - View
    - 클라이언트에게 보이는 화면을 반환
    - 보이는 역할만
  - Controller
    - 모델과 뷰를 연결, 통제해주는 역할
    - 모델과 뷰에 대한 정보를 앎
- MV or MVC1
  - 클라이언트 <--HTTP 요청 / 응답 --> WAS
  - WAS
    - JSP(View + Controller) <--> JavaBean(Model)
  - WAS <--TCP--> DB
  - JSP가 거의 모든 로직을 처리하기에 유지보수성이 좋지 않음
- MVC2
  - WAS
    - Controller(Filter / Servlet)가 HTTP 요청을 받음
    - Controller --Model-->DB--Model-->View-->응답 반환
    - JSP는 뷰만을 담당



## DispatcherServlet

- 필요성

  - 컨트롤러: 서블릿
  - 뷰: JSP
  - 모델: HttpServletRequest(request는 데이터 저장소를 가지고 있음: .set/getAttribute
  - 액션이 “/save”(절대경로)가 아니라 “save”(상대경로)
  - `dispather.forward()`: 다른 서블릿이나 JSP로 이동하는 기능, 서버 내부에서 다시 호출이 발생
    - vs redirect: 리다이렉트와는 다르다. 포워드는 서버 내부의 호출이기에 클라이언트가 호출 불가, 리다이렉트는 클라이언트에 응답 -> redirect 경로로 클라이언트의 재요청

  - 문제점

    - 포워드 중복: RequestDispather 생성하고, foward로 뷰 이동하는 코드가 중복 호출됨

    - ViewPath 중복: ViewPath 앞 뒷부분 중복 발생, 다른 뷰로 변경하려면 코드를 다 바꾸게됨

    - 사용하지 않는 코드: response 등 사용하지 않게 되는 코드가 많음, 또한 이러한 코드는 테스트 케이스 작성도 어려움

    - 공통 기능 처리가 어려움: 메서드로 뽑아내도, 호출이 필요하며, 안 호출하는 실수 가능
      -> **공통 처리**의 문제: 서블릿(컨트롤러) 호출 이전에 공통 기능이 처리해야 한다.
      -> **프론트 컨트롤러(Front Controller) 패턴**

- **FrontController 패턴 특징**

  - 프론트 컨트롤러 서블릿 하나로 CLI 요청 받음
  - 상황에 맞는 컨트롤러를 찾아 호출
  - 입구를 하나로!
  - 공통 처리 가능
  - 프론트 컨트롤러 외 컨트롤러는 서블릿 안 써도 됨!
  - 스프링 웹 MVC와의 연관
    - 스프링 웹 MVC의 핵심
    - DispatherServlet이 프론트 컨트롤러 패턴

- **DispatherSerlvet**

  - 스프링 MVC의 프론트 컨트롤러
  - 부모 클래스에서 HttpServlet 상속
  - 스프링 부트는 `DispatcherServlet`을 등록하면서 모든 경로(`urlPatterns="/"`)에 대해서 매핑한다.
    - 별도 규정이 있을 경우, 그것이 먼저 동작, 등록
  - 요청 흐름
    - 서블릿이 호출되면 `service()`호출, . . . , `doDispatch()`호출
  - `doDispatch()`: 핸들러 찾기, 핸들러 어댑터 찾기 -> 실제 호출 . . .처럼 예제와 같은 방식
  - 동작 순서
    1. 핸들러 조회
    2. 핸들러 어댑터 조회
    3. 핸들러 어댑터 실행
    4. ModelAndView 반환
    5. viewResolver 호출
    6. View 반환
    7. 뷰 랜더링



## IoC / DI

- **IoC 컨테이너, DI 컨테이너**
  - 필요
    - **Rod Johnson, “J2EE Design and Development”(2002)**
      - EJB의 문제점 지적
      - EJB 없이 제작한 애플리케이션 예시, 스프링 핵심 개념, 기반 코드
      - **BeanFactory, ApplicationContext, POJO, 제어의 역전, 의존관계 주입(DI)**
      - Juergen Hoeller, Yann Caroff가 오픈소스 프로젝트 제안, 개발
      - J2EE(EJB)-겨울을 넘어서 새로운 시작이라는 의미로 스프링
    - OCP 준수하는 객체지향적 애플리케이션을 위해 DIP 이루어져야함
    - 이를 위해 클라이언트 코드를 건드리지 않고 구현체를 변경해주어야 함
    - 관심사의 분리가 필요
      - 사용 영역과 구성 영역을 분리하라
      - 인스턴스를 생성하고 의존성을 주입해 줄 컨테이너가 필요
      - 객체 인스턴스를 사용하는 영역 외부에서 그 객체 의존성을 주입(DI)
    - 위와 같은 DI 컨테이너 작성은 많은 코드를 필요로 함 -> 스프링 프레임워크는 이를 제공
  - IoC; Inversion of Control
    - 내가 작성한 코드가 아니라(라이브러리) 프레임워크가 내가 작성한 코드를 제어하고 실행
    - 더 유연하며 개발자의 생산성을 높여줌
  - 최근에는 DI에 초점을 맞춰 DI컨테이너라 주로 말함. 혹은 어셈블러, 오브젝트 팩토리 등으로 불리기도 함.

- 스프링 컨테이너와 빈, 컴포넌트
  - 애노테이션 기반 / xml 기반
    - `AnnotationConfigApplicationContext`
  - `@Configuration` 애노테이션이 붙어 있는 클래스를 구성 정보로 사용
  - `@Bean` 애노테이션이 붙은 메서드를 호출, 반환된 객체는 스프링 컨테이너에 등록
  - 스프링 빈
    - 구성 정보의 `@Bean`으로 등록된 객체
    - 스프링 컨테이너의 `getBean()`메서드로 찾을 수 있음
  - 스프링 컨테이너 내의 스프링 빈 저장소에는 `빈 이름 - 빈 객체`등록 (`Map` 처럼)
  - 빈 생성 과정과 의존관계 주입 과정은 나누어져 있지만
    자바 코드로 등록할 경우 동시에 이루어짐
  - 싱글톤 컨테이너임

- 컴포넌트 스캔

  - 컴포넌트 스캔 방식 빈 등록을 사용할 경우 `@Compoent` 애노테이션 기반으로 빈 탐색
  - **`basePakageClasses`**`= AutoAppConfig.class` 해당 클래스의 패키지를 탐색 위치로 지정
  - **지정하지 않았을 경우** `@ComponentScan` 붙은 설정 정보 클래스의 패키지가 시작 위치
  - 또한 **스프링 부트**의 경우, 시작 정보인 **`@SpringBootApplication`** 을 프로젝트 시작 루트 위치에 두는 것이 관례이며, 이 설정 내부에 **`@ComponentScan`** 이 들어있음.
  - 컴포넌트 스캔은 `@Component`뿐만 아니라 다음 또한 대상에 포함한다: (`@Component`를 가지고 있기에)
    - `@Component`: 컴포넌트 스캔에서 사용
    - `@Controller`: 스프링 MVC 컨트롤러에서 사용
    - `@Service`: 스프링 비즈니스 로직에서 사용
    - `@Repository`: 스프링 데이터 접근 계층에서 사용
    - `@Configuration`: 스프링 설정 정보에서 사용
    - **주의**: 애노테이션에는 **상속관계가 없다.** 애노테이션이 애노테이션을 들고 있는 것은 **자바가 아니라 스프링이 지원하는 것**이다.
    - **애노테이션 부가 기능**: 컴포넌트 스캔 외에 지원하는 기능
      - `@Controller`: 스프링 MVC 컨트롤러로 인식
      - `@Repository`: 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환
        - 안 붙이면 어떻게 되지?
      - `@Configuration`: 스프링 설정 정보로 인식, 스프링 빈이 싱글톤을 유지하도록 추가 처리함
      - `@Service`: 특별한 처리는 없으나 개발자 간 정보 전달에 용이

  

## VO vs DTO vs DAO

- DTO / VO
  - 계층 별 데이터 전달을 위한 객체
  - 로직을 갖지 않음
  - VO는 불변
- DAO; Data Access Object
  - 데이터 접근 객체



## 추가

-  RootApplicationContext
- WebApplicationContext
  - MVC 컴포넌트
    - 컨트롤러 등
  - 핸들러 어댑터
  - 필터의 경우?
    - 서블릿 필터 체인
- CoC
- 서블릿 컨테이너
  - 서블릿 관리
  - tomcat 등
  - 애플리케이션 앞단에 위치
- 앞단은 서블릿 컨테이너(실제 요청 처리) - DispatcherServlet
  - WebAppContext의 컨트롤러를 호출
- 스프링 컨테이너는 자원 처리 / 메시지 처리