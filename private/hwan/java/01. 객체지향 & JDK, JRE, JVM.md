## 객체지향이란? 
- 상태와 행위를 가진 객체를 만들고, 그 객체들 간 유기적인 상호작용을 통해 로직을 구성하는 방식
- 객체 간의 독립성(책임)이 뚜렷하게 생기기 때문에 코드의 재사용성이 높고 유지보수가 용이하다.


### 4가지 특징 
- 캡슐화
	- 객체에 정보 은닉을 목적으로 외부의 직접적인 접근을 막고 객체가 제공하는 필드와 메서드를 통해서만 접근이 가능하다.
	- 그로 인해 변화가 일어나도 다른 곳에서 미치는 영향을 최소화 시킨다.
- 상속 
	- 상위 클래스의 **특성**을 하위 클래스에 상속하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미
	- 자식 클래스를 외부로부터 은닉하는 캡슐화의 일종
	- 재사용성의 관점이 아닌 기능의 확장 관점일 때 사용해야 한다.
- 추상화
	- 현실 사물들의 공통적인 특징을 파악한 후 하나의 객체로 만들어내는 것 
	- 즉, 필요로 하는 속성이나 행동을 추출하는 작업이다.
- 다형성
	- 하나의 객체가 여러 가지 타입을 가질 수 있는 것 
	- 서로 다른 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 방식
	- 오버로딩, 오버라이딩 등


### SOLID 
> 응집도를 높이고 결합도를 낮춰야 한다는 관점에서 정리 
> 응집도 : 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다.
> 결합도 : 모듈간의 상호 의존 정도로서 결합도가 낮으면 모듈간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.

- **SRP (단일 책임 원칙, Single Responsibility Principle)**
	- 객체는 단 한 가지의 책임만을 가져야 한다. 
	- 객체가 수정되는 이유는 오직 하나뿐이여야만 한다.
	- 메서드가 단일 책임 원칙을 지키지 않을 경우 나타나는 대표적인 문제가 **분기 처리를 위한 if문** 사용이다.
	- ex) 한 사람이 프론트도 하고 백엔드도 하며, 디자인까지 다 한다면?, 데이터를 읽고 화면을 보여주는 객체가 있을 때 읽어 오는 기능이 변경된다면?
	
- **OCP (개방 폐쇠 원칙, Open Closed Principle)**
	- 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
	- 즉, 기능이 변경되거나 확장할 때 그 기능을 사용하는 코드는 수정하지 않는다.
	- 상위 클래스나 인터페이스를 사용한다.
	- 장점 : 유연성, 재사용성, 유지보수성
	- ex) JDBC, JVM 
	
- **LSP (리스코프 치환 원칙, Liskov Substitution Principle)**
	- 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
	- 상속 관계가 아닌 클래스들을 상속 관계로 설정할 시 위배된다.
	- 리스코프 치환 원칙이 지켜지지 않으면 개방 폐쇠 원칙을 지킬 수 없게 된다. 
		- `instance of`로 확인하는 등
	- ex) 직사각형 - 정사각형
	
- **ISP (인터페이스 분리 원칙, Interface Segregation Principle)**
	- 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야한다.
	- 즉, 하나의 일반적인 인터페이스보다는 클라이언트를 기준으로 분리되어 구체적인 여러 개의 인터페이스가 효율적이라는 것이다.
	- 한 클라이언트의 영향이 다른 클라이언트에 영향이 없도록 하는 것이다.
		- 클라이언트 입장에서 사용하는 기능만 제공하도록 인터페이스를 분리함으로써 한 기능에 대한 변경의 여파를 최소화 할 수 있다. ( SRP )
	
- **DIP (의존 역전 원칙, Dependency inversion principle)**
	- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 조수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
	- 변하기 쉬운 저수준 모듈의 변화에 고수준 모듈이 영향받지 않게 하는 것 (OCP)
	- ex) 자동차 - 스노우타이어 ( x ) => 자동차 - (스노우타이어, 일반타이어..) 타이어, JDBC
	
		


### 객체지향 VS 절차지향 VS 함수형 프로그래밍 
**절차지향** 
데이터 흐름에 기반하여 작업의 진행순서대로 프로그래밍하는 기법  (프로시저로 구성, 데이터 중심 )
대표적으로 C언어가 있다. 
- 장점 
	- 프로그램의 흐름을 쉽게 추적할 수 있다.
- 단점 
	- 유지보수가 어렵다. 
	- 디버깅이 어렵다.

**객체지향**
실제 세계를 모델링하여 소프트웨어를 개발하는 방법 ( 객체 중심 )
- 장점 
	- 코드의 재활용성이 높다. (유지보수가 용이)
	- 디버깅이 쉽다. 
- 단점 
	- 처리속도가 절차지향에 비해 느리다. 
	- 설계에 많은 시간소요가 들어간다.

**함수형 프로그래밍**
거의 모든 것을 순수 함수로 나누어 문제를 해결하는 기법 
- 순수함수는 동일한 인자에 대해 항상 동일한 결과를 반환해야 하며 함수의 실행이 외부에 영향을 끼치지 않는다. 
- 순수함수는 그 자체가 독립적이며 Side-Effect가 없기 때문에 Thread에 안전성을 보장받는다.
- 장점 
	- 높은 재사용성, 가독성, 유지보수성, 불변성 
- 단점 
	- 내,외부 데이터의 상태를 조작할 수 없다.
- Java에서는 람다, Stream, 함수형 인터페이스로 함수형 프로그래밍을 활용할 수 있다.



## JDK, JRE, JVM

![](https://i.imgur.com/P5HKSY2.png)
[출처]( [https://www.inflearn.com/course/the-java-code-manipulation/dashboard](https://www.inflearn.com/course/the-java-code-manipulation/dashboard)) 
- JDK ( Java Development Kit)
	- 자바 개발 도구 
	- JRE + 개발에 필요한 툴 ( javac 등 )
- JRE ( Java Runtime Environment )
	- 자바 실행 환경 
	- 자바로 작성된 응용프로그램이 실행되기 위한 최소환경 
	- JVM + 클래스 라이브러리 ( Java API )
- JVM ( Java Virtual Machine )
	- 자바 가상 머신으로 자바 바이트코드(.class 파일)를 OS에 특화된 코드로 변환(인터프리터와 JIT 컴파일러)하여 실행한다.
	- 자바와 OS사이에 중개자 역할을 하며 자바로 작성된 모든 어플리케이션은 모두 JVM 위에서만 실행된다. (자바가 OS에 독립적인 이유)
	- 하지만 JVM은 OS 종속적이기 때문에 해당 OS에서 실행가능한 JVM이 필요하다.


###  컴파일 과정
1. java 코드 작성 
2. 컴파일러(javac)가 java파일을 컴파일하여 바이트코드(.class) 생성
3. 바이트코드를 JVM의 클래스 로더에게 전달 
4. 클래스 로더는 동적 로드를 통해 필요한 클래스들을 JVM의 메모리에 올린다.
5. JVM의 실행 엔진이 JVM 메모리에 올라온 바이트코드들을 명령어 단위로 하나씩 가져와서 실행한다. 이때, 인터프리터와 JIT 컴파일러가 사용된다.


### JVM 메모리 구조 

![](https://lh3.googleusercontent.com/91WJ4H5EUr0pM_BVSK8Immgo4f8ZfWvx34ieE9Wv8anC_QwbhS_ND60AOU6NqxzkGEJxmlySwv6jbg37Rt5dUjvWua2SKoxViZvAdtr5hJeyYLAr1hNN6DfsHHwUfWENJ5-FQ1IahZg1-iUDB6MO6w)
[출처]( [https://www.inflearn.com/course/the-java-code-manipulation/dashboard](https://www.inflearn.com/course/the-java-code-manipulation/dashboard)) 

#### **클래스 로더** 
> 자바는 동적 로드, 즉 컴파일 타임이 아닌 런타임(바이트코드를 실행할 때)에 클래스를 로드하고 링크하는 특징이 있다. 
> 이 동적 로드를 담당하는 부분이 바로 클래스 로더이다.
- 로딩, 링크, 초기화 3단계로 나뉘게 된다.
- **로딩** 
	- 각 자바 바이트 코드(.class)는 JVM에 의해 메소드 영역에 다음 정보를 저장한다.
		- 로드된 클래스를 비롯한 그의 부모 클래스 정보
			- Fully-Quailified Class Name(FQCN) : 클래스 로더, 클래스 패키지 경로, 패키지 이름, 클래스 이름을 모두 포함한 값
		- 클래스 파일과 Class,Interface,Enum의 관련 여부 
		- 변수나 메소드 등의 정보
	- 로딩이 끝나면 해당 클래스 타입의 Class 객체를 생성하여 힙 영역에 저장한다.
- **링크**
	- 코드 내부의 래퍼런스를 연결하는 과정
		- 검증 : .class 파일 형식이 유효한지 검사 
		- 준비 : static 변수와 기본 값 메모리 할당
		- 분석 : 심볼릭 메모리 래퍼런스를 실제 메모리 래퍼런스로 교체
- **초기화** 
	- static 변수를 초기화하고 값을 할당하는 과정
	
	
#### **메모리 ( Runtime Data Areas )**
> 프로그램을 수행하기 위해 운영체제로부터 할당받는 메모리 영역 
- **힙**
	- 모든 스레드가 공유하는 영역이며 프로그램을 실행하면서 생성된 모든 인스턴스 또는 객체를 저장하는 공간
	- GC에 있어서만 회수 가능
- **메소드 영역** 
	- 모든 스레드가 공유하는 영역이며 클래스 수준의 정보(클래스 이름, 부모 클래스 이름, 메소드, 변수) 저장 
		- 클래스 변수도 저장한다. (static 변수 등)
	-  **런타임 상수 풀** 
		- 각 클래스와 인터페이스의 상수 뿐만 아니라, 메소드와 필드에 대한 모든 래퍼런스까지 담고 있는 테이블 
		- 즉, 어떤 메소드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메소드나 필드의 실제 메모리 상 주소를 찾아서 참조
	- 힙 영역이 아닌 곳을 Metaspace(자바 8이후)라고 부르며  자바 8이전에는  Permanent 영역이라고 힙 영역에 있었지만 Java8부터는 Native영역으로 이동하였다.
		- 다만 static Object 변수나 상수는 Heap영역에 있게 함으로써 GC의 대상이 되도록 하였다.
- **스택**
	- 지역 변수 배열, 피연산자, 프레임 데이터를 갖는다.
		- 프레임 데이터는 현재 실행 중인 메소드가 속한 클래스의 런타임 상수 풀, 이전 스택 프레임에 대한 정보, 현재 메소드가 속한 클래스, 객체에 대한 참조 등을 뜻한다.
	- 각 스레드마다 하나씩 존재하며, 스레드가 시작될 때 생성되며 스택 프레임을 쌓는다.
		- 메소드 실행이 완료되거나 예외가 던져지면 스택에서 빠지게 된다.
- **PC** 
	- 스레드마다 가지고 있는 Program Counter 
	- 메소드 안에서 바이트코드 몇 번째 줄을 실행하고 있는지와 같은 정보를 갖고 있다.
- **네이티브 메소드 스택** 
	- 자바 바이트코드가 아닌 다른 언어로 작성된 네이티브 코드를 위한 스택
	- 성능 향상을 목적으로 작성되었으며 JVM 스택과 나눠어져 있다고 하더라도 자바 코드를 수행하다 JNI를 호출하면, JVM 스택에서 네이티브 메소드 스택으로 확장할 뿐이다.



#### **실행 엔진**

> 메모리에 적재된 바이트코드를 기계어로 변경하여 실행 및 바이트코드를 운영체제에 맞게 해석해주는 역할 
- **인터프리터** 
	- 런타임 중에 바이트코드를 한 줄씩 읽어 네이티브 코드로 변환 
	- 컴파일보다 속도가 느리다. (한 줄씩 읽으니깐)
- **JIT(Just In Time)**
	- 인터프리터의 속도 이슈를 해결하기 위해 같이 사용하며 자주 실행되는 바이트코드영역을 런타임 중에 기계어로 컴파일하여 사용한다.
	- JVM이 호출되는 메소드 각각에 대한 호출마다 호출 횟수를 누적해서 그 횟수가 특정 수치를 초과할 때 컴파일한다. 
	- 인터프리터와 동시에 돌고 있다.
-   GC ( Garbage Collector )
    -   더 이상 참조되지 않는 객체를 모아서 메모리 정리


### 컴파일 언어 vs 인터프리터 언어
#### **컴파일 언어**
- 코드 실행 전 빌드과정을 거칩니다. 
	- 빌드 과정에서 소스 코드 전체를 한번에 기계어로 변환 후 실행합니다.
- 장점 
	- 실행 속도가 빠릅니다. 
- 단점 
	- 실행 전 빌드 시간이 필요하기 때문에 느릴 수 있다.

#### **인터프리터 언어**
- 빌드타임에는 아무것도 하지 않고 런타임시에 한줄 한줄 읽어가며 변한하여 실행한다.
- 장점 
	- 코드 변경 시 빌드 과정없이 즉시 실행이 가능하여 테스트에 용이
- 단점 
	- 실행 속도가 느리다 
	- 코드의 오류 인지 시점이 늦다.

### Garbage Collector 동작과정
> 메모리 관리 기법 중 하나로, 동적으로 할당했던 메모리 영역 중 필요 없게 된 영역을 해제하는 기능
- 장점 
	- 메모리를 수동으로 관리하면서 발생하는 메모리 누수, 해제된 메모리 접근 등의 에러를 예방할 수 있다.
- 단점 
	- GC의 메모리 해제 타이밍을 알 기 어렵다
	- 어떠한 메모리 영역이 해제의 대상이 될 지 검사하고, 실제로 해제하는 일이 모두 오버헤드다.

#### Mark And Sweep 
Java는 기본적으로 Mark And Sweep 방식으로 메모리 관리를 합니다. 
- GC 루트에서부터 해당 객체에 접근 가능한지 해제의 기준으로 삼는다.
	- GC 루트는 stack 영역의 로컬 변수, 메소드 영역의 static 변수, 네이티브 메소드 영역의 JNI 참조가 될 수 있다.
	- **Mark** : 루트부터 그래프 순회를 통해 연결된 객체들을 찾는다. 
		- Reachable : 루트로부터 연결된 객체 
		- Unreachable : 루트로부터 연결되지 않는 객체
	- **Sweep** : 연결이 끊어진 객체들을 지운다.
	- **Compaction** (Optional) : 퍼포먼스 향상을 위해 Sweep 후에 분산된 객체들을 Heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않는 부분으로 나눈다.
- 의도적으로 특정 순간에 GC를 실행해야하며 애플리케이션과 GC 실행이 병행된다.


#### Heap 영역별 동작방식 
![](https://i.imgur.com/7HurxIN.png)
[출처](https://www.waitingforcode.com/off-heap/on-heap-off-heap-storage/read)
> Heap은 Young Generation과 Old Generation 두 부분으로 나눠진다.
- **Young Generation** : 새로운 객체들이 할당되는 영역 
	- 여기서 발생하는 GC를 minor gc라고 한다.
	- 이 영역은 eden, survival 0, survival 1로 나뉜다.
		- eden : 새롭게 생성된 객체들이 할당되는 영역 
		- survival : minor gc로부터 살아남은 객체들이 존재하는 영역 
			- survival 0, 1 둘 중 하나는 비어있어야 한다.
- **Old Generation** : Yong Generation에서 오랫동안 살아남은 객체들이 존재하는 영역
	- 여기서 발생하는 GC를 major gc라고 한다.
- Heap영역을 위와 같이 분리한 이유는 통계적으로 대부분의 객체가 수명이 짧으므로 특정 부분만 탐색함으로써 GC의 성능을 높이기 위함이다.

**과정** 
- 새로운 객체들은 Eden 영역에 할당이 됩니다. 
- 이후 Eden 영역이 꽉 차게 될 경우 minor gc가 일어나며 루트로부터 Reachable이라고 판단되는 객체는 Survival 0으로 옮겨진다. 
	- 이때, minor gc에서 살아남은 객체의 age-bit를 증가시킨다. (Aging)
- 시간이 지난 후 Eden영역이 다시 꽉차게 되면 minor gc가 일어나 Reachable이라고 판단되는 객체를 이번에는 Survival 1로 옮겨진다.
- 해당 과정을 반복하다 age-bit가 threshold에 도달하면 Old Generation으로 이동한다. (Promotion)
- 이후 Old Generation이 꽉 차게 되면 Major GC가 일어난다.
	- 이때, minor gc에 비해 시간이 오래 걸린다.

**GC의 실행 방식** 
> Stop the World  : GC를 실행하기 위해 JVM이 어플리케이션 실행을 멈추는 것 
- Serial GC 
	- 하나의 쓰레드로 GC 실행 
	- Stop The World 시간이 길다 
	- 싱글 스레드 환경 및 Heap 영역이 매우 작을 때 사용
	- Mark And Sweep 이후 Compaction 과정도 포함
- Parallel GC 
	- 여러 개의 스레드로 GC를 실행 
	- 멀티코어 환경에서 사용하며 Java 8의 기본 GC 방식이다.
	- minor gc에 대해서만 멀티 스레딩으로 수행
- Parallel Old GC 
	- Parallel GC에서 major gc도 멀티 스레딩으로 수행
	- Mark Summary Compaction을 사용
- CMS GC 
	- Stop The World 시간을 최소화하기 위해 고안 
	- 대부분의 GC 작업을 어플리케이션과 동시에 실행
	- compact 과정이 없다.
- G1 GC 
	- Heap을 Region으로 나누어 사용 
	- 전체 Heap이 아닌 Region 단위로 탐색
	- Java9부터 기본 GC 방식


### Java 버전 특징 
#### Java 8 
- Heap Permanent Generation 제거 
	- Heap 영역에 저장되던 PermGen 영역을 native 영역으로 이동
- Interface Default And Static Methods
- 함수형 인터페이스
- 람다 
	- 메소드를 하나의 식으로 표현 
	- 익명 함수라고 부르며, 메소드의 매개 변수로 전달되거나 메소드의 결과로 반환될 수 있는 특징이 있어 함수를 변수로 다룰 수 있다는 장점이 있다.
- Stream 
	- 람다식으로 요소 처리 내용만 전달할 뿐, 반복은 컬렉션 내부에서 일어난다.
- Date And Time API 제공
	- LocalDate, LocalTime, LocalDateTime 등 
- Optional 
	- null에 대한 참조를 안전하게 확인
- GC : Paralle GC 

#### Java 11 
- String 클래스 메소드 추가 
	- `isBlank()`, `repeat()` 등 
- Files 클래스 메소드 추가 
- 컬렉션 인터페이스 메소드 추가 
	- toArray() : 원하는 타입의 배열을 선택하여 반환 가능 
- Predicate 인터페이스 메소드 추가 
	- not() : 부정 의미
- 람다 로컬 변수 var 사용
- 자바 파일 실행 
	- 컴파일하지 않고 바로 java파일 실행 가능 
- GC : G1 GC로 변경