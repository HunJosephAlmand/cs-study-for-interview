## HTTP란?
HTTP는 HyperText Transfer Protocol의 약자로 서버-클라이언트 모델을 따르면서 요청/응답(request/response) 구조로 웹 상에서 정보를 주고 받을 수 있는 프로토콜이다. 
주로 HTML 문서를 주고 받는데 사용하지만 이외에도 JSON, XML 데이터 등의 정보를 주고 받을 수 있다. 

### HTTP 특징 

#### 클라이언트 서버 구조 
요청/응답(request/response) 구조이다. 
클라이언트는 서버에 요청을 보내고, 응답을 대기하게 되고 서버가 요청에 대한 결과를 만들어서 응답하게 된다. 
서버와 클라이언트를 분리함으로써 비즈니스 로직은 서버 개발에서 맡고, 클라이언트의 종류에 따라 UI 처리, api 응답 처리는 클라이언트 쪽에서 담당하면 된다. 즉, 역할을 분배하여 생산성이 높아진다.

### 비연결성 (Connectionless)
HTTP는 기본적으로 Connectionless 방식으로 작동하는데, 이 방식은 클라이언트와 서버가 한번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어 버리는 특징을 갖고 있다.
기본적으로 자원 하나에 대해서 하나의 연결을 만든다. 

#### 장점 
- 많은 사람이 웹을 이용하더라도 실제 동시 접속을 최소화하여 더 많은 유저의 요청을 처리
- 불특정 다수를 대상으로 하는 서비스에 적합한 방식

#### 단점 
- 연결을 끊었기 때문에, 클라이언트의 이전 상태(로그인 유무 등)을 알 수 가 없는데, 이러한 HTTP의 특징을 Stateless라고 한다. 
- 정보를 유지할 수 없음으로 웹 서비스를 하는 데 여러 문제가 생기게 된다. 클라이언트가 로그인을 했더라도 다음 요청에선 로그인을 유지할 수 가 없다.
	- Connectionless, Sttateless 특성을 가진 HTTP의 단점을 해결하기 위해 cookie, session, jwt 토큰 등이 도입되었다.
- 연결을 끊기 때문에 TCP/IP 연결을 새로 맺어야 한다. 
	- 3 way handshake 시간 추가 
	- HTTP/1.1에서는 HTTP 지속 연결(Persistent Connections)로 해결한다. keep-alive라고 부르기도 한다. 
	- 매번  TCP 연결을 하는 것이 아닌 한 번 TCP 초기화를 한 이후에 여러 개의 파일을 송수신할 수 있다.
	- 하지만 다수의 리소스(이미지, CSS 등)를 처리하려면 요청할 리소스 개수에 비례해서 대기 시간이 길어지는 단점이 있다.(HOL Blocking)
	- HTTP/2, HTTP/3에서는 더 많은 최적화가 이루어 진다.
![](https://i.imgur.com/xGEz48J.png)
![](https://i.imgur.com/dDLYgFX.png)



### 무상태 (Stateless)
비연결적인 특성으로 연결이 해제되기 때문에 서버가 클라이언트의 상태를 보존하지 않는다.
즉, 클라이언트가 이전 요청과 같은 데이터를 원한다고 하더라도 다시 서버에 연결을 하여 동일한 요청을 시도해야 한다. 
HTTP는 이러한 무상태 특성으로 인해 독립적인 쌍의 요청과 응답을 처리하기 때문에, 다음과 같은 장점을 가진다. 

#### 장점 
- 클라이언트 요청이 증가하면 수평 확장 즉, 스케일 아웃에 유리하다. 
- 특정 서버가 장애가 발생해도 대처하기 쉽다.

#### 단점 
- 요청 측에서 데이터를 많이 보내줘야 한다. 
- 모든 것을 무상태로 설계할 수 없는 한계가 있다. 
	- 로그인한 사용자의 경우 로그인 했다는 상태를 서버에서 유지시켜야 한다. 
	- 이를 위해 브라우저 쿠키나 서버 세션 등을 사용해서 상태를 유지하게 된다.


## HTTP 메시지
![](https://i.imgur.com/eiuOgBV.png)
[출처](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)
HTTP 메시지 구조의 공통점으로 start-line, header, body로 이루어져 있다
header의 경우 HTTP 전송에 필요한 모든 부가 정보가 들어가 있다. (메시지 바디의 내용, 메시지 바디의 크기, 요청 클라이언트 정보 등)


### 요청 
![](https://i.imgur.com/SuPCJrn.png)
#### start-line
- method : HTTP 메서드 
- path : 요청 대상(절대경로[?쿼리])
- HTTP 버전

#### header 
요청에 대한 정보를 담고 있다. User-Agent 등 여러 헤더가 있다. 

#### body 
요청을 할 때 함께 보내는 데이터 즉, 실제 전송할 데이터를 담는 부분이다. HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터를 전송할 수 있다. 


### 응답 
![](https://i.imgur.com/z4JQTwj.png)
#### start-line
- HTTP 버전
- HTTP 상태 코드 : 요청 성공, 실패를 나타낸다 
- HTTP 상태 메시지 : 사람이 이해할 수 있는 짧은 상태 코드 설명 글

#### header 
응답에 대한 정보를 담고 있다.

#### body 
응답에는 대부분의 경우 본문이 있다. 보통 데이터를 요청하고 응답 메시지에는 요청한 데이터를 담아서 보내기 때문이다. 

## HTTP 헤더 

### 개요 
#### RFC2616 (과거)
- HTTP 헤더 
	- General 헤더 : 메시지 전체에 적용되는 정보 ex) Connection: close 
	- Request 헤더 : 요청 정보 (요청 시에만 존재) ex) User-Agent : Mozilla/5.0
	- Response 헤더 응답 정보 (응답 시에만 존재) ex) Server: Apache 
	- Entity 헤더 : Entity 본문을  해석할 수 있는 정보 제공 ex) Content-Type: text/html 

- HTTP 바디 
	- Entity 헤더 : Entity 본문을 해석할 수 있는 정보 제공 
	- Entity 본문 : 실제 전달할 데이터 
	- 메시지 본문에는 Entity 본문 내용이 포함되어 있다.

![](https://i.imgur.com/zBOfA3L.png)

#### RFC7230 
엔티티(Entity)용어가 표현(Representation)으로 변경
- 표현(Representation) = 표현 메타데이터(representation Metadata) + 표현 데이터 (representation data)
- 메시지 본문을 페이로드(payload)라고 부르기도 한다. 


![](https://i.imgur.com/wZC3Q2C.png)
- 마찬가지로 표현 헤더는 표현 데이터를 해석할 수 있는 정보를 제공한다.
	- 데이터 유형(html, json), 데이터 길이 등

### 표현 
> 표현 헤더는 전송, 응답 둘다 사용한다.
- Content-Type : 표현 데이터의 방식 
	- 미디어 타입, 문자 인코딩
	- text/html; charset=utf-8, application/json 
- Content-Encoding : 표현 데이터의 압축 방법 
	- 표현 데이터를 압축하기 위해 사용하며 전달하는 곳에서 압축 후 인코딩 헤더를 추가하고 읽는 쪽에서 인코딩 헤더의 정보로 압축을 해제하게 됨. 
	- gzip, deflate, identity(압축 안함) 
- Content-Language : 표현 데이터의 자연 언어 
	- ko, en, en-US
- Content-Length : 표현 데이터의 길이
	- 바이트 단위 
	- Transfer-Encoding(전송 코딩)을 사용할 시 사용하면 안됨


### 협상 (콘텐츠 협상)
> 클라이언트가 선호하는 표현을 정해주어 서버 측에서 클라이언트에게 해당 표현으로 전달할 수 있도록 해주는 헤더 
> 요청시에만 사용한다.

- Accept : 클라이언트가 선호하는 미디어 타입 전달 
- Accept-Charset : 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding : 클라이언트가 선호하는 압축 인코딩
- Accept-Language : 클라이언트가 선호하는 자연 언어

우선순위를 지정해줄 수 있다. 
```HTTP
GET /event 
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
```
- Quality Values(q)를 이용하여 높은 우선순위를 지정해줄 수 있다. q=1의 경우 생략 가능 
- 구체적일수록 우선순위가 높다. text/* 보다 text/plain이 우선순위가 더 높다.
- 해당 Quality Values가 여러 값이 존재한다면, 구체적인 것을 기준으로 미디어 타입을 맞춰 Quality Values를 맞춘다.


## HTTP 문제점 
- HTTP는 평문 통신 즉, 정보를 text 형식으로 주고 받기 때문에 중간에 인터셉트할 경우 데이터 유출이 발생할 수 있다. 
- 통신 상태를 확인하지 않기 때문에 위장이 가능하다. 
- 완전성을 증명할 수 없기 때문에 변조가 가능하다.


## HTTP Method

### HTTP API 
API의 기능마다 이름을 정해줘서 명확한 API가 좋은 API일까? 
수많은 기능을 관리해야 한다면 URI가 지나치게 길어져 가독성이 떨어지고 유지보수에도 여러움을 겪게될 것이다. 
API 설계에서 가장 중요한 것응ㄴ 리소스 식별이다. 만약 회원 관리 API라면 가장 중요한 리소스는 회원인 것이다. 따라서 `/members` URI와 매핑시켜주게 된다. 
하지만 리소스 중심으로 짤 경우 수많은 기능들에서 중복되는 URI가 존재하게 된다. 이를 위해 리소스와 행위를 분리하게 되었는 데 여기서 행위가 HTTP Method가 된다.
주로 GET, POST, PUT, PATCH, DELETE가 사용되고 이외에도 HEAD, OPTIONS, CONNECT, TRACE와 같은 메서드가 있다.

- HEAD : GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환 
- OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명, 주로 CORS에서 사용한다. 
- CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정 
- TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행


### GET 
> 리소스 조회 

클라이언트가 서버에게 정보를 요청할 때 사용하는 메서드 
필요한 정보를 특정하기 위해 URL 끝에 Key-Value 쌍으로 파라미터를 포함하여 전송을 하는데, 이 부분을 Query String이라고 부른다. (URL 끝에 `?`가 붙으며 여러 개일 경우 `&`로 구분한다.) 즉, URL에 데이터가 노출되어 보안에 취약하다.
메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지는 않는다.
또한, 캐시가 가능하다는 특징을 가지고 있다. 한 번 서버에 GET 요청을 한 적이 있다면 브라우저가 그 결과를 저장해두고 이후 동일한 요청은 브라우저에 저장된 값으로 가져오게 된다.

### POST 
> 요청 데이터 처리 (주로 리소스 생성)

클라이언트가 바디를 통해 전달한 데이터를 서버가 처리하도록 요청하는 메서드 
서버는 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행하게 된다. 즉, 리소스를 생성하는 것만 아니라, 리소스마다 다양하게 처리 한다. 
데이터를 생성하거나 변경하기도 하지만 특정 프로세스를 처리하기도 한다. 
URL에 데이터를 노출하지 않아서 기본 보안은 되어있지만 일반적으로 캐싱할 수 없다. (특정한 경우에는 가능하다, 본문 내용까지 캐시 키로 고려해야 하는 데, 구현이 쉽지 않다.)
바디를 통해 데이터를 전달하기 때문에 헤더 필드 중 Body의 데이터를 설명하는 Content-Type이라는 헤더 필드가 포함되고 어떠한 데이터 타입인지를 명시해줘야 한다. 

### PUT 
해당 리소스가 없다면 생성하고, 있다면 완전히 대체하는 메서드 
서버의 리소스를 수정하는 메서드이지만 리소스 자체를 대처하는 성격을 가진다. 
클라이언트가 리소스 위치를 알고 있을 때 사용한다. 즉, 클라이언트가 리소스를 식별하며 `/member/1`과 같은 URI로 요청을 보낸다.


### PATCH 
리소스 부분 변경하는 메서드 
PUT과 가장 큰 차이점은 부분 변경한다는 점이다. 해당 리소스를 완전히 대처하는 것은 PUT, 부분 변경은 PATCH이다. 


### DELETE
지정한 리소스를 삭제하는 메서드

## HTTP 메서드 속성 
![](https://i.imgur.com/BMtxvZ8.png)

### 안전 
호출해도 리소스를 변경하지 않는다. 
GET, HEAD, OPTIONS, TRACE에 해당 한다. 

### 멱등성 
멱등성은 여러번 적용하더라도 결과가 달라지지 않는 것을 말한다. 
멱등성을 보장하는 메서드는 
- GET: 한 번 조회하든, 두 번 조회하든 같은 결과가 조회
- PUT : 결과를 대처하기 때문에 같은 요청을 여러번 해도 최종 결과는 같다. 
- DELETE : 결과를 삭제하기 때문에 같은 요청을 여러번 해도 삭제된 결과는 똑같다.

멱등성을 보장하지 않는 메서드는 
- POST : 요청마다 생성하기 때문에 멱등하지 않다. (중복결제 가능)
- PATCH

PATCH의 경우 멱등으로 설계할 수 도 있고, 아니게도 설계가 가능하다. 
```
{ name: "kim"}
```
다음과 같이 요청할 때는 멱등이다. 
```
{ "operation": "add", "age": 10"}
```
하지만 위와 같이 한번 호출할 때 마다 나이를 10 더하는 식으로 설계하는 경우 멱등이 아니게 된다.

### 캐시가능 
GET, HEAD, POST, PATCH 메서드는 캐시가 가능하다.
하지만 실제로는 GET, HEAD 정도만 캐시로 사용한다. POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데 구현이 쉽지 않고 변경되기 때문에 유지하기 어렵기 때문이다.


## HTTP status code
> 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능 

### 1XX (Informational)
요청이 수신되어 처리중임을 뜻하며 거의 사용하지 않는다. 


### 2XX(Successful)
요청 정상 처리되었음을 뜻한다. 
- 200(OK)
	- 요청 성공
	- GET과 같은 조회 요청에 성공적으로 응답하는 경우
- 201 (Created)
	- 리소스 생성 성공
	- POST와 같은 생성요청으로 리소스가 정상적으로 생성된 경우 
	- 생성된 리소스는 응답의 Location 헤더 필드로 식별
- 202 (Accepted)
	- 요청이 접수되었으나 처리가 완료되지 않았을 경우
	- 배치 처리 같은 곳에서 사용한다.
- 204 (No content)
	- 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없을 경우
	- 결과 내용이 없어도 메시지만으로 성공을 인식할 수 있다.

### 3XX 
요청을 완료하기 위해 추가적인 행동이 필요한 경우를 나타내는 상태코드 
웹 브라우저는 3XX 응답의 결과에 Location 헤더가 있을 경우, Location 위치로 자동 이동한다. 

#### 영구 리다이렉션 
특정 리소스의 URI가 영구적으로 이동 즉, 원래의 URL를 사용하지 않는 경우
- 301 (Moved Permanetly)
	- 리다이렉트시 요청 메서드가 GET으로 변경된다. 
	- 본문이 제거될 수 있다.
- 308 (Permanent Redirect)
	- 301과 기능은 동일하다 
	- 리다이렉트시 요청 메서드와 본문이 유지된다.

#### 일시적인 리다이렉션 
특정 리소스의 URI가 일시적으로 변경
- 302 (Found)
	- 리다이렉트시 요청 메서드가 GET으로 변경된다. 
	- 본문이 제거될 수 있다
- 307 (Temporary Redirect)
	- 302와 기능은 동일하다. 
	- 리다이렉트시 요청 메서드와 본문이 유지된다.
- 303 (See other)
	- 302와 기능은 동일하다 .
	- 리다이렉트 요청 메서드가 GET으로 변경된다.

#### PRG(Post - Redirect - Get) Pattern 
페이지 새로고침은 요청을 다시 보내는 것이다 따라서 멱등하지 않은 요청인 POST에 새로고침을 하면 중복 요청이 생성되게 된다. 이걸 방지하고자 일시적인 리다이렉션을 사용하여 문제를 방지할 수 있다. POST 요청이 완료되면 리다이렉션을 통해 GET으로 요청을 변경시켜준다. 

초기 302 스펙의 의도는 HTTP 메서드를 유지하기 위한 것이었다. 하지만 대부분의 브라우저가 GET으로 바꾸어버렸고, 애매한 302를 대신하여 303, 307이 등장했다. 

스펙으로는 303과 307를 권장하지만 현실적으로는 302를 대다수 사용하며 GET으로 메서드를 변경해도 상관 없다면 302를 사용한다. 

#### 캐시 목적 
- 304 (Not Modified)
	- 캐시를 목적으로 사용한다. 
	- 클라이언트에게 리소스가 수정되지 않았음을 알린다. 
	- 304 응답은 메시지 바디를 사용하면 안된다. (로컬 캐시를 사용해야 하므로)
	- 조건부 GET, HEAD 요청시 사용한다.

### 4XX
> 클라이언트 오류 
> 클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에, 똑같은 재시도면 실패함.

클라이언트에서 잘못된 스펙으로 데이터를 보냈거나 인증, 인가가 만족되지 않아 서버에서 요청을 수행할 수 없음을 뜻한다. 
- 400(Bad Request)
	- 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없는 경우 
	- 요청 포멧, 데이터 등의 오류 
- 401 (Unauthorized)
	- 인증이 되지 않은 클라이언트에서 리소스에 접근하는 경우 
	- 오류 발생 시 응답에 WWW-authenticate 헤더와 함께 인증 방법을 설명
- 403 (Forbidden)
	- 인증자격은 있지만 해당 리소스에 접근할 권한이 불충분한 경우 
- 404 (Not Found)
	- 요청 리소스를 찾을 수 없는 경우 
	- 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶은 경우

### 5XX
> 서버 오류 
> 서버에 문제가 있기 때문에 재시도하면 성공할 가능성이 있다.

- 500 (Internal Server Error)
	- 서버 내부 문제가 발생한 경우 
- 503 (Service Unavailable)
	- 서버에 트래픽 문제 혹은 점검으로 잠시 요청을 처리할 수 없는 경우


## HTTP 1.1 VS HTTP 2.0

### HTTP/1.0 
기본적으로 한 연결당 하나의 요청을 처리할 수 있기 때문에 RTT증가를 불러오게 되었다. 
여기서 RTT란, 패킷이 목적지에 도달하고 나서 다시 출발지로 돌아오기까지 걸린 시간이며 패킷 왕복 시간을 뜻한다. 
서버와 TCP의 3-way-handshaking 과정을 통해 커넥션을 맺어야 하는 데 매번 연결이 발생하기 때문에 RTT가 증가하였다.
이를 해결하기 위해 이미지 스프리팅, 코드 압축, 이미지 Base64 인코딩을 사용하곤 했다. 


### HTTP/1.1 
HTTP 1.0에서 발전한 것으로 매번 연결 하는 것이 아닌 한 번 TCP 초기화를 한 이후에 keep-alive라는 옵션으로 여러 개의 파일을 송수신할 수 있게 바뀌었다. (지속 커넥션)![](https://i.imgur.com/9kb99Bq.png)

- 지속 커넥션 : 지정한 timeout동안 커넥션을 닫지 않는 방식
- 파이프라이닝 커넥션 : 한 요청에 대한 응답을 기다리지 않고 다음 요청을 전달하는 방식 
	- HTTP는 응답 순서를 보장하지 않기 때문에 서버측에서는 먼저 온 요청을 처리할 때까지 다음 요청은 작업이 완료되더라도 기다려야 한다 
	- 이때 발생하는 성능 저하 현상을 HOL Blocking (Head Of Line Blocking)이라고 한다. 
- 무거운 헤더 구조 
	- 쿠키 등과 같이 많은 메타데이터가 헤더에 들어 있고 압축되지 않아 무거웠다. 
	- 또한, 헤더 구조의 중복이 있었다.


### HTTP/2.0
기존의 HTTP1.1 버전의 성능 향상에 초점을 맞춘 프로토콜이다. (확장의 개념)
HTTP/1.1의 RTT 줄이기 위해 헤더를 압축하여 대역폭을 절약했고, 하나의 TCP 커넥션에 여러 요청을 동시에 보내 RRT를 줄였으며, 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능을 가지고 있다. 

### 바이너리 프레이밍
![](https://i.imgur.com/TTaiDBy.png)
HTTP/1.1에서 text형식으로 전달되는 요청이 HTTP/2.0에서는 메시지를 프레임 단위로 나누게 되고 바이너리 형식으로 인코딩된다. 
즉, HTTP/2.0은 HTTP 프로토콜 통신을 바이너리 인코딩된 프레임의 교환으로 세분화된다. 그런 다음 이 프레임은 특정 스트림에 속하는 메시지에 매핑되어, 모든 프레임은 단일 TCP 연결 내에서 다중된다.
이로 인해 파싱, 전송 속도가 빨라졌고 오류 발생 가능성도 낮아지게 되었다.
- 메시지 : 논리적 요청 또는 응답 메시지에 매핑되는 프레임의 전체 시퀀스 
- 프레임 : HTTP/2.0에서 통신의 최소 단위이며 각 최소 단위에는 하나의 프레임 헤더가 포함된다. 이 프레임 헤더는 최소한 프레임이 속하는 스트림을 식별한다.



#### 멀티플렉싱 
> 한 커넥션에 여러개의 메세지를 동시에 주고 받을 수 있음

![](https://i.imgur.com/PIgrtIv.png)

여러 개의 스트림을 사용하여 송수신하는 것이다. 이를 통핸 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림은 멀쩡하게 동작할 수 있다. 
여기서 스트림이란, 시간이 지남에 따라 사용할 수 있게 되는 일련의 데이터 요소를 가리키는 데이터 흐름을 뜻한다. 

![](https://i.imgur.com/QnJ9uQ5.png)
병렬적인 스트림들을 통해 데이터를 서빙하며 스트림 내의 데이터들도 쪼개져 있다. 애플리케이션에서 받아온 메시지를 독립된 프레임으로 분할하고 서로 송수신한 이후 다시 조립하여 데이터를 주고 받게 된다. 
이를 통해 단일 연결을 사용하여 병렬로 여러 요청을 받을 수 있고 응답을 줄일 수 있게되어 HTTP/1.X의 문제점이였던 HOL Blocking을 해결하였다.



### 스트림 우선순위 
리소스간 우선 순위를 설정할 수 있다.
CPU, 메모리 및 기타 리소스의 할당을 제어하는 것일 뿐으로 가중치라는 의미가 강하고, 특정 순서로 처리되도록 강제할 수 는 없다.


#### 헤더 압축 
> 헤더의 크기를 줄여 페이지 로드 시간 감속 

![](https://i.imgur.com/DdfhtXg.png)
HTTP1.1의 문제점인 큰 헤더를 해결하기 위해 압축한다. 
허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식을 가진다. 

> 허프만 코딩 
> 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트 수를 사용하여 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현해서 전체 데이터의 표현에 필요한 비트양을 줄이는 원리


![](https://i.imgur.com/WYlDthY.png)
HPACK 형식에서는 헤더를 정적 테이블과 동적 테이블로 나눈다. 정적 테이블에는 모든 연결에서 사용될 가능성이 있는 공용 HTTP 헤더 필드를 담아둔다. 동적 테이블에는 특정 연결에서 교환되는 값에 따라 갱신된다. 따라서 동적 테이블에 대해서는 호프만 코딩을 사용하여 압축하고 정적 테이블에 대해서는 값을 인덱스로 대처하여 각 요청의 크기를 줄일 수 있다.


#### 서버 푸시
![](https://i.imgur.com/RNRmEPy.png)
클라이언트가 서버에 요청을 하지 않아도 서버가 추가적인 리소스를 클라이언트에게 전송할 수 있다. 
웹 페이지를 구성하는 다양한 리소스가 있기 때문에 서버는 클라이언트가 해당 리소스를 요청하기 까지 기다리지 않고 필요한 리소스를 먼저 클라이언트에게 푸시함으로써 웹 페이지 로딩 시간을 줄일 수 있다.
