---

mindmap-plugin: basic

---

# Java

## JDK : java Development Kit
- Java 개발 목적
- 특징
   - JRE를 포함하고 있음 (JDK ⊃ JRE)
- 구성
   - JVM
   - 자바 클래스 라이브러리
   - 자바 명령

## JRE : Java Runtime Environment
- Java 실행 목적
- 특징
   - Java용 SDK(Software Development Kit)
   - javac가 있다?

## JVM
- 메모리 구조
- JVM이란?
   - 자바와 운영체제 사이에서 중개자 역할을 수행
   - 운영체제에 구애 받지 않고 프로그램을 `실행`할 수 있도록 도와줌 (단, JVM은 운영체제에 종속적)
   - 가비지 컬렉터를 사용한 메모리 관리 자동 수행
   - 다른 하드웨어와 다르게 레지스터 기반이 아닌 스택 기반으로 동작
- 구조
   - Class Loader
      - 런타임 시에 동적으로 클래스를 로드
      - JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈
   - Execution Engine
      - 클래스 로더를 통해 JVM 내의 Runtime Data Area에 배치된 바이트 코드들을 명렁어 단위로 읽어서 실행
      - 인터프리터 방식 → (일정 기준이 넘어가면) → JIT컴파일러 방식
   - GC
      - 힙 메모리 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색 후 제거하는 역할
   - Runtime Data Area
      - JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역
         - Method Area
            - 모든 쓰레드가 공유하는 메모리 영역
            - 클래스, 인터페이스, 메소드, 필드, Static 변수 등의 바이트 코드를 보관
         - Heap Area
            - 모든 쓰레드가 공유하며, new 키워드로 생성된 객체와 배열이 생성되는 영역
            - 메소드 영역에 로드된 클래스만 생성이 가능
            - Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역
         - Stack Area
         - PC register
            - 현재 수행중인 JVM 명령의 주소를 갖는다
            - 쓰레드가 시작될 때 생성
            - 생성될 때마다 생성되는 공간으로 쓰레드마다 하나씩 존재
            - 쓰레드가 어떤 부분을 무슨 명령으로 실행해야할 지에 대한 기록을 하는 부분
         - Native Method Stack
            - 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역
      - 참고 : https://steady-coding.tistory.com/305

## GC (Garbage Collector)
- GC란?
   - 힙 메모리 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색 후 제거하는 역할
- 동작과정
- 종류
   - Serial GC
   - Parallel GC
   - Parallel Old GC
   - CMS GC (Concurrent Mark-Sweep)
   - G1 GC
      - Java 9 버전부터 기본 GC 방식으로 채택
   - 참고 : https://s2choco.tistory.com/14

## Java의 컴파일 과정
- 과정
   - java 파일 작성 → .java
   - 자바 컴파일러가 .java 컴파일 → .class
   - JVM 클래스로더에게 전달
   - 클래스 로더는 동적로딩을 통해, 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역 (JVM의 메모리) 에 올린다
      - 클래스 로더 세부 동작
         - 로드 - 클래스 파일을 가져와 JVM 메모리에 로드
         - 검증 - 자바언어 명세 및 JVM 명세에 명시된 대로 구성되어 있는지 검사
         - 준비 - 클래스가 필요로 하는 메모리 할당 (필드, 메서드, 인터페이스 등)
         - 분석 - 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
         - 초기화 - 클래스 변수들을 적절한 값으로 초기화 (static 필드)
   - 실행엔진(java)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 실행, 이때, 실행 엔진은 두가지 방식으로 변경??
      - 인터프리터
         - 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행
         - 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다
      - JIT 컴파일러 (just-in-time compiler)
         - 인터프리터의 단점을 보완하기 위해 도입된 방식
         - 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행
         - 하나씩 인터프리팅하여 실행x 바이트 코드 전체가 컴파일된 바이너리 코드를 실행 o
         - 따라서 전체적인 실행속도는 인터프리팅 방식보다 빠름
   - 참고
      - https://gyoogle.dev/blog/computer-language/Java/컴파일%20과정.html

## 컴파일 언어 vs 인터프리터 언어
- 컴파일언어
   - 정의
   - 특징
      - 컴파일 단계와 실행 단계가 분리
      - 런타임 상황에서는 이미 기계어로 모든 소스코드가 변환되어 있기 때문에 빠르게 실행할 수 있다
      - 실행 파일 생성
   - 예시
      - C/C++, Go
- 인터프리터 언어
   - 정의
      - 원시코드(소스코드)를 기계어로 변환하는 과정없이 한줄 한줄 해석하여 바로 명령어를 실행하는 언어
   - 특징
      - 런타임에 인터프리터가 코드 한 줄씩 중간 코드인 바이트코드로 변환 후 즉시 실행
      - 기계어로 변환하지 않기 때문에 빌드 시간이 없다
      - Runtime 상황에서는 한 줄씩 실시간으로 읽어서 실행하기 때문에 컴파일 언어에 비해 속도가 느리다
   - 예시
      - Python, Javascript, Ruby
- 자바는 컴파일언어일까 인터프리터 언어일까?
   - 자바 컴파일러가 .java를 자바 바이트 코드 .class로 번역한다
   - 자바 바이트코드는 자바 인터프리터를 기계어로 번역되어 한줄씩 실행된다
   - 처음에는 인터프리터 언어로써 사용되다가 성능향상을 위해 JIT 컴파일러를 추가하여 컴파일 언어의 장점을 가져왔다고 한다

## Java LTS 버전
- Java 8
   - 함수형프로그래밍 지원
      - 람다표현식
      - 함수형 인터페이스
      - Stream
   - Default Method
   - Optional
      - NPE 처리에 효과적
   - 날짜 관련 클래스 추가
   - String 메서드 추가
- Java 11
   - var
   - HTTP Client
   - 모듈
   - 프로파일링 및 진단
   - 가비지 수집
      - Java 11의 기본 GC는 G1GC(가비지 우선 가비지 수집기)
      - CMS(Concurrent Mark and Sweep) GC는 사용할 수 있지만 Java 9 이후 사용X
   - 성능 향상
- Java 17
   - 텍스트 블록
   - record
   - sealed class
   - instance of 변수
   - 스위치 문법 람다