# 자료 구조

- 자료 구조의 목적
  - 추상화
    - 사용자는 내부 구현을 신경 쓸 필요가 없음
  - 최적화



## Array

- 원소들을 메모리의 연속된 위치에 저장
- 특정 위치 원소의 수정 / 접근을 $O(1)$에 할 수 있음

> 원소들을 메모리의 연속된 공간에 저장하는 자료 구조입니다.
> 특정 위치 원소의 수정 / 접근을 $O(1)$에 수행할 수 있지만,
> 생성 시에 크기를 정해줘야 하며, 그 크기 이상의 원소를 저장할 수는 없습니다.



## List

### ArrayList

- 배열의 단점을 극복한 동적 배열
  - 생성할 떄 크기를 지정하지 않아도 되고
  - 크기를 키울 수 있음
    - 재할당 연산에는 기존 배열의 크기에 비례하는 시간이 걸림
    - 배열 마지막에 원소 하나를 추가하는 데에는 상수 시간이 걸림
      - size: 실제 원소의 수
      - capacity: 할당받은 메모리의 실제 크기
      - 현재 가진 원소 대비 여유 용량을 확보하는 방식으로
        상수 시간 안에 재할당이 이루어지게 할 수 있음
    - `ensureCapacity()`
- 중간 위치 원소 수정 시에는 모든 원소를 뒤로 한 칸 미뤄야 함

> 크기 문제를 해결한 배열입니다.
> 크기를 동적으로 조절할 수 있기에 동적 배열입니다.



### LinkedList

- 삽입 / 삭제를 선형 시간에 수행 가능
- 각 노드는 이전, 다음 원소에 대한 참조를 가지고 있음
- 연결 리스트 자체는 첫 노드와 마지막 노드에 대한 참조를 가지고 있음: head, tail
- 특정 위치의 원소에 접근하는 데 $O(N)$

> 삽입 및 삭제에 특화된 자료구조입니다.



| 작업 별 비교                             | ArrayList | LinkedList                  |
| ---------------------------------------- | --------- | --------------------------- |
| 이전 원소 / 다음 원소 찾기               | $O(1)$    | $O(1)$                      |
| 맨 뒤에 원소 추가  / 삭제하기            | $O(1)$    | $O(1)$                      |
| 맨 뒤 이외의 위치에 원소 추가 / 삭제하기 | $O(N)$    | $O(1)$                      |
| 임의의 위치의 원소 찾기                  | $O(1)$    | $O(N)$                      |
| 크기 구하기                              | $O(1)$    | $O(N)$ (구현에 따라) $O(1)$ |



## HashTable

- key값의 해시 값을 index로 삼고,
  해당 인덱스에 해당하는 버킷에 데이터를 저장
- 빠른 검색 가능 $O(1)$
- 충돌
  - 해시 값은 무한하지 않기에 충돌이 발생 가능
- 충돌 해결법
  - 분리 연결법(Separate Chaining)
    - 충돌이 발생한 버킷을 연결 리스트로 구성
    - $O(N)$
    - LinkedList / Red-Black Tree
  - 개방 주소법(Open Addressing)
    - 비어 있는 해시 테이블의 공간을 활용하는 방식
    - 탐사(Probing)
      - 비어 있는 자리를 탐색하는 것
      - Linear Probing
        - 버킷 인덱스에서 고정폭만큼 이동, 비어 있는 버킷에 저장
      - Quadratic Probing
        - $2^n$만큼 이동하는 방식
      - Double Hashing Probing
        - 해시된 값을 다시 해싱하는 방식, 추가적인 연산 필요



## Queue / Stack / Deque

- 원소의 추가, 제거 $O(1)$
- 지정된 위치의 원소 확인 $O(1)$



### Queue

- FIFO; First In First Out
  - 먼저 들어간 것이 먼저 나옴



### Stack

- LIFO; Last In First Out
  - 마지막에 들어간 것이 먼저 나옴



### Deque or Dequeue; Double-ended Queue

- 양쪽 방향 모두에서 원소 넣고 뺄 수 있음
- 큐와 스택 모두 구현 가능



## 인덱스 접근 방법

- 배열의 경우
  - random access
- 표현법
  - 선형 시간복잡도
- 순환 큐로 구현하는 방식으로 오버헤드를 줄임