# CPU 스케줄링

## CPU 스케줄링 개요

- CPU 스케줄링(CPU scheduling)
  - 운영체제가 프로세스들에게 CPU 자원을 배분하는 것



### 프로세스 우선순위

- 입출력 집중 프로세스(I/O bound process)
  - 입출력 대기상태에 머무를 때가 많음
  - 입출력 버스트(burst): 입출력장치를 기다리는 작업
  - 입출력 버스트가 많은 프로세스
- CPU 집중 프로세스(CPU bound process)
  - 실행 상태에 더 많이 머물러 있음
  - CPU 버스트(burst): CPU를 이용하는 작업
  - CPU 버스트가 많은 프로세스
- CPU 집중 프로세스 보다는 입출력 집중 프로세스의 우선순위가 더 높은 것이 효율적
- 운영체제는 각 프로세스 PCB에 우선순위를 명시



### 스케줄링 큐

- 운영체제가 일일히 모든 PCB를 검사하여 우선 자원을 점유할 프로세스를 결정하는 것은 비효율적
- 스케줄링 큐(scheduling queue)
  - 준비 큐(ready queue): CPU 이용을 위한 대기
  - 대기 큐(waiting queue): I/O 장치 이용을 위한 대기



### 선점형과 비선점형 스케줄링

- 선점형 스케줄링(preemptive scheduling)
  - 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당 가능
  - 자원 독점을 막고 고르게 자원 배분이 가능하지만, 문맥 교환 과정의 오버헤드 발생 가능
- 비선점형 스케줄링(non-)
  - 자원을 사용 중인 프로세스의 종료 / 대기 상태로 전환 이전에는 다른 프로세스가 끼어들 수 없음
  - 문맥 교환 오버헤드는 적지만, 자원을 고르게 나누기 힘듦



## CPU 스케줄링 알고리즘

### 선입 선처리 스케줄링

- FCFS; First Come Fitst Served
- 준비 큐에 삽입된 순서대로 프로세스를 처리
- 비선점형 스케줄링
- 호위 효과(convoy effect)
  - CPU를 오래 사용하는 프로세스로 인해, 뒤의 짧게 사용하는 프로세스가 대기해야 하는 상황



### 최단 작업 우선 스케줄링

- SJF; Shortest Job First
- 준비 큐에 삽입된 프로세스 중 CPU 이용 시간이 가장 짧은 프로세스부터 실행
- 기본적으로는 비선점형, 하지만 선점형으로 구현 가능
  - 선점형 최단 작업 우선 스케줄링 = 최소 잔여 시간 우선 스케줄링



### 라운드 로빈 스케줄링

- round robin
- FCFS + 타임 슬라이스
- 타임 슬라이스: 프로세스가 CPU를 사용할 수 있는 시간
  - 타임 슬라이스 크기가 중요
    - 너무 클 경우 호위 효과 발생 가능
    - 너무 낮을 경우 문맥 교환 오버헤드의 문제



### 최소 잔여 시간 우선 스케줄링

- SRT; Shortest Remaining Time
- SJF + 라운드 로빈
- 타임 슬라이스만큼 CPU를 사용하되, 다음 프로세스는 SRT 기준으로 설정



### 우선 순위 스케줄링

- priorty
- 프로세스 우선순위를 부여, 거기에 따라 분배
  - 동일 우선순위의 경우 FCFS
- SJF, SRT의 경우 우선 순위 스케줄링의 일종
- 기아 현상이 가능
  - 우선순위가 높은 프로세스에 의해 낮은 프로세스는 계속 자원을 할당받지 못함
  - 에이징(aging): 방지 기법
    - 오랫동아 대기한 프로세스의 우선순위를 점차 높임



### 다단계 큐 스케줄링

- multilevel queue
- 우선순위별로 준비 큐를 사용(준비 큐 여럿을 사용)
- 우선순위가 가장 높은 큐에 있는 프로세스를 우선 처리
- 큐별로 타임 슬라이스를 다르게 지정하거나, 다른 스케줄링 알고리즘을 적용하는 것도 가능



### 다단계 피드백 큐 스케줄링

- multilevel feedback queue
- 다단계 큐 스케줄링의 기아 현상 발생 가능성을 개선한 스케줄링
- 프로세스가 다른 큐로 이동 가능
  - 실행시간이 긴 프로세스가 우선순위가 낮아져, 다른 큐로 이동할 수 있음
- 구현이 복잡하지만, 가장 일반적으로 사용됨