# 자료구조 / 알고리즘

## 선형 자료구조

### 배열

* 메모리 상에 원소를 '연속하게' 배치한 자료구조

#### 배열의 성질

* O(1)에 k 번째 원소를 확인/ 변경 가능
  * Random Access(순서에 상관없이 접근)

* 추가적으로 소모되는 메모리의 양이 거의 없음
* Cache hit rate가 높음
* 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림

### 리스트

#### ArrayList(vector)

* 특정 인덱스 값 읽기/수정
  * O(1)
* 삽입
  * 끝 부분
    * 배열의 공간이 남아 있을 경우 O(1)
    * 없을 경우 O(N)
  * 그 외
    * O(N)
* 삭제
  * 끝 부분
    * O(1)
  * 그 외
    * O(N)
* cf : Java의 Vector
  * 동기화됨 -> 매우느린 속도
  * 배열을 복제 할 때 현재 크기의 두 배의 크기의 배열 생성
    * ArrayList는 현재 배열 크기의 절반 크기만을 더한(1.5배) 배열 생성

#### LinkedList

* 메모리가 물리적으로 흩어져 있다.
* k 번째 원소를 확인/변경하기 위해 O(k)가 필요함
* 임의의 위치에 원소를 추가/임의 위치에 원소 제거는 O(1)
* 원소들이 메모리 상에 연속해있지 않아 Cache hit rate이 낮지만 할당이 쉬움
* 종류
  * 단일 연결 리스트
  * 양방향 연결 리스트
  * 원형 연결 리스트

​	

### 해시테이블

* 키에 대응되는 값을 저장하는 알고리즘

* 특징

  * 충돌이 없을 경우 모든 연산(삽입, 삭제, 탐색, 수정) O(1)

* 해시 함수

  * 임의의 길이의 데이터를 고정된 길이의 데이터로 대응시키는 함수

* 간단한 해시테이블 구현

* 연결 리스트와 해시 코드 함수

* 키의 해시 코드 계산
  * key의 자료형은 보통 int, long
  * 키는 무한하지만 해시 코드는 무한하지 않다.

* 해시 코드를 이용해 배열의 인덱스를 구한다.
  * `hash(key)  % array_length` 

* 충돌

  * 서로 다른 키가 같은 해시 값을 갖게 될 때 발생

* 충돌 회피

  * Separate Chaining(분리 연결법),
    * 각 인덱스마다 연결 리스트 혹은 트리를 하나씩 둔다.
    * 해시 함수를 제대로 구성하지 못했을 경우, 해시 테이블에 대한 연산의 시간이 O(N)이 된다.

  * Open Addressing(개방 주소법)
    * 인덱스에 바로 (키, 값)쌍 사용
    * 해시 값에 이미 데이터가 존재할 경우(중복) 데이터가 없는 칸을 찾을 때 까지 해시 값에 1을 더한다.
    * 삭제 시 해당 노드를 삭제하면, 그 배열을 비우는 것이 아니라 배열이 삭제 되었다는 쓰레기 값을 따로 둔다.
      * 아래의 나머지 노드들도 탐색하기 위함
      * 삽입 시에는 쓰레기 값이 들어있는 칸에 삽입

    * 클러스터링
      * 해시 배열의 특정 영역에만 데이터가 뭉치는 현상
      * 뭉친 영역의 탐색 비용이 크다.
    * 크기 제한이 있다.




* 균형 이진 탐색 트리를 사용하는 방법도 있음

### 큐

* 한쪽 끝(rear)에 원소를 삽입하고 다른 한쪽 끝(front)에서 원소를 가져올 수 있는 자료구조
* 원소의 추가 O(1)
* 원소의 제거 O(1)
* 제일 앞/뒤의 원소 확인 O(1)
* 제일 앞/뒤가 아닌 나머지 원소들의 확인/변경
  *  원칙적으로 불가능
* 구현 방식
  * 배열
    * 순환 큐

  * 연결 리스트


### 스택

* 한쪽 끝에서만 원소를 삽입하거나 삭제할 수 있는 자료구조.
* 원소 추가 O(1)
* 원소 삭제 O(1)
* 최상단 원소 확인 O(1)
* 최상단 원소가 아닌 나머지 원소들의 확인/변경 불가능(원칙적으로)
* 자바
  * 스택 사용을 지양하라?
    * 동기화된 자료구조(성능)
    * 벡터를 상속받음

  * 보통 **Deque**를 많이 사용한다.
  * 동기화된 자료구조가 필요할 때는 외부 라이브러리를 사용한다.


