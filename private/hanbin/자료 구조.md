# 자료 구조

- 자료 구조의 목적
  - 추상화
    - 사용자는 내부 구현을 신경 쓸 필요가 없음
  - 최적화



## Array

- 원소들을 메모리의 연속된 위치에 저장
- 특정 위치 원소의 수정 / 접근을 $O(1)$에 할 수 있음

> 원소들을 메모리의 연속된 공간에 저장하는 자료 구조입니다.
> 특정 위치 원소의 수정 / 접근을 $O(1)$에 수행할 수 있지만,
> 생성 시에 크기를 정해줘야 하며, 그 크기 이상의 원소를 저장할 수는 없습니다.



## List

### ArrayList

- 배열의 단점을 극복한 동적 배열
  - 생성할 떄 크기를 지정하지 않아도 되고
  - 크기를 키울 수 있음
    - 재할당 연산에는 기존 배열의 크기에 비례하는 시간이 걸림
    - 배열 마지막에 원소 하나를 추가하는 데에는 상수 시간이 걸림
      - size: 실제 원소의 수
      - capacity: 할당받은 메모리의 실제 크기
      - 현재 가진 원소 대비 여유 용량을 확보하는 방식으로
        상수 시간 안에 재할당이 이루어지게 할 수 있음
    - `ensureCapacity()`
- 중간 위치 원소 수정 시에는 모든 원소를 뒤로 한 칸 미뤄야 함

> 크기 문제를 해결한 배열입니다.
> 크기를 동적으로 조절할 수 있기에 동적 배열입니다.



### LinkedList

- 삽입 / 삭제를 선형 시간에 수행 가능
- 각 노드는 이전, 다음 원소에 대한 참조를 가지고 있음
- 연결 리스트 자체는 첫 노드와 마지막 노드에 대한 참조를 가지고 있음: head, tail
- 특정 위치의 원소에 접근하는 데 $O(N)$

> 삽입 및 삭제에 특화된 자료구조입니다.



| 작업 별 비교                             | ArrayList | LinkedList                  |
| ---------------------------------------- | --------- | --------------------------- |
| 이전 원소 / 다음 원소 찾기               | $O(1)$    | $O(1)$                      |
| 맨 뒤에 원소 추가  / 삭제하기            | $O(1)$    | $O(1)$                      |
| 맨 뒤 이외의 위치에 원소 추가 / 삭제하기 | $O(N)$    | $O(1)$                      |
| 임의의 위치의 원소 찾기                  | $O(1)$    | $O(N)$                      |
| 크기 구하기                              | $O(1)$    | $O(N)$ (구현에 따라) $O(1)$ |



## HashTable

- key값의 해시 값을 index로 삼고,
  해당 인덱스에 해당하는 버킷에 데이터를 저장
- 빠른 검색 가능 $O(1)$
- 충돌
  - 해시 값은 무한하지 않기에 충돌이 발생 가능
- 충돌 해결법
  - 분리 연결법(Separate Chaining)
    - 충돌이 발생한 버킷을 연결 리스트로 구성
    - $O(N)$
    - LinkedList / Red-Black Tree
  - 개방 주소법(Open Addressing)
    - 비어 있는 해시 테이블의 공간을 활용하는 방식
    - 탐사(Probing)
      - 비어 있는 자리를 탐색하는 것
      - Linear Probing
        - 버킷 인덱스에서 고정폭만큼 이동, 비어 있는 버킷에 저장
      - Quadratic Probing
        - $2^n$만큼 이동하는 방식
      - Double Hashing Probing
        - 해시된 값을 다시 해싱하는 방식, 추가적인 연산 필요



## Queue / Stack / Deque

- 원소의 추가, 제거 $O(1)$
- 지정된 위치의 원소 확인 $O(1)$



### Queue

- FIFO; First In First Out
  - 먼저 들어간 것이 먼저 나옴



### Stack

- LIFO; Last In First Out
  - 마지막에 들어간 것이 먼저 나옴



### Deque or Dequeue; Double-ended Queue

- 양쪽 방향 모두에서 원소 넣고 뺄 수 있음
- 큐와 스택 모두 구현 가능



## 인덱스 접근 방법

- 배열의 경우
  - random access
- 표현법
  - 선형 시간복잡도
- 순환 큐로 구현하는 방식으로 오버헤드를 줄임



## 트리(Tree)

### 기본 개념

- 계층 관계를 갖는 객체들을 표현하는 데 사용
- 계층 관계가 없는 자료들의 경우에도 빠른 연산을 위하여 사용
- 노드와 간선으로 구성
  - 부모, 자식, 형제, 선조, 자손 노드
  - 루트: 최상단 노드
  - 리프: 최하단 노드
- 루트에서 노드까지 도달하기 위해 거쳐야 하는 간선의 수를 해당 노드의 **깊이**(depth)라고 하며
  가장 깊숙히 있는 노드의 깊이를 **높이**(height)라고 함
- 서브트리(subtree)
  - 특정 노드와 그 자손을 묶으면 그것도 트리가 됨
    - $t$ 를 루트로 하는 서브트리라고 부름
  - 트리의 재귀적 속성
- 순회
  - 재귀적 특성을 이용하여 루트 방문 -> 서브트리 방문하는 방식으로 구현
  - 높이 계산
    - 서브트리 중 가장 큰 것의 높이 + 1
  - 전위 순회(preorder traverse)
    - 루트 - 좌, 우 서브트리 방문
  - 중위 순회(inorder traverse)
    - 좌 - 루트 - 우 방문
  - 후위 순회(postorder traverse)
    - 좌 - 우 서브트리 - 루트 방문



### 이진 검색 트리(Binary Search Tree)

- 검색 트리(Search Tree)
  - 자료들을 순서에 따라 정렬
  - 원소의 추가 / 삭제 + 특정 원소의 존재 확인 등을 빠르게 수행
  - 이진 검색 트리가 대표적
- 이진 트리(binary tree)
  - 각 노드는 최대 2개의 자식 노드를 가질 수 있음
  - 중위 순회로 정렬된 원소 목록을 얻을 수 있음
  - 이진 탐색과 비슷한 검색 속도
  - 조작
    - 이진 트리는 순회 및 검색에 있어서 정렬된 배열에 비해 이점 없음
    - 조작에 있어서 강점이 발휘
    - 선형 구조의 제약이 없기에 빠른 삽입 가능
    - 삭제의 경우 복잡
      - 합치기 연산을 이용하는 방식
        - 삭제될 노드를 제외한 부분들을 서브트리로 구성,
        - 삭제될 노드를 해당 서브트리와 바꿔침
  - 시간 복잡도
    - 최대 재귀 호출의 경우 트리의 높이 $h$와 같음: $O(h)$
    - 기울어진(skewed) 트리
      - 한쪽으로 기울어진 트리
      - 높이가 높은 트리
    - 평평한 트리의 경우 이 문제가 해결
      - 트리의 최소 높이 $O(logN)$
        (트리 높이가 1 증가할 때마다 들어갈 수 있는 원소가 약 2배씩 증가하기에)
      - -> **균형 잡힌 이진 검색 트리(balanced binary search tree)**



### 균형 잡힌 이진 검색 트리

- 균형 잡힌 이진 검색 트리
  - 완전 이진 트리(Complete Binary Tree)
    - 좌측부터 노드 차 있으며
    - 마지막 레벨을 제외한 레벨은 모두 차 있음
  - 전 이진 트리(Full Binary Tree)
    - 모든 노드가 0개 혹은 2개의 자식 노드를 가짐
  - 포화 이진 트리(Perfect Binary Tree)
    - 모든 레벨이 노드로 꽉 차 있음
  - 이진 탐색 트리
    - 이진 트리이면서 검색에 특화
    - 노드의 key가 unique
    - 부모 key가 좌측 자식 key보다 크고, 우측 자식 key보다 작음
    - 하위 노드도 이진 탐색 트리임

- 대표적으로 Red-Black Tree, AVL 트리가 있음
- 트립(treap)
  - 힙과 트리 속성을 모두 갖춤
- 우선순위 큐
  - $O(logN)$의 시간복잡도로 삽입 / 삭제 가능
  - 균형 잡힌 이진 검색 트리로도 구현 가능하지만, 힙으로 구현하는 것이 더 간단
- 힙
  - 가장 큰 / 작은 원소를 찾는 데 최적화된 이진 트리
  - 원소 추가, 가장 큰 / 작은 원소 꺼내는 데 $O(logN)$의 시간 복잡도
  - ***힙의 대소관계 규칙: 부모 노드 원소는 자식 노드 원소보다 큼***
    - 이진 검색 트리와 다르게
      - 부모 - 자식 관계에만 적용
      - 좌 / 우 원소의 크기를 제한하지 않음
  - ***높이를 제약하기 위한 규칙***
    - 마지막 레벨 제외한 모든 노드에 원소가 가득 차 있어야 함
    - 마지막 레벨 노드는 좌측부터 순서대로 채워져 있음
    - 이진 검색 트리보다 엄격한 형태 규칙
    - 동적 배열을 이용하여 구현 가능
  - 원소 삽입은 모양 규칙 준수하기 위해 마지막 자리에 추가, 이후 올라가면서 대소관계 정리



## 그래프(Graph)

- 트리와 달리 부모 자식 제약이 없기에 다양한 구조를 표현 가능
- 그래프 $G(V, E)$는 정점(vertex)들의 집합 $V$와 이들을 연결하는 간선(edge)들의 집합 $E$로 구성



### 분류

- **방향 그래프(directed graph)**

  - 유향 그래프
  - 각 간선이 방향 속성을 가짐
  - <-> **무향 그래프(undirected graph)**

- **가중치 그래프(weighted graph)**

  - 각 간선이 가중치 속성을 가짐

- **다중 그래프(multigraph)**

  - 두 정점 사이의 여러 간선이 존재할 수 있음
  - <-> **단순 그래프(simple graph)**

- **트리, 루트 없는 트리(unrooted tree)**

  - 부모 자식 관계는 없지만, 트리와 같은 구조
    - 간선을 통해 두 정점을 잇는 방법이 단 하나

- **이분 그래프(bipartite graph)**

  - 서로 다른 그룹에 속한 정점 사이에만 간선이 존재

    ```mermaid
    graph TD
    A{A} --> a(a)
    B{B} --> c(c)
    C{C} --> b(b)
    B --> a
    ```

    

- **사이클 없는 방향 그래프(DAG; directed acyclic graph)**

  - 방향 그래프지만, 자신에게 돌아오는 경로(사이클)는 없음
  - 상호 의존 관계 표현